[
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the name of every singer, country and age starting from the oldest., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c5",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY singer.c1, t1.c2, t1.c5",
            "SELECT-FROM-ORDER BY (CLIENT-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (CLIENT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2 and t1.c5"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the name of every singer, country and age starting from the oldest., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c5",
        "label": "select t1.c1, t1.c2, t1.c5",
        "score": true,
        "real_pred": "select singer.Name, singer.Country, singer.Age",
        "real_label": "select singer.Name, singer.Country, singer.Age",
        "topk_preds": [
            "select singer.Name, singer.Country, singer.Age",
            "select singer.Name, singer.Country & singer.Age",
            "select singer.Name, singer.Country., singer.Age",
            "select singer.Name, singer.Country, singer.Age",
            "select singer.Name, singer.Country, singer.Age.",
            "select singer.Name, singer.Country and singer.Age",
            "select singer.Name, singer.Country, singer.Age",
            "select singer.Name, singer.Country, singer.Age,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the name of every singer, country and age starting from the oldest., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the songs by singer who have been around longer than the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the songs by singer who have been around longer than the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Age",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name (singer.Song_release_year)",
            "select singer.Song_Name del.icio.us"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the songs by singer who have been around longer than the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the locations and names for stadiums with capacities from 5000 to 10000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the locations and names for stadiums with capacities from 5000 to 10000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select stadium.Location, stadium.Name",
        "real_label": "select stadium.Location, stadium.Name",
        "topk_preds": [
            "select stadium.Location, stadium.Name",
            "select stadium.Location., stadium.Name",
            "select t0, stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name, stadium.Capacity",
            "select t0.c 1, stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name,",
            "select stadium.Name, stadium.Location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the locations and names for stadiums with capacities from 5000 to 10000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the location and name for all stadiums with a capacity of 5000 to 10000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the location and name for all stadiums with a capacity of 5000 to 10000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select stadium.Location, stadium.Name",
        "real_label": "select stadium.Location, stadium.Name",
        "topk_preds": [
            "select stadium.Location, stadium.Name",
            "select stadium.Location., stadium.Name",
            "select t0, stadium.Location, stadium.Name",
            "select t0.c 1, stadium.Name",
            "select stadium.Location, stadium.Name,",
            "select stadium.Location, t00.c2",
            "select stadium.Name, stadium.Location",
            "select stadium.Location, stadium.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the location and name for all stadiums with a capacity of 5000 to 10000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the median, minimum, and maximum age of all singers from France., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country (France), c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (MEDIAN, MINIMUM, MAXIMUM",
            "SELECT-FROM-WHERE INVERT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (GROUP BY",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the median, minimum, and maximum age of all singers from France., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country (France), c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select avg(t1.c5), min(t1.c5), max(t1.c5)",
        "label": "select avg(t1.c5), min(t1.c5), max(t1.c5)",
        "score": true,
        "real_pred": "select avg(singer.Age), min(singer.Age), max(singer.Age)",
        "real_label": "select avg(singer.Age), min(singer.Age), max(singer.Age)",
        "topk_preds": [
            "select avg(singer.Age), min(singer.Age), max(singer.Age)",
            "select singer.Age, min(singer.Age), max(singer.Age)",
            "select median(singer.Age), min(singer.Age), max(singer.Age)",
            "select singer.Song_Name, min(singer.Age), max(singer.Age)",
            "select singer.Song_release_year, min(singer.Age), max(singer.Age)",
            "select singer.Name, min(singer.Age), max(singer.Age)",
            "select singer.Singer_ID, min(singer.Age), max(singer.Age)",
            "select singer.Singer_ID, singer.Age, max(singer.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the median, minimum, and maximum age of all singers from France., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country (France), c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the year that had the largest number of concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the year that had the largest number of concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t2.c4",
        "label": "select t2.c4",
        "score": true,
        "real_pred": "select concert.Year",
        "real_label": "select concert.Year",
        "topk_preds": [
            "select concert.Year",
            "select concert.Year, concert.Stadium_ID",
            "select concert.Stadium_ID, concert.Year",
            "select concert.Year, t2.c5",
            "select concert.Year, concert.concert_Name",
            "select concert.Year, t2.c6",
            "select concert.Year, concert.Theme",
            "select concert.Year (concert.concert_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the year that had the largest number of concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "concert",
        "real_label": "concert",
        "topk_preds": [
            "concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the list of years that have the greatest number of concerts., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the list of years that have the greatest number of concerts., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t2.c4",
        "label": "select t2.c4",
        "score": true,
        "real_pred": "select concert.Year",
        "real_label": "select concert.Year",
        "topk_preds": [
            "select concert.Year",
            "select concert.Year, concert.Stadium_ID",
            "select concert.Year, t2.c5",
            "select concert.Year, t2.c6",
            "select concert.Year, concert.concert_Name",
            "select concert.Year, concert.Theme",
            "select concert.Year (t2.c5)",
            "select concert.Year, t2.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the list of years that have the greatest number of concerts., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "concert",
        "real_label": "concert",
        "topk_preds": [
            "concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the stadium name and capacity with the largest number of concerts in 2014 or later., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the stadium name and capacity with the largest number of concerts in 2014 or later., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Capacity",
        "real_label": "select stadium.Name, stadium.Capacity",
        "topk_preds": [
            "select stadium.Name, stadium.Capacity",
            "select stadium.Name, stadium.Capacity, stadium.Highest",
            "select stadium.Name.c2, stadium.Capacity",
            "select stadium.Name, stadium.Capacity, stadium.Average",
            "select stadium.Location, stadium.Capacity",
            "select stadium.Name, stadium.Capacity, stadium.Stadium_ID",
            "select stadium.Name.c3, stadium.Name",
            "select stadium.Name, stadium.Capacity, stadium.Lowest"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the stadium name and capacity with the largest number of concerts in 2014 or later., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the stadium name and capacity with the highest number of concerts since 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GAMMA-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the stadium name and capacity with the highest number of concerts since 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Capacity",
        "real_label": "select stadium.Name, stadium.Capacity",
        "topk_preds": [
            "select stadium.Name, stadium.Capacity",
            "select stadium.Name, stadium.Capacity, stadium.Highest",
            "select stadium.Location, stadium.Capacity",
            "select stadium.Name.c3, stadium.Name",
            "select stadium.Name., stadium.Capacity",
            "select stadium.Name, t0-.c3",
            "select stadium.Name/, stadium.Capacity",
            "select stadium.Capacity, stadium.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the stadium name and capacity with the highest number of concerts since 2014., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the stadium name and capacity with the most concerts since 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the stadium name and capacity with the most concerts since 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Capacity",
        "real_label": "select stadium.Name, stadium.Capacity",
        "topk_preds": [
            "select stadium.Name, stadium.Capacity",
            "select stadium.Name, stadium.Capacity, stadium.Average",
            "select stadium.Name.c2, stadium.Capacity",
            "select stadium.Name.c3, stadium.Name",
            "select stadium.Location, stadium.Capacity",
            "select stadium.Name, stadium.Capacity, stadium.Highest",
            "select stadium.Capacity, stadium.Name",
            "select stadium.Name, stadium.Capacity, stadium.Stadium_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the stadium name and capacity with the most concerts since 2014?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest capacity and the average capacity of all stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (T0).c3, t0.c4, t0.c6",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (T0).c3, avg(t0.c3)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM (GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest capacity and the average capacity of all stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select max(t0.c3), avg(t0.c3)",
        "label": "select max(t0.c3), t0.c6",
        "score": false,
        "real_pred": "select max(stadium.Capacity), avg(stadium.Capacity)",
        "real_label": "select max(stadium.Capacity), stadium.Average",
        "topk_preds": [
            "select max(stadium.Capacity), avg(stadium.Capacity)",
            "select stadium.Highest, stadium.Average",
            "select stadium.Capacity, stadium.Highest, stadium.Average",
            "select stadium.Capacity, stadium.Highest",
            "select stadium.Name, stadium.Capacity, avg(stadium.Capacity)",
            "select stadium.Capacity, stadium.Highest, stadium.Lowest, avg(stadium.Capacity)",
            "select stadium.Stadium_ID, stadium.Highest, stadium.Average",
            "select stadium.Capacity, stadium.Highest, stadium.Lowest, stadium.Average"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest capacity and the average capacity of all stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest capacity and average of all stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT.c3, avg(t0.c3)",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT.c3, avg(t0.c6)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest capacity and average of all stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select max(t0.c3), avg(t0.c3)",
        "label": "select max(t0.c3), t0.c6",
        "score": false,
        "real_pred": "select max(stadium.Capacity), avg(stadium.Capacity)",
        "real_label": "select max(stadium.Capacity), stadium.Average",
        "topk_preds": [
            "select max(stadium.Capacity), avg(stadium.Capacity)",
            "select max(stadium.Capacity), avg(stadium.Average)",
            "select stadium.Capacity, avg(stadium.Average)",
            "select stadium.Capacity, stadium.Average",
            "select stadium.Capacity, avg(stadium.Capacity)",
            "select stadium.Name, stadium.Capacity, stadium.Average",
            "select stadium.Stadium_ID, stadium.Capacity, stadium.Average",
            "select stadium.Highest, stadium.Average"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest capacity and average of all stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the year that had the largest number of concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the year that had the largest number of concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t2.c4",
        "label": "select t2.c4",
        "score": true,
        "real_pred": "select concert.Year",
        "real_label": "select concert.Year",
        "topk_preds": [
            "select concert.Year",
            "select concert.Year, concert.Stadium_ID",
            "select concert.Stadium_ID, concert.Year",
            "select concert.Year, concert.concert_Name",
            "select concert.Year, t2.c5",
            "select concert.Year, t2.c6",
            "select concert.Year, concert.Theme",
            "select concert.Year, concert.concert_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the year that had the largest number of concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "concert",
        "real_label": "concert",
        "topk_preds": [
            "concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What year has the most concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What year has the most concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t2.c4",
        "label": "select t2.c4",
        "score": true,
        "real_pred": "select concert.Year",
        "real_label": "select concert.Year",
        "topk_preds": [
            "select concert.Year",
            "select concert.Year, concert.Stadium_ID",
            "select concert.Stadium_ID, concert.Year",
            "select concert.Year, concert.concert_Name",
            "select concert.Year, t2.c5",
            "select concert.Year, t2.c6",
            "select concert.Year, concert.Theme",
            "select concert.Year, concert.concert_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What year has the most concerts?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "concert",
        "real_label": "concert",
        "topk_preds": [
            "concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: In which year did most concerts take place?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: In which year did most concerts take place?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t2.c4",
        "label": "select t2.c4",
        "score": true,
        "real_pred": "select concert.Year",
        "real_label": "select concert.Year",
        "topk_preds": [
            "select concert.Year",
            "select concert.Year, concert.Stadium_ID",
            "select concert.Stadium_ID, concert.Year",
            "select concert.Year, concert.concert_Name",
            "select concert.Year, t2.c5",
            "select concert.Year, concert.Theme",
            "select concert.Year (t2.c5)",
            "select concert.Year, t2.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: In which year did most concerts take place?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "concert",
        "real_label": "concert",
        "topk_preds": [
            "concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which has the most concerts in a given year?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which has the most concerts in a given year?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t2.c4",
        "label": "select t2.c4",
        "score": true,
        "real_pred": "select concert.Year",
        "real_label": "select concert.Year",
        "topk_preds": [
            "select concert.Year",
            "select concert.concert_Name, concert.Year",
            "select concert.Year, concert.concert_Name",
            "select concert.concert_ID, concert.concert_Name",
            "select concert.Stadium_ID, concert.Theme",
            "select concert.concert_Name, concert.Stadium_ID",
            "select concert.Stadium_ID, concert.concert_Name",
            "select concert.Stadium_ID, concert.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which has the most concerts in a given year?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "concert",
        "real_label": "concert",
        "topk_preds": [
            "concert",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries have singers who are over 40 years old, and have singers who are under 30 years old?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CONTRAST-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINGUISH-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISPATCH-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-SECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries have singers who are over 40 years old, and have singers who are under 30 years old?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select singer.Country",
        "real_label": "select singer.Country",
        "topk_preds": [
            "select singer.Country",
            "select singer.Country, singer.Song_Name",
            "select singer.Country, singer.Age",
            "select singer.Country (singer.Age), singer.Is_male",
            "select singer.Country (singer.Age), singer.Country",
            "select singer.Country, singer.Song_release_year",
            "select singer.Country, singer.Name",
            "select singer.Country, singer.Is_male"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries have singers who are over 40 years old, and have singers who are under 30 years old?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the countries where singers over age 40 and under 30 are from., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE AND-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the countries where singers over age 40 and under 30 are from., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select singer.Country",
        "real_label": "select singer.Country",
        "topk_preds": [
            "select singer.Country",
            "select singer.Country, singer.Age",
            "select singer.Country for both (singer.Age), (singer.Is_male)",
            "select singer.Country for both singer.Age, singer.Is_male",
            "select singer.Country for both groups(singer.Age), singer.Is_male",
            "select singer.Country for both (singer.Age), singer.Is_male",
            "select singer.Country for both groups(singer.Age), (singer.Is_male)",
            "select singer.Country for singer.Age, singer.Is_male"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the countries where singers over age 40 and under 30 are from., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the countries where a singer who is over 40 and another who is under 30 are from., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE and-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the countries where a singer who is over 40 and another who is under 30 are from., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select singer.Country",
        "real_label": "select singer.Country",
        "topk_preds": [
            "select singer.Country",
            "select singer.Country, singer.Age",
            "select singer.Country, singer.Song_Name",
            "select singer.Country, singer.Is_male",
            "select singer.Country, singer.Song_release_year",
            "select singer.Country de, singer.Age",
            "select singer.Country (or singer.Song_Name)",
            "select singer.Country, t1.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the countries where a singer who is over 40 and another who is under 30 are from., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of concerts that have taken place at the stadium with the biggest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ATTACH-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-AT-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GAMMA-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GAMMA-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of concerts that have taken place at the stadium with the biggest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), stadium.Name",
            "select count(*), stadium.Name, stadium.Capacity",
            "select count(*), stadium.Stadium_ID",
            "select count(*), stadium.Stadium_ID, stadium.Name",
            "select count(*), stadium.Capacity",
            "select count(*), stadium.Location",
            "select count(*), stadium.Location, stadium.Capacity"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of concerts that have taken place at the stadium with the biggest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "stadium singer concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many concerts occurred in the stadium with the highest capacity?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ATTACH-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-OF-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many concerts occurred in the stadium with the highest capacity?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), stadium.Name",
            "select count(*), stadium.Stadium_ID",
            "select count(*), stadium.Location",
            "select count(*), stadium.Capacity",
            "select count(*), stadium.Highest",
            "select concert.Stadium_ID, count(*)",
            "select count(concert.concert_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many concerts occurred in the stadium with the highest capacity?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "stadium singer concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all songs sung by a singer older than the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name (Sun), c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all songs sung by a singer older than the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name (Sun), c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Age",
            "select distinct singer.Song_Name",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name del.icio.us"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all songs sung by a singer older than the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name (Sun), c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            "singer singer_in_concert"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the song by singers that are older than the average?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the song by singers that are older than the average?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Age",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name (singer.Song_release_year)",
            "select singer.Song_Name, t1.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the song by singers that are older than the average?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "singer singer_in_concert",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all songs named after singers whose average age is greater than average., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-INSTEAD-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all songs named after singers whose average age is greater than average., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Age",
            "select singer.Name, singer.Song_Name",
            "select singer.Song_Name, avg(singer.Age)",
            "select singer.Song_Name, singer.Age, singer.Is_male",
            "select singer.Song_Name de-avg(singer.Age)",
            "select singer.Song_Name, singer.Age-avg(singer.Age)",
            "select singer.Song_Name, singer.Age-, singer.Is_male"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all songs named after singers whose average age is greater than average., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Display all songs by singers over the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Display all songs by singers over the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select singer.Song_Name",
        "real_label": "select singer.Song_Name",
        "topk_preds": [
            "select singer.Song_Name",
            "select singer.Song_Name, singer.Song_release_year",
            "select singer.Song_Name, singer.Age",
            "select singer.Song_Name, singer.Is_male",
            "select singer.Song_Name, singer.Country",
            "select singer.Song_Name, t1.c7",
            "select singer.Song_Name del.icio.us",
            "select singer.Song_Name de singer.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Display all songs by singers over the average age., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "singer singer_in_concert",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the different countries with singers over 20 years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the different countries with singers over 20 years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select distinct t1.c2",
        "label": "select distinct t1.c2",
        "score": true,
        "real_pred": "select distinct singer.Country",
        "real_label": "select distinct singer.Country",
        "topk_preds": [
            "select distinct singer.Country",
            "select count(distinct singer.Country)",
            "select distinct singer.Country, singer.Age",
            "select distinct singer.Country, singer.Is_male",
            "select distinct singer.Country, singer.Song_Name",
            "select singer.Country",
            "select distinct singer.Country, singer.Song_release_year",
            "select distinct singer.Country,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the different countries with singers over 20 years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out what the different countries have singers older than twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY-HAVING",
            "SELECT-FROM-WHERE descript-FROM-WHERE",
            "SELECT-FROM-WHERE-RECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out what the different countries have singers older than twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select distinct t1.c2",
        "label": "select distinct t1.c2",
        "score": true,
        "real_pred": "select distinct singer.Country",
        "real_label": "select distinct singer.Country",
        "topk_preds": [
            "select distinct singer.Country",
            "select count(distinct singer.Country)",
            "select singer.Country",
            "select distinct singer.Country, singer.Age",
            "select distinct singer.Country, singer.Song_Name",
            "select distinct singer.Country,",
            "select distinct singer.Country, singer.Song_release_year",
            "select distinct singer.Country, singer.Is_male"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out what the different countries have singers older than twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the countries with singers older than 20., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the countries with singers older than 20., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c2",
        "label": "select distinct t1.c2",
        "score": false,
        "real_pred": "select singer.Country",
        "real_label": "select distinct singer.Country",
        "topk_preds": [
            "select singer.Country",
            "select distinct singer.Country",
            "select singer.Country, singer.Age",
            "select singer.Country, singer.Is_male",
            "select distinct singer.Country, singer.Age",
            "select singer.Country, singer.Song_Name",
            "select singer.Country, singer.Song_release_year",
            "select singer.Country,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the countries with singers older than 20., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the list of countries with singers older than twenty?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the list of countries with singers older than twenty?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c2",
        "label": "select distinct t1.c2",
        "score": false,
        "real_pred": "select singer.Country",
        "real_label": "select distinct singer.Country",
        "topk_preds": [
            "select singer.Country",
            "select distinct singer.Country",
            "select list(singer.Country)",
            "select the singer.Country",
            "select specific singer.Country",
            "select country singer.Country",
            "select countries singer.Country",
            "select singer.Country,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the list of countries with singers older than twenty?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the countries that have singers older than twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the countries that have singers older than twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c2",
        "label": "select distinct t1.c2",
        "score": false,
        "real_pred": "select singer.Country",
        "real_label": "select distinct singer.Country",
        "topk_preds": [
            "select singer.Country",
            "select distinct singer.Country",
            "select count(distinct singer.Country)",
            "select singer.Country, singer.Age",
            "select distinct singer.Country, singer.Age",
            "select distinct singer.Country, singer.Song_Name",
            "select specific singer.Country",
            "select singer.Country, singer.Is_male"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the countries that have singers older than twenty years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all countries and show me the total count of singers in each country., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM in-GROUP BY",
            "SELECT-FROM by-GROUP BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-GROUP BY ",
            "SELECT-FROM -GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all countries and show me the total count of singers in each country., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c2, count(*)",
        "label": "select t1.c2, count(*)",
        "score": true,
        "real_pred": "select singer.Country, count(*)",
        "real_label": "select singer.Country, count(*)",
        "topk_preds": [
            "select singer.Country, count(*)",
            "select singer.Country, count(*), singer.Singer_ID",
            "select count(*), singer.Country",
            "select singer.Country, count(*), singer.Song_Name",
            "select singer.Country, count(*),",
            "select singer.Country.c2, count(*)",
            "select singer.Country, count(*)",
            "select singer.Country, count(*), singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all countries and show me the total count of singers in each country., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are all countries where singers over the age of 20 are from?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are all countries where singers over the age of 20 are from?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select distinct t1.c2",
        "label": "select distinct t1.c2",
        "score": true,
        "real_pred": "select distinct singer.Country",
        "real_label": "select distinct singer.Country",
        "topk_preds": [
            "select distinct singer.Country",
            "select singer.Country",
            "select distinct singer.Country, singer.Age",
            "select distinct singer.Country, singer.Is_male",
            "select specific singer.Country",
            "select distinct singer.Country, singer.Song_Name",
            "select distinct singer.Country,",
            "select distinct singer.Country, singer.Song_release_year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are all countries where singers over the age of 20 are from?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are all the countries in which singers over 20 years old are from?., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are all the countries in which singers over 20 years old are from?., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select distinct t1.c2",
        "label": "select distinct t1.c2",
        "score": true,
        "real_pred": "select distinct singer.Country",
        "real_label": "select distinct singer.Country",
        "topk_preds": [
            "select distinct singer.Country",
            "select singer.Country",
            "select count(distinct singer.Country)",
            "select distinct singer.Country, singer.Age",
            "select distinct singer.Country, singer.Is_male",
            "select distinct singer.Country, singer.Song_Name",
            "select specific singer.Country",
            "select countries singer.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are all the countries in which singers over 20 years old are from?., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the countries where singers are over 20 years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the countries where singers are over 20 years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c2",
        "label": "select distinct t1.c2",
        "score": false,
        "real_pred": "select singer.Country",
        "real_label": "select distinct singer.Country",
        "topk_preds": [
            "select singer.Country",
            "select distinct singer.Country",
            "select count(distinct singer.Country)",
            "select singer.Country, singer.Age",
            "select distinct singer.Country, singer.Age",
            "select countries singer.Country",
            "select distinct singer.Country, singer.Is_male",
            "select singer.Country, singer.Is_male"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the countries where singers are over 20 years old., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the numbers of concerts that occurred in the stadium with the largest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ATTACH-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the numbers of concerts that occurred in the stadium with the largest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), stadium.Name",
            "select count(*), stadium.Stadium_ID",
            "select concert.Stadium_ID, count(*)",
            "select count(*), stadium.Capacity",
            "select count(*), stadium.Location",
            "select avg(concert.concert_Name)",
            "select avg(concert.concert_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the numbers of concerts that occurred in the stadium with the largest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "stadium singer concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of concerts held in the largest stadium., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-OF-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ATTACH-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GAMMA-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of concerts held in the largest stadium., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), stadium.Name",
            "select avg(concert.concert_Name)",
            "select count(*), stadium.Stadium_ID",
            "select count(*), stadium.Location",
            "select concert.Stadium_ID, count(*)",
            "select count(*) dependant on stadium.Name",
            "select count(*) dependant on stadium.Stadium_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of concerts held in the largest stadium., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "",
            "",
            "",
            "stadium singer concert",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of concerts that happened in the stadium with the largest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ATTACH-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GAMMA-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEORGE BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of concerts that happened in the stadium with the largest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), stadium.Name",
            "select count(*), stadium.Name, stadium.Capacity",
            "select concert.Stadium_ID, count(*)",
            "select count(*), stadium.Stadium_ID",
            "select count(*), stadium.Capacity",
            "select count(*), stadium.Stadium_ID, stadium.Name",
            "select count(*), stadium.Location, stadium.Capacity"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of concerts that happened in the stadium with the largest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "stadium singer concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of concerts that have taken place in the stadium with the largest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ATTACH-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-AT-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (t2.c3)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT.",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of concerts that have taken place in the stadium with the largest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), stadium.Name",
            "select count(*), stadium.Name, stadium.Capacity",
            "select count(*), stadium.Stadium_ID",
            "select count(*), stadium.Stadium_ID, stadium.Name",
            "select count(*), stadium.Location, stadium.Capacity",
            "select count(*), stadium.Location",
            "select count(*), stadium.Capacity"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of concerts that have taken place in the stadium with the largest capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "stadium concert",
        "real_label": "stadium concert",
        "topk_preds": [
            "stadium concert",
            "stadium singer concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and count of concerts performed by each singer., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY t1.c1, count(*)",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-GROUP BY (t1.c1)",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GAGGER-GROUP BY",
            "SELECT-FROM-PER-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and count of concerts performed by each singer., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, count(*)",
        "label": "select t1.c1, count(*)",
        "score": true,
        "real_pred": "select singer.Name, count(*)",
        "real_label": "select singer.Name, count(*)",
        "topk_preds": [
            "select singer.Name, count(*)",
            "select singer.Name, count(*), concert.concert_Name",
            "select singer.Name, count(*)",
            "select singer.Name, count(*), singer_in_concert.Singer_ID",
            "select singer.Name, count(*),",
            "select singer.Name, count(concert.concert_Name)",
            "select singer.Name, counts(*)",
            "select singer.Name, count(*), concert.concert_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and count of concerts performed by each singer., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t2 t3",
        "label": "t1 t3",
        "score": false,
        "real_pred": "singer concert singer_in_concert",
        "real_label": "singer singer_in_concert",
        "topk_preds": [
            "singer concert singer_in_concert",
            "singer singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List singers and their concert count for each., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-PER-GROUP BY",
            "SELECT-FROM-FROM-GROUP BY",
            "SELECT-FROM-GIGROUP BY",
            "SELECT-FROM-GIG-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List singers and their concert count for each., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, count(*)",
        "label": "select t1.c1, count(*)",
        "score": true,
        "real_pred": "select singer.Name, count(*)",
        "real_label": "select singer.Name, count(*)",
        "topk_preds": [
            "select singer.Name, count(*)",
            "select singer_in_concert.Singer_ID, count(*)",
            "select concert.concert_Name, count(*)",
            "select singer.Singer_ID, count(*)",
            "select singer.Name, count(*), concert.concert_ID",
            "select singer.Name, count(*), concert.concert_Name",
            "select t4.c1, count(*)",
            "select singer.Name, count(*), concert.Stadium_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List singers and their concert count for each., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t3",
        "label": "t1 t3",
        "score": true,
        "real_pred": "singer singer_in_concert",
        "real_label": "singer singer_in_concert",
        "topk_preds": [
            "singer singer_in_concert",
            "singer concert singer_in_concert",
            "",
            "concert singer_in_concert",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the list of singer names and total concerts for each singer., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY t1.c1, count(*)",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t1.c1, sum(t2.c1)",
            "SELECT-FROM-GROUP BY t1. C1, count(*)",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY (t1.c1) t2.c1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the list of singer names and total concerts for each singer., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, count(*)",
        "label": "select t1.c1, count(*)",
        "score": true,
        "real_pred": "select singer.Name, count(*)",
        "real_label": "select singer.Name, count(*)",
        "topk_preds": [
            "select singer.Name, count(*)",
            "select singer.Name, sum(concert.concert_Name)",
            "select singer.Name, sum(concert.concert_ID)",
            "select singer.Name, count(*), concert.concert_Name",
            "select singer.Name, count(*), concert.concert_ID",
            "select singer.Name, sum(concert.Stadium_ID)",
            "select singer.Name, sum(concert.Theme)",
            "select singer.Name, sum(t2.c8)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the list of singer names and total concerts for each singer., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1 t2 t3",
        "label": "t1 t3",
        "score": false,
        "real_pred": "singer concert singer_in_concert",
        "real_label": "singer singer_in_concert",
        "topk_preds": [
            "singer concert singer_in_concert",
            "singer singer_in_concert",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the youngest, the oldest, and the middle age of a group of French singers?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (GROUP BY-HAVING)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the youngest, the oldest, and the middle age of a group of French singers?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select min(t1.c5), max(t1.c5), min(t1.c5)",
        "label": "select avg(t1.c5), min(t1.c5), max(t1.c5)",
        "score": false,
        "real_pred": "select min(singer.Age), max(singer.Age), min(singer.Age)",
        "real_label": "select avg(singer.Age), min(singer.Age), max(singer.Age)",
        "topk_preds": [
            "select min(singer.Age), max(singer.Age), min(singer.Age)",
            "select singer.Singer_ID, singer.Country, singer.Age",
            "select singer.Singer_ID, singer.Age, singer.Is_male",
            "select singer.Singer_ID, singer.Name, singer.Age",
            "select max(singer.Age), min(singer.Age), singer.Age",
            "select singer.Singer_ID, singer.Age, singer.Is_male",
            "select singer.Singer_ID, singer.Age, singer.Country",
            "select singer.Singer_ID, singer.Song_Name, singer.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the youngest, the oldest, and the middle age of a group of French singers?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average capacity and the largest capacity for all stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average capacity and the largest capacity for all stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select avg(t0.c3), max(t0.c3)",
        "label": "select avg(t0.c3), max(t0.c3)",
        "score": true,
        "real_pred": "select avg(stadium.Capacity), max(stadium.Capacity)",
        "real_label": "select avg(stadium.Capacity), max(stadium.Capacity)",
        "topk_preds": [
            "select avg(stadium.Capacity), max(stadium.Capacity)",
            "select avg(stadium.Average), max(stadium.Capacity)",
            "select stadium.Average, stadium.Capacity",
            "select stadium.Average, stadium.Highest",
            "select avg(stadium.Average), stadium.Highest",
            "select avg(stadium.Capacity), stadium.Highest",
            "select avg(stadium.Average), stadium.Capacity",
            "select avg(stadium.Capacity), max(stadium.Highest)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average capacity and the largest capacity for all stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average capacity and the largest capacity for all the stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average capacity and the largest capacity for all the stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select avg(t0.c3), max(t0.c3)",
        "label": "select avg(t0.c3), max(t0.c3)",
        "score": true,
        "real_pred": "select avg(stadium.Capacity), max(stadium.Capacity)",
        "real_label": "select avg(stadium.Capacity), max(stadium.Capacity)",
        "topk_preds": [
            "select avg(stadium.Capacity), max(stadium.Capacity)",
            "select avg(stadium.Average), max(stadium.Capacity)",
            "select stadium.Average, stadium.Highest",
            "select stadium.Average, stadium.Capacity",
            "select avg(stadium.Capacity), stadium.Highest",
            "select avg(stadium.Average), stadium.Highest",
            "select avg(stadium.Average), stadium.Capacity",
            "select avg(stadium.Capacity), max(stadium.Highest)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average capacity and the largest capacity for all the stadiums?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the locations and names of stations with capacity of 5000 to 10,000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the locations and names of stations with capacity of 5000 to 10,000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select stadium.Location, stadium.Name",
        "real_label": "select stadium.Location, stadium.Name",
        "topk_preds": [
            "select stadium.Location, stadium.Name",
            "select stadium.Location., stadium.Name",
            "select t0.c 1, stadium.Name",
            "select stadium.Location, stadium.Name",
            "select stadium.Location, stadium.Name,",
            "select stadium.Stadium_ID, stadium.Name",
            "select t0-c1, t0-c2",
            "select stadium.Name, stadium.Location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the locations and names of stations with capacity of 5000 to 10,000., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the locations and names of all stations in range from 5000-10,000 capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE (GROUP BY-HAVING)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the locations and names of all stations in range from 5000-10,000 capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select stadium.Location, stadium.Name",
        "real_label": "select stadium.Location, stadium.Name",
        "topk_preds": [
            "select stadium.Location, stadium.Name",
            "select stadium.Location., stadium.Name",
            "select stadium.Location, stadium.Name",
            "select t0.c 1, stadium.Name",
            "select stadium.Stadium_ID, stadium.Name",
            "select stadium.Location, stadium.Name,",
            "select stadium.Name, stadium.Location",
            "select t0-c1, t0-c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the locations and names of all stations in range from 5000-10,000 capacity., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the id and weight of every pet that has more than 1 year of age?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the id and weight of every pet that has more than 1 year of age?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c0, t2.c3",
        "label": "select t2.c0, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetID, Pets.weight",
        "real_label": "select Pets.PetID, Pets.weight",
        "topk_preds": [
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, Pets.weight.",
            "select Pets.PetID, Pets.weight)",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID, Pets.weight,",
            "select Pets.PetID, Pets.pet_age",
            "select Pets.PetID, Pets.weight3",
            "select Pets.PetID, Pets.PetID3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the id and weight of every pet that has more than 1 year of age?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the id and weight of all pets that are more than 1 year old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the id and weight of all pets that are more than 1 year old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c0, t2.c3",
        "label": "select t2.c0, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetID, Pets.weight",
        "real_label": "select Pets.PetID, Pets.weight",
        "topk_preds": [
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, Pets.weight.",
            "select Pets.PetID, Pets.weight)",
            "select Pets.PetID, Pets.weight,",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID, Pets.pet_age",
            "select Pets.PetID, Pets.weight3",
            "select Pets.PetID, Pets.PetID3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the id and weight of all pets that are more than 1 year old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many pets weigh more than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many pets weigh more than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*), Pets.PetType",
            "select count(*), Pets.weight",
            "select count(*), http://Pets.PetID",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many pets weigh more than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the number of pet animals above 10 pounds., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WITH-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the number of pet animals above 10 pounds., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*) denoted by Pets.PetID",
            "select count(*), Pets.PetID",
            "select count(*) dependant on Pets.PetID",
            "select count(*), Pets.weight",
            "select count(*), Pets.pet_age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the number of pet animals above 10 pounds., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many pets are larger than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many pets are larger than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*), Pets.pet_age",
            "select count(*), Pets.PetType",
            "select count(*), Pets.weight",
            "select count(*), t2.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many pets are larger than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many pets have a weight larger than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-CUMULAT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many pets have a weight larger than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*),",
            "select count(*), http://Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*), Pets.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many pets have a weight larger than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the first name and gender of all students who have two or more pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the first name and gender of all students who have two or more pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select Student.Fname, Student.Sex",
        "real_label": "select Student.Fname, Student.Sex",
        "topk_preds": [
            "select Student.Fname, Student.Sex",
            "select Student.StuID, Student.Fname, Student.Sex",
            "select distinct Student.Fname, Student.Sex",
            "select Student.LName, Student.Sex",
            "select Student.Sex, Student.Fname",
            "select Student.Fname, Student.Age, Student.Sex",
            "select Student.Fname.c2, Student.Sex",
            "select Student.Fname), Student.Sex"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the first name and gender of all students who have two or more pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "Student Student Has_Pet",
            "",
            "Student Pets",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name and gender of every student who has two or more pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name and gender of every student who has two or more pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select Student.Fname, Student.Sex",
        "real_label": "select Student.Fname, Student.Sex",
        "topk_preds": [
            "select Student.Fname, Student.Sex",
            "select Student.LName, Student.Fname, Student.Sex",
            "select Student.Fname, Student.Age, Student.Sex",
            "select Student.StuID, Student.Fname, Student.Sex",
            "select Student.Sex, Student.Fname",
            "select Student.Fname.c2, Student.Sex",
            "select Student.Fname, Student.Sex, Student.StuID",
            "select distinct Student.Fname, Student.Sex"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name and gender of every student who has two or more pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "Student Student Has_Pet",
            "",
            "Student Pets",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first name and gender of students who have at least two pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTANT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first name and gender of students who have at least two pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select Student.Fname, Student.Sex",
        "real_label": "select Student.Fname, Student.Sex",
        "topk_preds": [
            "select Student.Fname, Student.Sex",
            "select Student.StuID, Student.Fname, Student.Sex",
            "select distinct Student.Fname, Student.Sex",
            "select Student.LName, Student.Sex",
            "select Student.Sex, Student.Fname",
            "select Student.Fname, Student.Age, Student.Sex",
            "select Student.Fname.c2, Student.Sex",
            "select Student.Fname, Student.Sex, min(t1.c3)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first name and gender of students who have at least two pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "Student Student Has_Pet",
            "",
            "",
            "Student Pets",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first name and gender of students that own two or more pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTANT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first name and gender of students that own two or more pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select Student.Fname, Student.Sex",
        "real_label": "select Student.Fname, Student.Sex",
        "topk_preds": [
            "select Student.Fname, Student.Sex",
            "select Student.StuID, Student.Fname, Student.Sex",
            "select Student.LName, Student.Sex",
            "select Student.Sex, Student.Fname",
            "select Student.Fname, Student.Age, Student.Sex",
            "select Student.Fname.c2, Student.Sex",
            "select distinct Student.Fname, Student.Sex",
            "select Student.Fname, Student.Sex, Student.StuID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first name and gender of students that own two or more pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "Student Pets",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the first name and gender of students who own at least two pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSIST-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTANT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the first name and gender of students who own at least two pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select Student.Fname, Student.Sex",
        "real_label": "select Student.Fname, Student.Sex",
        "topk_preds": [
            "select Student.Fname, Student.Sex",
            "select Student.StuID, Student.Fname, Student.Sex",
            "select distinct Student.Fname, Student.Sex",
            "select Student.LName, Student.Sex",
            "select Student.Sex, Student.Fname",
            "select Student.Fname.c2, Student.Sex",
            "select Student.Fname, Student.Age, Student.Sex",
            "select Student.Fname), Student.Sex"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the first name and gender of students who own at least two pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            "Student Pets",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of pets owned by students who are aged greater than 20., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE NUM(*)",
            "SELECT-FROM students-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of pets owned by students who are aged greater than 20., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.StuID, Student.Age",
            "select count(distinct Has_Pet.PetID)",
            "select count(*), Student.LName, Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of pets owned by students who are aged greater than 20., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the number of pets owned by students who are at least 21 years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM students who are at least 21 years old",
            "SELECT-FROM students who are at least 21",
            "SELECT-FROM-WHERE-NUM(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the number of pets owned by students who are at least 21 years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(distinct Has_Pet.PetID)",
            "select count(*), Student.LName",
            "select count(*), Student.StuID, Student.Age",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.Fname, Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the number of pets owned by students who are at least 21 years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of pets owned by students aged over 20 years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-COUNT(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of pets owned by students aged over 20 years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.StuID, Student.Age",
            "select count(distinct Has_Pet.PetID)",
            "select count(*), Student.Fname, Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of pets owned by students aged over 20 years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the total count of pets owned by older-than-20 students., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the total count of pets owned by older-than-20 students., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.StuID, Student.Age",
            "select count(*), Student.LName, Pets.pet_age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the total count of pets owned by older-than-20 students., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the total number of pets owned by students who are at least 21 years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE -GROUP BY",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the total number of pets owned by students who are at least 21 years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName",
            "select count(*), Student.StuID, Student.Age",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.Fname, Student.Age",
            "select count(*), Student.LName, Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the total number of pets owned by students who are at least 21 years old., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the total count of pets for each student who has pet and student id., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY TI1.c0 et count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the total count of pets for each student who has pet and student id., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*), t1.c0",
        "label": "select count(*), t0.c0",
        "score": false,
        "real_pred": "select count(*), Has_Pet.StuID",
        "real_label": "select count(*), Student.StuID",
        "topk_preds": [
            "select count(*), Has_Pet.StuID",
            "select Has_Pet.StuID, count(*)",
            "select sum(Has_Pet.PetID), Has_Pet.StuID",
            "select counts(*), Has_Pet.StuID",
            "select count(Has_Pet.PetID), Has_Pet.StuID",
            "select add count(*), Has_Pet.StuID",
            "select sum(t1.c2), Has_Pet.StuID",
            "select sum(Pets.weight), Has_Pet.StuID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the total count of pets for each student who has pet and student id., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Has_Pet",
            "Has_Pet Pets",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest weight for each type of pet? Find the weight and pet type., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY max(t2.c3), SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY max(t2.c3), SELECT-FROM-GROUP BY max(t2.c1)",
            "SELECT-FROM-GROUP BY Max(t2.c3), SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY maximum(t2.c3), SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY max(t2.c3), SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY max(t2.c3), SELECT-FROM-GROUP BY max(t2.c3)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest weight for each type of pet? Find the weight and pet type., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select max(t2.c3), t2.c1",
        "label": "select max(t2.c3), t2.c1",
        "score": true,
        "real_pred": "select max(Pets.weight), Pets.PetType",
        "real_label": "select max(Pets.weight), Pets.PetType",
        "topk_preds": [
            "select max(Pets.weight), Pets.PetType",
            "select Pets.weight, Pets.PetType",
            "select max(Pets.weight), max(Pets.PetType), Pets.PetType",
            "select maximum(Pets.weight), Pets.PetType",
            "select min(Pets.weight), Pets.PetType",
            "select max(Pets.weight), max(Pets.PetType),",
            "select max(t2.c), Pets.PetType",
            "select max(Pets.weight), Pets.PetType, min(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest weight for each type of pet? Find the weight and pet type., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest weight and the type for each pet type?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY max(t2.c3), SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY maximum(t2.c3), SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY largest(t2.c3), SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY maximum(t2.c3), SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY max(t2.c3), SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest weight and the type for each pet type?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select max(t2.c3), t2.c1",
        "label": "select max(t2.c3), t2.c1",
        "score": true,
        "real_pred": "select max(Pets.weight), Pets.PetType",
        "real_label": "select max(Pets.weight), Pets.PetType",
        "topk_preds": [
            "select max(Pets.weight), Pets.PetType",
            "select max(Pets.weight), Pets.PetType, min(Pets.weight)",
            "select min(Pets.weight), Pets.PetType",
            "select max(Pets.weight), Pets.PetType, Pets.pet_age",
            "select Pets.weight, Pets.PetType, max(Pets.weight)",
            "select max(Pets.weight), Pets.PetType, max(Pets.weight)",
            "select Pets.weight, Pets.PetType",
            "select max(Pets.weight), Pets.PetType, Pets.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest weight and the type for each pet type?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the heaviest weight for each type of pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY TI2.c1, max(t2.c3)",
            "SELECT-FROM-GROUP BY, max(t2.c3)",
            "SELECT-FROM-GROUP BY TI2.C1, max(t2.c3)",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM -GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the heaviest weight for each type of pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c1, max(t2.c3)",
        "label": "select max(t2.c3), t2.c1",
        "score": false,
        "real_pred": "select Pets.PetType, max(Pets.weight)",
        "real_label": "select max(Pets.weight), Pets.PetType",
        "topk_preds": [
            "select Pets.PetType, max(Pets.weight)",
            "select Pets.PetType, min(Pets.weight)",
            "select Pets.PetType.c1, max(Pets.weight)",
            "select max(Pets.weight), Pets.PetType",
            "select Pets.PetType, max(Pets.weight), Pets.weight",
            "select Pets.PetType, max(Pets.weight)",
            "select Pets.PetType, Max(Pets.weight)",
            "select pettype, max(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the heaviest weight for each type of pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids and weights of all pets whose age is greater than 1?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids and weights of all pets whose age is greater than 1?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c0, t2.c3",
        "label": "select t2.c0, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetID, Pets.weight",
        "real_label": "select Pets.PetID, Pets.weight",
        "topk_preds": [
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, Pets.weight.",
            "select Pets.PetID, Pets.weight)",
            "select Pets.PetID, Pets.weight,",
            "select Pets.PetID, Pets.pet_age",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID, Pets.PetID3",
            "select Pets.PetID, Pets.weight3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids and weights of all pets whose age is greater than 1?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the id and weight of all pets whose age is greater than 1?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the id and weight of all pets whose age is greater than 1?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c0, t2.c3",
        "label": "select t2.c0, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetID, Pets.weight",
        "real_label": "select Pets.PetID, Pets.weight",
        "topk_preds": [
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, Pets.weight.",
            "select Pets.PetID, Pets.weight)",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID, Pets.weight,",
            "select Pets.PetID, Pets.pet_age",
            "select Pets.PetID, Pets.weight3",
            "select Pets.PetID, Pets.PetID3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the id and weight of all pets whose age is greater than 1?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the id and weight of all pets whose age is greater than or equal to 2?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the id and weight of all pets whose age is greater than or equal to 2?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c0, t2.c3",
        "label": "select t2.c0, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetID, Pets.weight",
        "real_label": "select Pets.PetID, Pets.weight",
        "topk_preds": [
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, Pets.weight.",
            "select Pets.PetID, Pets.weight)",
            "select Pets.PetID, Pets.weight,",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID, Pets.pet_age",
            "select Pets.PetID, Pets.weight3",
            "select Pets.PetID, Pets.PetID3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the id and weight of all pets whose age is greater than or equal to 2?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the id and weight of all pets that have an age greater than one., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the id and weight of all pets that have an age greater than one., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c0, t2.c3",
        "label": "select t2.c0, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetID, Pets.weight",
        "real_label": "select Pets.PetID, Pets.weight",
        "topk_preds": [
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, Pets.weight.",
            "select Pets.PetID, Pets.weight)",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID, Pets.weight,",
            "select Pets.PetID, Pets.pet_age",
            "select Pets.PetID-, Pets.weight",
            "select Pets.PetID, Pets.weight3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the id and weight of all pets that have an age greater than one., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the id and weight of all pets, the age of which is greater than 1., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the id and weight of all pets, the age of which is greater than 1., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c0, t2.c3",
        "label": "select t2.c0, t2.c3",
        "score": true,
        "real_pred": "select Pets.PetID, Pets.weight",
        "real_label": "select Pets.PetID, Pets.weight",
        "topk_preds": [
            "select Pets.PetID, Pets.weight",
            "select Pets.PetID, Pets.weight.",
            "select Pets.PetID, Pets.weight)",
            "select Pets.PetID, Pets.weight,",
            "select Pets.PetID, Pets.pet_age",
            "select Pets.PetType, Pets.weight",
            "select Pets.PetID-, Pets.weight",
            "select Pets.PetID, Pets.weight3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the id and weight of all pets, the age of which is greater than 1., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of pets whose weight is larger than 10., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE NUM(*)",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of pets whose weight is larger than 10., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*), database: Pets.PetID",
            "select count(*), Pets.weight",
            "select count(*), http://Pets.PetID",
            "select count(*) the Pets.PetID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of pets whose weight is larger than 10., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many pets have a weight greater than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many pets have a weight greater than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*),",
            "select count(*), http://Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*), Pets.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many pets have a weight greater than 10?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of pets whose weight is more than ten?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of pets whose weight is more than ten?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*),",
            "select count(*), Pets.weight",
            "select count(*), Pets.PetType",
            "select count(*), http://Pets.PetID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of pets whose weight is more than ten?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            "Has_Pet Pets"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the mean age of students without pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (Avg(t0.c3)",
            "SELECT-FROM-WHERE (avg(t0.c3)",
            "SELECT-FROM-WHERE (AVERAGE(t0.c3)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the mean age of students without pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select avg(t0.c3)",
        "label": "select avg(t0.c3)",
        "score": true,
        "real_pred": "select avg(Student.Age)",
        "real_label": "select avg(Student.Age)",
        "topk_preds": [
            "select avg(Student.Age)",
            "select avg(Student.Age), Student.StuID",
            "select avg(Student.Age), Has_Pet.StuID",
            "select an avg(Student.Age)",
            "select avg(Student.Age), Student.Sex",
            "select avg(Student.Age), Student.Fname",
            "select avg(t0-Student.Age)",
            "select avg(Student.Age), Student.LName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the mean age of students without pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0",
        "score": false,
        "real_pred": "Student Has_Pet",
        "real_label": "Student",
        "topk_preds": [
            "Student Has_Pet",
            "Student",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the mean age of students without pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (Avg(t0.c3)",
            "SELECT-FROM-WHERE (avg(t0.c3)",
            "SELECT-FROM-WHERE (AVERAGE(t0.c3)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the mean age of students without pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select avg(t0.c3)",
        "label": "select avg(t0.c3)",
        "score": true,
        "real_pred": "select avg(Student.Age)",
        "real_label": "select avg(Student.Age)",
        "topk_preds": [
            "select avg(Student.Age)",
            "select avg(Student.Age), Student.StuID",
            "select an avg(Student.Age)",
            "select avg(Student.Age), Has_Pet.StuID",
            "select avg(Student.Age), Student.Sex",
            "select avg(Student.Age), Student.Fname",
            "select avg(t0-Student.Age)",
            "select avg(Student.Age), Student.LName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the mean age of students without pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Student",
        "real_label": "Student",
        "topk_preds": [
            "Student",
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the mean age of students who have no pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t0.c3)",
            "SELECT-FROM-WHERE (avg(t0.c3)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the mean age of students who have no pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select avg(t0.c3)",
        "label": "select avg(t0.c3)",
        "score": true,
        "real_pred": "select avg(Student.Age)",
        "real_label": "select avg(Student.Age)",
        "topk_preds": [
            "select avg(Student.Age)",
            "select an avg(Student.Age)",
            "select avg(Student.Age), Student.StuID",
            "select avg(Student.Age), Has_Pet.StuID",
            "select avg(Student.Age), Student.Sex",
            "select avg(Student.Age), Student.Fname",
            "select avg(t0-Student.Age)",
            "select avg(Student.Age), Student.Advisor"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the mean age of students who have no pets., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Student",
        "real_label": "Student",
        "topk_preds": [
            "Student",
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of pets owned by students that are older than 20., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE NUM(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of pets owned by students that are older than 20., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.StuID, Student.Age",
            "select count(*), Student.LName",
            "select count(distinct Has_Pet.PetID)",
            "select count(*), Student.StuID, Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of pets owned by students that are older than 20., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total number of pets owned by students who are over 20 years old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE GROSS(t1.c1)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE -GROUP BY",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total number of pets owned by students who are over 20 years old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.LName",
            "select count(*), Student.StuID, Student.Age",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.StuID, Student.Fname"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total number of pets owned by students who are over 20 years old?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many pets do students who are over the age of 20 own?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many pets do students who are over the age of 20 own?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(*), Student.LName, Student.Age",
            "select count(distinct Has_Pet.PetID)",
            "select count(*), Student.LName",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.StuID, Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many pets do students who are over the age of 20 own?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of students with pets that have an age of 21 or greater?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE ACT-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE ACT-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of students with pets that have an age of 21 or greater?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.LName, Student.Age",
            "select count(*), Student.StuID",
            "select count(distinct Has_Pet.StuID)",
            "select count(*), Student.LName",
            "select count(*), Student.LName, Student.Fname",
            "select count(*), Student.LName, Pets.pet_age",
            "select count(*), Student.Fname, Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of students with pets that have an age of 21 or greater?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many pets are owned by students that have at least 21 years?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many pets are owned by students that have at least 21 years?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.StuID",
            "select count(distinct Has_Pet.PetID)",
            "select count(*), Student.LName",
            "select count(*), Student.StuID",
            "select count(*), Student.Fname",
            "select count(distinct Has_Pet.StuID)",
            "select count(*), Student.LName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many pets are owned by students that have at least 21 years?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet Pets",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are all students on average who do not own any pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AVERAGE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are all students on average who do not own any pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select avg(t0.c3)",
        "label": "select avg(t0.c3)",
        "score": true,
        "real_pred": "select avg(Student.Age)",
        "real_label": "select avg(Student.Age)",
        "topk_preds": [
            "select avg(Student.Age)",
            "select an avg(Student.Age)",
            "select avg(Student.Age), Student.StuID",
            "select  avg(Student.Age)",
            "select avg(t0-Student.Age)",
            "select Avg(Student.Age)",
            "select avg(Student.Age), Student.Fname",
            "select avg(Student.Age), Student.Sex"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are all students on average who do not own any pets?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Student",
        "real_label": "Student",
        "topk_preds": [
            "Student",
            "Student Has_Pet",
            "",
            "Student Has_Pet Pets",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model of the car with the lowest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model of the car with the lowest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.Make",
            "select car_names.Model (car_names.Make)",
            "select model_list.Model, car_names.Model",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model of the car with the lowest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model of the car that has the least amount of horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model of the car that has the least amount of horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, t4.c3",
            "select model_list.Model, car_names.Model",
            "select car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model of the car that has the least amount of horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data",
            "continents model_list car_names cars_data",
            "continents car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the model of the car with the least amount of horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the model of the car with the least amount of horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select car_names.Make",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the model of the car with the least amount of horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_names cars_data",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "continents model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which model in the car category has the least horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which model in the car category has the least horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Model, model_list.Model",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, car_names.MakeId",
            "select car_names.Model, cars_data.Id",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which model in the car category has the least horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model of the car with the least horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-OREGON-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model of the car with the least horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.Make",
            "select car_names.Model (car_names.Make)",
            "select model_list.Model, car_names.Model",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model of the car with the least horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the model of the car with the lowest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-OREGON-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the model of the car with the lowest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Make",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model (model_list.Model)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the model of the car with the lowest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_names cars_data",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "continents model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers model_list cars_data",
            "continents car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the average horsepower in all cars manufactured prior to 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-AGGREG(t5.c4)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the average horsepower in all cars manufactured prior to 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c4)",
        "label": "select avg(t5.c4)",
        "score": true,
        "real_pred": "select avg(cars_data.Horsepower)",
        "real_label": "select avg(cars_data.Horsepower)",
        "topk_preds": [
            "select avg(cars_data.Horsepower)",
            "select an avg(cars_data.Horsepower)",
            "select avg(avg(cars_data.Horsepower)",
            "select  avg(cars_data.Horsepower)",
            "select Avg(cars_data.Horsepower)",
            "select avg(cars_data.Horsepower)",
            "select avg(cars_data.Accelerate)",
            "select the avg(cars_data.Horsepower)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the average horsepower in all cars manufactured prior to 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the smallest weight of the car produced in 1974 with eight cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-MIN(t5.c5)",
            "SELECT-FROM-WHERE (MIN(t5.c5)",
            "SELECT-FROM-WHERE, min(t5.c5)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the smallest weight of the car produced in 1974 with eight cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select min(t5.c5)",
        "label": "select min(t5.c5)",
        "score": true,
        "real_pred": "select min(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select min(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Cylinders",
            "select min(cars_data.Weight), cars_data.Year",
            "select min(cars_data.Weight), cars_data.Accelerate",
            "select min(cars_data.Weight), t5.c8",
            "select cars_data.Weight",
            "select max(cars_data.Weight)",
            "select minimum(cars_data.Weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the smallest weight of the car produced in 1974 with eight cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the minimum weight of the car produced in 1974 with eight cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (MIN(t5.c5)",
            "SELECT-FROM-WHERE-MIN(t5.c5)",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the minimum weight of the car produced in 1974 with eight cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select min(t5.c5)",
        "label": "select min(t5.c5)",
        "score": true,
        "real_pred": "select min(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select min(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Cylinders",
            "select min(cars_data.Weight), cars_data.Accelerate",
            "select min(cars_data.Weight), cars_data.Year",
            "select min(cars_data.Weight), t5.c8",
            "select min(cars_data.Weight), cars_data.Id",
            "select min(cars_data.Weight), cars_data.MPG",
            "select min(cars_data.Weight), t5.c9"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the minimum weight of the car produced in 1974 with eight cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the minimum weight of the car with 8 cylinders made in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (MIN(t5.c5)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the minimum weight of the car with 8 cylinders made in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select min(t5.c5)",
        "label": "select min(t5.c5)",
        "score": true,
        "real_pred": "select min(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select min(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Year",
            "select min(cars_data.Weight), cars_data.Accelerate",
            "select min(cars_data.Weight), cars_data.Cylinders",
            "select min(cars_data.Weight), t5.dcars_data.Accelerate",
            "select min(cars_data.Weight), t5.dcars_data.Year",
            "select min(cars_data.Weight), t5.c8",
            "select min(cars_data.Weight), t5.dcars_data.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the minimum weight of the car with 8 cylinders made in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "",
            "countries cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the minimum weight of cars made with 8 cylinders in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-MIN(t5.c5)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the minimum weight of cars made with 8 cylinders in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select min(t5.c5)",
        "label": "select min(t5.c5)",
        "score": true,
        "real_pred": "select min(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select min(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Year",
            "select min(cars_data.Weight), cars_data.Accelerate",
            "select min(cars_data.Weight), cars_data.Cylinders",
            "select min(cars_data.Weight), t5.dcars_data.Year",
            "select min(cars_data.Weight), t5.dcars_data.Accelerate",
            "select min(cars_data.Weight), t5.c8",
            "select min(cars_data.Weight), t5.dcars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the minimum weight of cars made with 8 cylinders in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the lowest weight of a car made with eight cylinders in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-MIN(t5.c5)",
            "SELECT-FROM-WHERE, min(t5.c5)",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-1974"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the lowest weight of a car made with eight cylinders in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select min(t5.c5)",
        "label": "select min(t5.c5)",
        "score": true,
        "real_pred": "select min(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select min(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Year",
            "select min(cars_data.Weight), cars_data.Accelerate",
            "select min(cars_data.Weight), cars_data.Cylinders",
            "select max(cars_data.Weight)",
            "select min(cars_data.Weight), t5.c8",
            "select min(cars_data.Weight), cars_data.Id",
            "select min(cars_data.Weight), cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the lowest weight of a car made with eight cylinders in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_makers cars_data",
            "countries cars_data",
            "",
            "cars_data car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the horsepower of the car which accelerates the quickest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the horsepower of the car which accelerates the quickest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c4",
        "label": "select t5.c4",
        "score": true,
        "real_pred": "select cars_data.Horsepower",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate",
            "select cars_data.Id, cars_data.Horsepower",
            "select cars_data.Horsepower, t5.diff(cars_data.Accelerate)",
            "select cars_data.Id, cars_data.Cylinders",
            "select cars_data.Horsepower, cars_data.Accelerate, cars_data.Year",
            "select cars_data.Id, cars_data.Cylinders, cars_data.Horsepower",
            "select cars_data.Horsepower, t5.diff, cars_data.Accelerate"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the horsepower of the car which accelerates the quickest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the horsepower of the car with the best acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ALERT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the horsepower of the car with the best acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c4",
        "label": "select t5.c4",
        "score": true,
        "real_pred": "select cars_data.Horsepower",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate",
            "select cars_data.Horsepower, t5.diff(cars_data.Accelerate)",
            "select cars_data.Horsepower, cars_data.Accelerate, cars_data.Year",
            "select cars_data.Horsepower, t5.diff, cars_data.Accelerate",
            "select cars_data.Horsepower (cars_data.Accelerate)",
            "select cars_data.Horsepower (cars_data.Horsepower)",
            "select cars_data.Horsepower, t5.diff (cars_data.Accelerate)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the horsepower of the car with the best acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the horsepower of the car that can accelerate the fastest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the horsepower of the car that can accelerate the fastest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c4",
        "label": "select t5.c4",
        "score": true,
        "real_pred": "select cars_data.Horsepower",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate",
            "select cars_data.Horsepower, t5.diff(cars_data.Accelerate)",
            "select cars_data.Horsepower, cars_data.Accelerate, cars_data.Year",
            "select cars_data.Horsepower (cars_data.Accelerate)",
            "select cars_data.Horsepower, t5.diff, cars_data.Accelerate",
            "select max(cars_data.Horsepower)",
            "select cars_data.Horsepower, cars_data.Accelerate, t5.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the horsepower of the car that can accelerate the fastest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the horsepower of the car that has the most acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the horsepower of the car that has the most acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c4",
        "label": "select t5.c4",
        "score": true,
        "real_pred": "select cars_data.Horsepower",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate",
            "select cars_data.Id, cars_data.Horsepower",
            "select cars_data.Horsepower, t5.diff(cars_data.Accelerate)",
            "select cars_data.Id, cars_data.Cylinders",
            "select cars_data.Id, cars_data.Cylinders, cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate, cars_data.Year",
            "select cars_data.Horsepower (cars_data.Accelerate)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the horsepower of the car that has the most acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the horsepower of the car that has the highest acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the horsepower of the car that has the highest acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c4",
        "label": "select t5.c4",
        "score": true,
        "real_pred": "select cars_data.Horsepower",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate",
            "select cars_data.Id, cars_data.Horsepower",
            "select cars_data.Id, cars_data.Cylinders",
            "select cars_data.Horsepower (cars_data.Accelerate)",
            "select cars_data.Horsepower (cars_data.Horsepower)",
            "select cars_data.Horsepower(cars_data.Horsepower)",
            "select cars_data.Horsepower(cars_data.Accelerate)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the horsepower of the car that has the highest acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the year ranges in which there were cars manufactured lighter than 4,000 lbs. and vehicles heavier than 3,000 lbs?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROMWHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERES-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE AND-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the year ranges in which there were cars manufactured lighter than 4,000 lbs. and vehicles heavier than 3,000 lbs?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select cars_data.Year, t5.c8",
            "select cars_data.Year, cars_data.Accelerate",
            "select cars_data.Year-, t5.c8",
            "select cars_data.Year, cars_data.Cylinders",
            "select distinct cars_data.Year",
            "select cars_data.Year-, cars_data.Accelerate",
            "select cars_data.Year-t5.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the year ranges in which there were cars manufactured lighter than 4,000 lbs. and vehicles heavier than 3,000 lbs?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the years in which cars had a weight below 4000 and those above 3000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the years in which cars had a weight below 4000 and those above 3000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select distinct cars_data.Year",
            "select cars_data.Year, t5.c8",
            "select cars_data.Year, cars_data.Accelerate",
            "select cars_data.Year, cars_data.MPG0",
            "select cars_data.Year, cars_data.Cylinders",
            "select cars_data.Year, cars_data.MPG",
            "select cars_data.Year, cars_data.MPG2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the years in which cars had a weight below 4000 and those above 3000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "model_list cars_data",
            "",
            "",
            "car_makers cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the make ids and names of all cars that does not have the minimum horsepower, and show me the ones with fewer than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the make ids and names of all cars that does not have the minimum horsepower, and show me the ones with fewer than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c0, t4.c2",
        "label": "select t4.c0, t4.c2",
        "score": true,
        "real_pred": "select car_names.MakeId, car_names.Make",
        "real_label": "select car_names.MakeId, car_names.Make",
        "topk_preds": [
            "select car_names.MakeId, car_names.Make",
            "select car_names.Make, car_names.MakeId",
            "select car_names.MakeId, car_names.Make, t4.c3",
            "select car_names.MakeId, car_names.Model",
            "select car_names.MakeId, car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Make, car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Make,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the make ids and names of all cars that does not have the minimum horsepower, and show me the ones with fewer than four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Among the cars that do not have the minimum horsepower, show me the maker IDs and car names with fewer than 4 cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Among the cars that do not have the minimum horsepower, show me the maker IDs and car names with fewer than 4 cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c0, t4.c1",
        "label": "select t4.c0, t4.c2",
        "score": false,
        "real_pred": "select car_names.MakeId, car_names.Model",
        "real_label": "select car_names.MakeId, car_names.Make",
        "topk_preds": [
            "select car_names.MakeId, car_names.Model",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model, car_names.Make",
            "select car_names.Make, car_names.Model",
            "select car_makers.Maker, car_names.Make",
            "select car_names.MakeId, t4.c4",
            "select car_makers.Maker, car_names.Model",
            "select car_names.Model, t4.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Among the cars that do not have the minimum horsepower, show me the maker IDs and car names with fewer than 4 cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of cars with a larger acceleration than the one with the most horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE -GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY -LIMIT",
            "SELECT-FROM-WHERE-GROUP BYORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of cars with a larger acceleration than the one with the most horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Horsepower",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Accelerate",
            "select count(*), cars_data.MPG",
            "select count(*) dependant on cars_data.Accelerate",
            "select count(*), cars_data.Cylinders",
            "select count(*), t5.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of cars with a larger acceleration than the one with the most horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of cars that has a larger acceleration than the one with the most horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE -GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE CIRCUMSCRIPT-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE CIRCUMSCRIPT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY -LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of cars that has a larger acceleration than the one with the most horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Horsepower",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*), cars_data.Accelerate",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of cars that has a larger acceleration than the one with the most horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest accelerating power for different number of cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest accelerating power for different number of cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c6), t5.c2",
        "label": "select max(t5.c6), t5.c2",
        "score": true,
        "real_pred": "select max(cars_data.Accelerate), cars_data.Cylinders",
        "real_label": "select max(cars_data.Accelerate), cars_data.Cylinders",
        "topk_preds": [
            "select max(cars_data.Accelerate), cars_data.Cylinders",
            "select cars_data.Cylinders, max(cars_data.Accelerate)",
            "select min(cars_data.Accelerate), cars_data.Cylinders",
            "select maxima cars_data.Cylinders, max(cars_data.Accelerate)",
            "select maxima cars_data.Cylinders, cars_data.Accelerate",
            "select maxima(cars_data.Accelerate), cars_data.Cylinders",
            "select maximum(cars_data.Accelerate), cars_data.Cylinders",
            "select maximum cars_data.Accelerate, cars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest accelerating power for different number of cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model for cars with less than the average weight?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model for cars with less than the average weight?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select model_list.ModelId, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select model_list.Model (refers to car_names.Model)",
            "select car_names.Model",
            "select model_list.Model (ref. car_names.Model)",
            "select model_list.ModelId, model_list.Maker",
            "select model_list.Model (or car_names.Model)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model for cars with less than the average weight?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_makers model_list cars_data",
            "car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data",
            "countries cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model for the car that has a weight less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model for the car that has a weight less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select model_list.ModelId, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select model_list.Model (refers to car_names.Model)",
            "select car_names.Model, model_list.Model",
            "select model_list.Model (or car_names.Model)",
            "select model_list.Model (refers to model_list.Model)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model for the car that has a weight less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents model_list car_names cars_data",
            "countries car_names cars_data",
            "model_list cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model for the car whose weight is less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model for the car whose weight is less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select model_list.ModelId, model_list.Model",
            "select car_names.Model",
            "select model_list.Model, car_names.Model",
            "select model_list.Model (refers to car_names.Model)",
            "select model_list.ModelId, model_list.Maker",
            "select model_list.Model (refers to model_list.Model)",
            "select model_list.Model (or car_names.Model)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model for the car whose weight is less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "model_list cars_data",
            "car_names cars_data",
            "car_makers model_list cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers car_names cars_data",
            "continents car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the car model that weighs less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the car model that weighs less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Model",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.MakeId, model_list.Model",
            "select car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the car model that weighs less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers car_names cars_data",
            "continents car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the car model with a weight less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the car model with a weight less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model, cars_data.Id",
            "select car_names.Model, model_list.Model",
            "select car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the car model with a weight less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_names cars_data",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents model_list car_names cars_data",
            "car_makers model_list cars_data",
            "continents car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total number of cars with more than 6 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total number of cars with more than 6 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.MPG",
            "select sum(cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total number of cars with more than 6 cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many vehicles have more than six cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many vehicles have more than six cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.Cylinders",
            "select count(*), t5.dcars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many vehicles have more than six cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the number of cars with 7 or more cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the number of cars with 7 or more cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Id, cars_data.Cylinders",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Cylinders, cars_data.Edispl"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the number of cars with 7 or more cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out how many vehicles have more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-NUM(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out how many vehicles have more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.Id, cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Cylinders, cars_data.Edispl"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out how many vehicles have more than six cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and ids of all countries that either have four or more car makers or produce Fiat model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-4-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and ids of all countries that either have four or more car makers or produce Fiat model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c0, t1.c1",
        "score": false,
        "real_pred": "select countries.CountryName, countries.CountryId",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, model_list.ModelId",
            "select countries.CountryName, car_names.MakeId",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, t1c0",
            "select countries.CountryName., countries.CountryId",
            "select countries.CountryName, t01.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and ids of all countries that either have four or more car makers or produce Fiat model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "countries model_list car_names",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the ids and names of all countries that have four or more carmakers or make fiat models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING or-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the ids and names of all countries that have four or more carmakers or make fiat models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select car_names.Model, countries.CountryId, countries.CountryName",
            "select countries.CountryId, countries.CountryName, car_makers.Country",
            "select t1, car_makers.Id, countries.CountryName",
            "select car_names.Model, countries.CountryId",
            "select countries.CountryName, countries.CountryId",
            "select car_names.MakeId, countries.CountryName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the ids and names of all countries that have four or more carmakers or make fiat models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers car_names",
            "",
            "",
            "countries car_makers model_list",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids and names of all countries that have more than three car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids and names of all countries that have more than three car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select car_names.Model, countries.CountryId, countries.CountryName",
            "select countries.CountryId, countries.CountryName, car_makers.Country",
            "select t1, car_makers.Id, countries.CountryName",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryId, countries.CountryName, countries.Continent",
            "select countries.CountryId, countries.CountryName,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids and names of all countries that have more than three car makers or produce fiat model?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list the ids and names of countries with more than three car makers, or produce a Fiat model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING,-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING or-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list the ids and names of countries with more than three car makers, or produce a Fiat model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select t1, car_makers.Id, countries.CountryName",
            "select countries.CountryId, countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryId, countries.CountryName,",
            "select car_makers.Id, car_makers.Maker",
            "select car_makers.Id, countries.CountryName, car_makers.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list the ids and names of countries with more than three car makers, or produce a Fiat model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "",
            "countries car_makers",
            "countries car_makers car_names",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which of the countries has the largest number of car makers? List the country name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which of the countries has the largest number of car makers? List the country name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName (countries.CountryId)",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName,",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName pour car_makers.Country",
            "select countries.CountryName (countries.Continent)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which of the countries has the largest number of car makers? List the country name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the maker of the earliest made car and what year was it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the maker of the earliest made car and what year was it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1, t5.c7",
        "label": "select t4.c2, t5.c7",
        "score": false,
        "real_pred": "select car_makers.Maker, cars_data.Year",
        "real_label": "select car_names.Make, cars_data.Year",
        "topk_preds": [
            "select car_makers.Maker, cars_data.Year",
            "select car_names.Model, cars_data.Year",
            "select model_list.Maker, cars_data.Year",
            "select car_makers.Maker, t4.c7",
            "select car_names.Make, cars_data.Year",
            "select car_names.Model, t4.c7",
            "select cars_data.MPG, cars_data.Year",
            "select car_makers.Maker, cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the maker of the earliest made car and what year was it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "countries car_makers car_names cars_data",
            "continents car_makers car_names cars_data",
            "model_list car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the maker of the first car ever made and when was it manufactured?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the maker of the first car ever made and when was it manufactured?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1, t4.c7",
        "label": "select t4.c2, t5.c7",
        "score": false,
        "real_pred": "select car_makers.Maker, t4.c7",
        "real_label": "select car_names.Make, cars_data.Year",
        "topk_preds": [
            "select car_makers.Maker, t4.c7",
            "select car_makers.Maker, cars_data.Year",
            "select car_makers.Maker, t2.c7",
            "select car_names.Model, t4.c7",
            "select car_names.Make, t4.c7",
            "select car_makers.Maker, t3.c7",
            "select car_names.Make, cars_data.Year",
            "select car_names.Model, cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the maker of the first car ever made and when was it manufactured?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4",
        "label": "t4 t5",
        "score": false,
        "real_pred": "car_makers car_names",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_makers car_names",
            "countries car_makers car_names",
            "car_makers car_names cars_data",
            "continents car_makers car_names",
            "model_list car_makers car_names",
            "countries car_names",
            "car_names cars_data",
            "model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the countries in Europe with more than 2 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAGMENT-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAUSS-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the countries in Europe with more than 2 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName, countries.CountryId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the countries in Europe with more than 2 car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Are there any European countries that have 3 or more vehicle manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Are there any European countries that have 3 or more vehicle manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, continents.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Are there any European countries that have 3 or more vehicle manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me which of these European countries have three or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAGROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me which of these European countries have three or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, countries.CountryId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me which of these European countries have three or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "",
            "countries car_makers",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the countries in Europe that have three or more car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GAUSS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the countries in Europe that have three or more car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the countries in Europe that have three or more car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "",
            "",
            "countries car_makers",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries in Europe have three or more car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GAGROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUPE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries in Europe have three or more car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, continents.ContId1"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries in Europe have three or more car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "",
            "countries car_makers",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of countries that have 3 or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM \"GROUP BY-HAVING",
            "SELECT-FROM situations-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of countries that have 3 or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryName",
            "select count(distinct car_makers.Country)",
            "select count(1, car_makers.Country)",
            "select count(distinct countries.CountryName)",
            "select count(*), countries.CountryId",
            "select count(countries.CountryName)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of countries that have 3 or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "car_makers",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many countries have 3 or more car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING",
            "SELECT-FROM QUARTER-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many countries have 3 or more car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct car_makers.Country)",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryName",
            "select count(1, car_makers.Country)",
            "select count(distinct countries.CountryName)",
            "select count(countries.CountryName)",
            "select count(*), countries.CountryId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many countries have 3 or more car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "car_makers",
            "countries car_makers",
            "model_list car_makers",
            "",
            "car_makers model_list",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of countries with three or more car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of countries with three or more car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Country",
            "select count(*), countries.CountryName",
            "select count(distinct car_makers.Country)",
            "select count(*) dependant on car_makers.Country",
            "select count(*), countries.CountryId",
            "select count(*), car_makers.Maker",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of countries with three or more car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "car_makers",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of cars manufactured by American Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (American Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE total(t4.c0)",
            "SELECT-FROM-WHERE total(t2.c0)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of cars manufactured by American Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (American Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Id",
            "select count(*), car_makers.Maker",
            "select count(*), car_makers.FullName",
            "select count(car_names.MakeId)",
            "select count(*), car_makers.Country",
            "select t4.c count(*)",
            "select count(*), t2.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of cars manufactured by American Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent (america)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (American Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers car_names",
            "",
            "",
            "car_makers car_makers car_names",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which car model with four cylinders has the greatest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which car model with four cylinders has the greatest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Model, model_list.Model",
            "select car_names.Model (car_names.Make)",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which car model with four cylinders has the greatest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For cars with 4 cylinders, what model has the greatest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For cars with 4 cylinders, what model has the greatest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Edispl",
            "select car_names.Model, model_list.Model",
            "select car_names.Model, cars_data.Id",
            "select car_names.Model (cars_data.Horsepower)",
            "select car_names.Model, cars_data.Accelerate"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For cars with 4 cylinders, what model has the greatest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "car_makers cars_data",
            "continents car_names cars_data",
            "countries cars_data",
            "model_list cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which car model with 4 cylinders has the most horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which car model with 4 cylinders has the most horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, model_list.Model",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, t4.c3",
            "select car_names.Model, car_names.MakeId",
            "select car_names.Model, cars_data.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which car model with 4 cylinders has the most horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For the four-cylinder cars, which model has the most horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For the four-cylinder cars, which model has the most horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Id",
            "select car_names.Model (cars_data.Cylinders)",
            "select car_names.Model, cars_data.Edispl",
            "select car_names.Model, car_names.MakeId",
            "select car_names.Model, cars_data.Accelerate"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For the four-cylinder cars, which model has the most horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "continents car_names cars_data",
            "countries car_names cars_data",
            "car_makers cars_data",
            "countries cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the numbers of cars with more than 6 cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE_GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the numbers of cars with more than 6 cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.MPG",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the numbers of cars with more than 6 cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: There are different models made by either General Motors or which weighs in excess of 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNSELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: There are different models made by either General Motors or which weighs in excess of 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select distinct model_list.Model, car_makers.Maker",
            "select distinct model_list.Model.c2",
            "select distinct model_list.Model, model_list.Maker",
            "select distinct car_names.Model",
            "select model_list.Model",
            "select distinct model_list.Model denoted by car_makers.Maker",
            "select distinct model_list.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: There are different models made by either General Motors or which weighs in excess of 3500?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list cars_data",
            "car_makers model_list car_names",
            "car_makers model_list car_names cars_data",
            "countries car_makers model_list cars_data",
            "continents car_makers model_list cars_data",
            "continents car_makers model_list car_names",
            "",
            "countries car_makers model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the different models made by General Motors in which there is a weight of greater than 3500 pounds., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the different models made by General Motors in which there is a weight of greater than 3500 pounds., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select model_list.Model",
            "select count(distinct model_list.Model)",
            "select distinct car_names.Model",
            "select distinct model_list.Model, car_makers.Maker",
            "select distinct model_list.Model, car_makers.FullName",
            "select distinct model_list.Maker",
            "select distinct car_names.Model, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the different models made by General Motors in which there is a weight of greater than 3500 pounds., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list cars_data",
            "car_makers model_list car_names",
            "countries car_makers model_list cars_data",
            "continents car_makers model_list cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many vehicles have 5 or more cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many vehicles have 5 or more cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(distinct cars_data.Id)",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*), cars_data.Id, cars_data.Cylinders",
            "select count(*), t5.dcars_data.Id",
            "select count(*) (cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many vehicles have 5 or more cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Identify the distinctive models manufactured by the manufacturer named General Motors or over 3500 pounds., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (distinct t3.c2)",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM cars-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Identify the distinctive models manufactured by the manufacturer named General Motors or over 3500 pounds., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select distinct model_list.Model, model_list.Maker",
            "select distinctive model_list.Model",
            "select distinct model_list.Model, car_makers.Maker",
            "select distinct model_list.Maker",
            "select distinct car_names.Model",
            "select distinct model_list.Maker, model_list.Model",
            "select distinct car_names.Model, model_list.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Identify the distinctive models manufactured by the manufacturer named General Motors or over 3500 pounds., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers model_list cars_data",
            "car_makers model_list car_makers model_list car_names",
            "car_makers model_list car_makers car_names",
            "car_makers model_list car_makers model_list cars_data",
            "countries car_makers model_list car_names",
            "car_makers model_list car_makers cars_data",
            "countries car_makers model_list cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which of these models has the greatest fuel economy? That is to say, has the largest miles per gallon?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which of these models has the greatest fuel economy? That is to say, has the largest miles per gallon?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select model_list.ModelId, model_list.Model",
            "select car_names.Model, model_list.Model",
            "select model_list.Model, cars_data.MPG",
            "select car_names.Model, car_names.Make",
            "select model_list.ModelId, car_names.Make",
            "select car_names.Model (cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which of these models has the greatest fuel economy? That is to say, has the largest miles per gallon?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "model_list cars_data",
            "car_makers model_list cars_data",
            "countries model_list car_names cars_data",
            "countries model_list cars_data",
            "continents model_list cars_data",
            "countries car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which model has the highest MPGe?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which model has the highest MPGe?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.Model (cars_data.MPG)",
            "select model_list.Model, car_names.Model",
            "select car_names.Make",
            "select model_list.Model, model_list.ModelId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which model has the highest MPGe?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_makers model_list cars_data",
            "countries car_names cars_data",
            "car_names cars_data",
            "car_makers car_names cars_data",
            "continents model_list cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which car has the highest fuel economy?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which car has the highest fuel economy?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Model-, car_names.Make",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, car_names.Make",
            "select car_names.Model-car_names.Make",
            "select car_names.Model (cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which car has the highest fuel economy?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which vehicle gets the best gas mileage?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which vehicle gets the best gas mileage?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Model-, car_names.Make",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, car_names.Make",
            "select car_names.Model-car_names.Make",
            "select car_names.MakeId, car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which vehicle gets the best gas mileage?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of cars with horsepower greater than 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of cars with horsepower greater than 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*) dependant on cars_data.Id",
            "select count(*) descripted in cars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*) dependant on cars_data.Horsepower",
            "select count(*), cars_data.MPG",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of cars with horsepower greater than 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the total number of cars with horsepower over 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE -GROUP BY",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the total number of cars with horsepower over 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select cars_data.Id, count(*)",
            "select t5.c count(*)",
            "select count(*), cars_data.MPG",
            "select count(*) (cars_data.Id)",
            "select count(*),",
            "select sum(cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the total number of cars with horsepower over 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of vehicles with horsepower over 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of vehicles with horsepower over 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*) dependant on cars_data.Id",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.Id, cars_data.MPG",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Id, cars_data.Horsepower"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of vehicles with horsepower over 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model with the largest number of different versions?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-VARIATION-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model with the largest number of different versions?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select model_list.Model, model_list.ModelId",
            "select model_list.Model, count(distinct model_list.ModelId)",
            "select model_list.Model (distinct model_list.ModelId)",
            "select model_list.ModelId, model_list.Model",
            "select model_list.Model, count(distinct model_list.Model)",
            "select model_list.Model(distinct model_list.ModelId)",
            "select model_list.Model, count(distinct model_list.Maker)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model with the largest number of different versions?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3",
        "label": "t4",
        "score": false,
        "real_pred": "model_list",
        "real_label": "car_names",
        "topk_preds": [
            "model_list",
            "car_makers model_list",
            "model_list car_names",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the model names with the most versions., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the model names with the most versions., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select model_list.Model, model_list.ModelId",
            "select model_list.Model (model_list.ModelId)",
            "select model_list.Model, car_names.Model",
            "select model_list.Model, t3.c3",
            "select model_list.Model, model_list.Maker",
            "select model_list.Model, t3.c4",
            "select model_list.Model [model_list.ModelId]"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the model names with the most versions., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t4",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "car_names",
        "topk_preds": [
            "model_list car_names",
            "model_list",
            "car_makers model_list car_names",
            "model_list cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all European countries where there are at least three manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAGROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all European countries where there are at least three manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all European countries where there are at least three manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "",
            "countries car_makers",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all the names of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GHOST-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all the names of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName de, continents.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all the names of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "countries car_makers",
            "continents countries",
            "",
            "",
            "",
            "",
            "continents countries car_makers model_list"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of all European countries with three or more manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GHESS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GHOST-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of all European countries with three or more manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName de, continents.ContId",
            "select countries.CountryName de, continents.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of all European countries with three or more manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "countries car_makers",
            "continents countries",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GHOST-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName, continents.ContId2",
            "select countries.CountryName (continents.ContId)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of all European countries with three or more manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "countries car_makers",
            "continents countries",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of all European countries with more or equal to 3 manufactures?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAUSS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of all European countries with more or equal to 3 manufactures?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t0.c3",
            "select countries.CountryName de, continents.Continent",
            "select countries.CountryName, t0.c4",
            "select countries.CountryName (t0.c2)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of all European countries with more or equal to 3 manufactures?, database: Database: car_1. t0: continents(c0: contid, c1: continent (europe)). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "continents countries car_makers",
        "real_label": "continents countries car_makers",
        "topk_preds": [
            "continents countries car_makers",
            "continents car_makers",
            "continents countries",
            "",
            "countries car_makers",
            "",
            "continents countries car_makers model_list",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the mean EDISPL for all volvos?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (volvo), c2: fullname (Volvo), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (volvo)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (volvo), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t5.c3)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the mean EDISPL for all volvos?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (volvo), c2: fullname (Volvo), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (volvo)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (volvo), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c3)",
        "label": "select avg(t5.c3)",
        "score": true,
        "real_pred": "select avg(cars_data.Edispl)",
        "real_label": "select avg(cars_data.Edispl)",
        "topk_preds": [
            "select avg(cars_data.Edispl)",
            "select an avg(cars_data.Edispl)",
            "select avg(cars_data.Edispl)",
            "select  avg(cars_data.Edispl)",
            "select Avg(cars_data.Edispl)",
            "select avg(cars_data.Cylinders)",
            "select avg(cars_data.Edispl),",
            "select mean(cars_data.Edispl)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the mean EDISPL for all volvos?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (volvo), c2: fullname (Volvo), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (volvo)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (volvo), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "cars_data",
            "model_list car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "countries cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the makers and their ids of car brands that produce two or more models and produce four or more car models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING AND-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING-",
            "SELECT-FROM-GROUP BY-HAVING,-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the makers and their ids of car brands that produce two or more models and produce four or more car models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2, t4.c0",
        "label": "select t2.c0, t2.c1",
        "score": false,
        "real_pred": "select car_names.Make, car_names.MakeId",
        "real_label": "select car_makers.Id, car_makers.Maker",
        "topk_preds": [
            "select car_names.Make, car_names.MakeId",
            "select car_makers.Maker, car_names.MakeId",
            "select car_makers.Maker, car_makers.Id",
            "select car_names.Model, car_names.MakeId",
            "select model_list.Maker, car_names.MakeId",
            "select car_makers.Maker, model_list.ModelId",
            "select model_list.Maker, model_list.ModelId",
            "select car_makers.Maker, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the makers and their ids of car brands that produce two or more models and produce four or more car models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t2 t3 t4",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "car_makers model_list car_names",
        "topk_preds": [
            "model_list car_names",
            "car_makers model_list car_names",
            "continents car_makers model_list car_names",
            "countries model_list car_names",
            "car_makers car_names",
            "countries car_names",
            "car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the ids and makers of the car manufacturers that have produced two or more models and manufactured more than three cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING AND-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING AND-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the ids and makers of the car manufacturers that have produced two or more models and manufactured more than three cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c0, t2.c1",
        "label": "select t2.c0, t2.c1",
        "score": true,
        "real_pred": "select car_makers.Id, car_makers.Maker",
        "real_label": "select car_makers.Id, car_makers.Maker",
        "topk_preds": [
            "select car_makers.Id, car_makers.Maker",
            "select model_list.ModelId, car_makers.Maker",
            "select car_names.Model, car_makers.Maker",
            "select car_names.Model, car_makers.FullName",
            "select car_names.MakeId, car_makers.Maker",
            "select car_names.Model, car_makers.Id",
            "select car_names.Make, car_makers.Maker",
            "select model_list.Maker, car_makers.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the ids and makers of the car manufacturers that have produced two or more models and manufactured more than three cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3 t4",
        "score": true,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list car_names",
        "topk_preds": [
            "car_makers model_list car_names",
            "countries car_makers model_list car_names",
            "model_list car_names",
            "",
            "continents car_makers model_list car_names",
            "countries model_list car_names",
            "",
            "continents model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the horsepower of the car that has the greatest acceleration?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the horsepower of the car that has the greatest acceleration?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c4",
        "label": "select t5.c4",
        "score": true,
        "real_pred": "select cars_data.Horsepower",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate",
            "select cars_data.Id, cars_data.Horsepower",
            "select cars_data.Horsepower, t5.diff(cars_data.Accelerate)",
            "select cars_data.Id, cars_data.Cylinders",
            "select cars_data.Id, cars_data.Cylinders, cars_data.Horsepower",
            "select cars_data.Horsepower, t5.diff, cars_data.Accelerate",
            "select cars_data.Horsepower, cars_data.Accelerate, cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the horsepower of the car that has the greatest acceleration?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the horsepower of the car with the maximum acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ALERT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the horsepower of the car with the maximum acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c4",
        "label": "select t5.c4",
        "score": true,
        "real_pred": "select cars_data.Horsepower",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate",
            "select cars_data.Id, cars_data.Horsepower",
            "select max(cars_data.Horsepower)",
            "select cars_data.Id, cars_data.Cylinders",
            "select cars_data.Horsepower (cars_data.Accelerate)",
            "select cars_data.Horsepower(cars_data.Accelerate)",
            "select cars_data.Horsepower (cars_data.Horsepower)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the horsepower of the car with the maximum acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much horse power does the car have that can accelerate the fastest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much horse power does the car have that can accelerate the fastest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c4",
        "label": "select t5.c4",
        "score": true,
        "real_pred": "select cars_data.Horsepower",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate",
            "select cars_data.Horsepower, t5.diff(cars_data.Accelerate)",
            "select max(cars_data.Horsepower)",
            "select cars_data.Horsepower (rev. cars_data.Accelerate)",
            "select cars_data.Horsepower, t5.diff, cars_data.Accelerate",
            "select cars_data.Horsepower, cars_data.Accelerate, cars_data.Year",
            "select cars_data.Horsepower (or cars_data.Accelerate)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much horse power does the car have that can accelerate the fastest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the horsepower of the car that currently accelerates fastest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the horsepower of the car that currently accelerates fastest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c4",
        "label": "select t5.c4",
        "score": true,
        "real_pred": "select cars_data.Horsepower",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate",
            "select cars_data.Horsepower, t5.diff(cars_data.Accelerate)",
            "select cars_data.Horsepower, cars_data.Accelerate, cars_data.Year",
            "select cars_data.Horsepower, t5.diff, cars_data.Accelerate",
            "select cars_data.Horsepower (cars_data.Accelerate)",
            "select cars_data.Horsepower, t5.dbl(cars_data.Accelerate)",
            "select cars_data.Horsepower, t5.diff(cars_data.Edispl)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the horsepower of the car that currently accelerates fastest?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of cars manufactured in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY -ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of cars manufactured in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Country",
            "select car_makers.Country, count(*)",
            "select count(*), car_makers.Maker",
            "select count(*), car_makers.Id",
            "select count(car_makers.Id)",
            "select sum(car_makers.Country)",
            "select count(*), car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of cars manufactured in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "car_makers",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "car_makers",
            "car_makers car_names",
            "",
            "",
            "",
            "",
            "",
            "car_makers model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of cars produced in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of cars produced in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), car_makers.Country",
            "select car_makers.Country, count(*)",
            "select sum(car_makers.Country)",
            "select count(*), car_makers.Maker",
            "select count(*), car_makers.Id",
            "select count(car_makers.Id)",
            "select count(*), car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of cars produced in the United States., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "car_makers",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "car_makers",
            "car_makers car_names",
            "countries car_makers car_names",
            "countries car_makers",
            "continents car_makers car_names",
            "car_makers cars_data",
            "continents car_makers",
            "car_makers model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of cars that have a horsepower above 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of cars that have a horsepower above 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*) dependant on cars_data.Id",
            "select count(*), t5.dcars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*),",
            "select count(*), cars_data.MPG",
            "select count(*) de cars_data.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of cars that have a horsepower above 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the number of cars that have a horsepower of over 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE(t5.c0)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the number of cars that have a horsepower of over 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*) dependant on cars_data.Id",
            "select count(*) depreciated(cars_data.Id)",
            "select count(*) depreciated cars_data.Id",
            "select count(*), t5.dcars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the number of cars that have a horsepower of over 150., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different models with the weight lower than 3500 but were not built by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE but-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE BUT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2014EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different models with the weight lower than 3500 but were not built by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t3.c2",
        "label": "select distinct t3.c2",
        "score": true,
        "real_pred": "select distinct model_list.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct model_list.Model",
            "select distinct car_names.Model",
            "select distinct car_names.Make",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select distinct car_names.Model, car_makers.FullName",
            "select distinct model_list.Model, car_makers.Maker",
            "select distinct car_makers.Maker, model_list.Model",
            "select distinct model_list.Model, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different models with the weight lower than 3500 but were not built by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list cars_data",
            "countries car_makers model_list cars_data",
            "continents car_makers model_list cars_data",
            "car_makers model_list car_names",
            "",
            "car_makers model_list",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What were all the cars weighing less than 3500, but built outside of the Ford company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, BUT-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, BUT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE but-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE BUT-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What were all the cars weighing less than 3500, but built outside of the Ford company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Make",
            "select car_names.Model, car_names.Make",
            "select car_makers.Maker, car_names.Make",
            "select car_names.Make, car_names.Model",
            "select model_list.Maker, car_names.Make",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.FullName, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What were all the cars weighing less than 3500, but built outside of the Ford company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "countries car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "model_list car_names cars_data",
            "car_names cars_data",
            "continents car_makers car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and ids of all countries that has at least one car manufacturer., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM at-GROUP BY-HAVING",
            "SELECT-FROM gROUP BY-HAVING",
            "SELECT-FROM -GROUP BY-HAVING",
            "SELECT-FROM g1.c1, t1.c0"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and ids of all countries that has at least one car manufacturer., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c1, t1.c0",
        "score": true,
        "real_pred": "select countries.CountryName, countries.CountryId",
        "real_label": "select countries.CountryName, countries.CountryId",
        "topk_preds": [
            "select countries.CountryName, countries.CountryId",
            "select distinct countries.CountryName, countries.CountryId",
            "select count(*), countries.CountryName, countries.CountryId",
            "select at least countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, countries.CountryId, car_makers.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and ids of all countries that has at least one car manufacturer., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and IDs of all countries with two or more car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and IDs of all countries with two or more car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c1, t1.c0",
        "score": true,
        "real_pred": "select countries.CountryName, countries.CountryId",
        "real_label": "select countries.CountryName, countries.CountryId",
        "topk_preds": [
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName.c0, countries.CountryName",
            "select countries.CountryName, t01.c0",
            "select countries.CountryName, t1c0",
            "select countries.CountryName, countries.CountryId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and IDs of all countries with two or more car makers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and IDs of all countries that have at least one car manufacturer., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM -GROUP BY-HAVING",
            "SELECT-FROM - GROUP BY-HAVING",
            "SELECT-FROM at-GROUP BY-HAVING",
            "SELECT-FROM -GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and IDs of all countries that have at least one car manufacturer., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c1, t1.c0",
        "score": true,
        "real_pred": "select countries.CountryName, countries.CountryId",
        "real_label": "select countries.CountryName, countries.CountryId",
        "topk_preds": [
            "select countries.CountryName, countries.CountryId",
            "select distinct countries.CountryName, countries.CountryId",
            "select count(*), countries.CountryName, countries.CountryId",
            "select at least countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Country",
            "select count(*), countries.CountryName, car_makers.Id",
            "select count(*), countries.CountryName, car_makers.Country",
            "select countries.CountryName, car_makers.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and IDs of all countries that have at least one car manufacturer., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and IDs of all countries with two or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and IDs of all countries with two or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c1, t1.c0",
        "score": true,
        "real_pred": "select countries.CountryName, countries.CountryId",
        "real_label": "select countries.CountryName, countries.CountryId",
        "topk_preds": [
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, t01.c0",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, t1c0",
            "select countries.CountryName, t.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and IDs of all countries with two or more car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which model of the car weighs less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which model of the car weighs less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select model_list.Model, car_names.Model",
            "select car_names.Model, model_list.Model",
            "select car_names.Model, t4.c3",
            "select car_names.Model (car_names.Make)",
            "select model_list.Model, model_list.ModelId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which model of the car weighs less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents model_list car_names cars_data",
            "car_names cars_data",
            "countries car_names cars_data",
            "car_makers car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model of the car whose weight is smaller than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING)",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model of the car whose weight is smaller than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select car_names.Model, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select car_names.Model, car_names.Make",
            "select model_list.Model (refers to car_names.Model)",
            "select model_list.Model (or car_names.Model)",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model of the car whose weight is smaller than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_makers model_list car_names cars_data",
            "car_names cars_data",
            "continents model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the make and model of the car whose weight is less than the average weight., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the make and model of the car whose weight is less than the average weight., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2, t4.c1",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select car_names.Make, car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Make, car_names.Model",
            "select distinct car_names.Make, car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Make, car_names.Model, car_names.MakeId",
            "select car_makers.FullName, car_names.Model",
            "select car_names.MakeId, car_names.Make, car_names.Model",
            "select car_names.Make, car_names.Model",
            "select car_names.Make, car_names.Model,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the make and model of the car whose weight is less than the average weight., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: In which years were cars produced weighing between 3000 and 4000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: In which years were cars produced weighing between 3000 and 4000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select distinct cars_data.Year",
            "select specific cars_data.Year",
            "select cars_data.Year",
            "select the cars_data.Year",
            "select year(cars_data.Year)",
            "select exact cars_data.Year",
            "select cars_data.Year,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: In which years were cars produced weighing between 3000 and 4000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "model_list cars_data",
            "car_names cars_data",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When were cars produced that weighed exactly between 3000 and 4000 grams?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When were cars produced that weighed exactly between 3000 and 4000 grams?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select t4.c7",
            "select t7.c7",
            "select cars_data.Year",
            "select t6.c7",
            "select t8.c7",
            "select t7",
            "select t0.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When were cars produced that weighed exactly between 3000 and 4000 grams?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "",
            "",
            "",
            "cars_data car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the years that cars were produced weighing between 3000 and 4000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the years that cars were produced weighing between 3000 and 4000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select distinct cars_data.Year",
            "select avg(cars_data.Year)",
            "select cars_data.Year, t5.c8",
            "select the cars_data.Year",
            "select cars_data.Year",
            "select cars_data.Year, cars_data.Accelerate",
            "select cars_data.Year, cars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the years that cars were produced weighing between 3000 and 4000?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "model_list cars_data",
            "",
            "car_names cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the countries that have one or moew car manufacturer, mention their names and ids., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the countries that have one or moew car manufacturer, mention their names and ids., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t2.c0",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select countries.CountryName, car_makers.Id",
        "real_label": "select countries.CountryName, countries.CountryId",
        "topk_preds": [
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, continents.ContId",
            "select countries.CountryName, car_makers.FullName",
            "select countries.CountryName, car_makers.Id3",
            "select countries.CountryName, car_makers.Maker",
            "select countries.CountryName, countries.CountryId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the countries that have one or moew car manufacturer, mention their names and ids., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the countries that have car makers? Give the names and ids., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM t1.c1, t2.c0",
            "SELECT-FROM t1.c1, t2.c3",
            "SELECT-FROM-C1, t2.c0",
            "SELECT-FROM-C1, t2.c3",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the countries that have car makers? Give the names and ids., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t2.c0",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select countries.CountryName, car_makers.Id",
        "real_label": "select countries.CountryName, countries.CountryId",
        "topk_preds": [
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, car_makers.Country",
            "select distinct countries.CountryName, car_makers.Id",
            "select countries.CountryName, countries.CountryId",
            "select distinct countries.CountryName, countries.CountryId",
            "select distinct countries.CountryName, car_makers.Country",
            "select countries.CountryName, car_makers.Id3",
            "select countries.CountryName, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the countries that have car makers? Give the names and ids., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which car model is rated to have the best mpg rating?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which car model is rated to have the best mpg rating?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model (cars_data.MPG)",
            "select car_names.Model (cars_data.Id)",
            "select car_names.Model, car_names.Make",
            "select car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which car model is rated to have the best mpg rating?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents model_list car_names cars_data",
            "continents car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the car model with the best fuel efficiency., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the car model with the best fuel efficiency., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, model_list.Model",
            "select car_names.Model (cars_data.MPG)",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model, car_names.MakeId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the car model with the best fuel efficiency., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the car model with the best gas mileage?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the car model with the best gas mileage?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Model (cars_data.MPG)",
            "select car_names.Model, model_list.Model",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model(cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the car model with the best gas mileage?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names and ids of the countries that have 4 or more car makers or produce the Fiat model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING or-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVING-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names and ids of the countries that have 4 or more car makers or produce the Fiat model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1, t1.c0",
        "label": "select t1.c0, t1.c1",
        "score": false,
        "real_pred": "select countries.CountryName, countries.CountryId",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_makers.Id",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, car_names.MakeId",
            "select car_makers.Maker, car_makers.Id",
            "select countries.CountryName., countries.CountryId",
            "select countries.CountryName, model_list.ModelId",
            "select countries.CountryName, countries.CountryId0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names and ids of the countries that have 4 or more car makers or produce the Fiat model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "countries model_list car_names",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which car has the largest horsepower among the four-cylinder model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which car has the largest horsepower among the four-cylinder model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Model-, car_names.Make",
            "select car_names.Model, car_names.MakeId",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which car has the largest horsepower among the four-cylinder model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "car_makers car_names cars_data",
            "countries cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For all of the 4 cylinder cars, which model has the largest amount of horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For all of the 4 cylinder cars, which model has the largest amount of horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Id",
            "select car_names.Model (cars_data.Horsepower)",
            "select car_names.Model def. cars_data.Cylinders",
            "select car_names.Model (cars_data.Cylinders)",
            "select car_names.Model, cars_data.Weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For all of the 4 cylinder cars, which model has the largest amount of horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "countries cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the data for all 4-cylinder cars, listing the model with the largest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the data for all 4-cylinder cars, listing the model with the largest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1, t5.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select car_names.Model, cars_data.Cylinders",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model, cars_data.Cylinders",
            "select cars_data.MPG, max(cars_data.Horsepower)",
            "select cars_data.MPG, cars_data.Cylinders",
            "select car_names.Model",
            "select car_names.Model, max(cars_data.Horsepower)",
            "select car_names.Model, cars_data.Id",
            "select cars_data.MPG, cars_data.Edispl",
            "select car_names.Model, cars_data.Horsepower"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the data for all 4-cylinder cars, listing the model with the largest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "cars_data",
            "model_list car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "countries cars_data",
            "model_list cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which of the 4-cylinder models has the greatest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which of the 4-cylinder models has the greatest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.MakeId, car_names.Model",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Make",
            "select car_names.Model, car_names.Make",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, cars_data.Edispl"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which of the 4-cylinder models has the greatest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_makers cars_data",
            "",
            "countries car_names cars_data",
            "countries cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the country which has the largest number of car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the country which has the largest number of car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName (countries.Continent)",
            "select countries.CountryName de, car_makers.Country",
            "select countries.CountryName, t0.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the country which has the largest number of car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the country with the largest number of car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the country with the largest number of car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName de, car_makers.Country",
            "select countries.CountryName (countries.Continent)",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName (countries.CountryId)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the country with the largest number of car makers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name of the country with the most car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name of the country with the most car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName (countries.Continent)",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName,",
            "select countries.CountryName, continents.Continent",
            "select countries.CountryName pour car_makers.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name of the country with the most car manufacturers., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the country with the largest number of car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the country with the largest number of car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select countries.CountryName",
        "real_label": "select countries.CountryName",
        "topk_preds": [
            "select countries.CountryName",
            "select countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select countries.CountryName, countries.Continent",
            "select countries.CountryName (countries.Continent)",
            "select countries.CountryName de, car_makers.Country",
            "select countries.CountryName, t0.c2",
            "select countries.CountryName, continents.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the country with the largest number of car manufacturers?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "countries car_makers",
        "real_label": "countries car_makers",
        "topk_preds": [
            "countries car_makers",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the best mpg value of all vehicles with eight cylinders that were made ahead of 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE - ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the best mpg value of all vehicles with eight cylinders that were made ahead of 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c1)",
        "label": "select max(t5.c1)",
        "score": true,
        "real_pred": "select max(cars_data.MPG)",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select max(cars_data.MPG)",
            "select cars_data.MPG",
            "select min(cars_data.MPG)",
            "select max(cars_data.MPG), cars_data.Cylinders",
            "select max(cars_data.MPG), cars_data.Year",
            "select avg(cars_data.MPG)",
            "select max(cars_data.MPG), cars_data.Accelerate",
            "select min(cars_data.MPG), cars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the best mpg value of all vehicles with eight cylinders that were made ahead of 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all the manufacturers with at least four car models and list their name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all the manufacturers with at least four car models and list their name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.Id",
            "select car_makers.FullName, model_list.Maker, model_list.ModelId",
            "select car_makers.FullName, model_list.Maker, car_names.MakeId",
            "select model_list.Maker, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, car_names.Model, car_makers.Id",
            "select car_makers.FullName, model_list.Maker, car_makers.Id",
            "select car_makers.FullName, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all the manufacturers with at least four car models and list their name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers model_list car_names",
            "countries car_makers model_list car_names",
            "",
            "",
            "",
            "car_makers model_list",
            "car_makers car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the makers who have made 3 or more cars. List the full name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUPGROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the makers who have made 3 or more cars. List the full name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c0",
        "label": "select t2.c2, t2.c0",
        "score": true,
        "real_pred": "select car_makers.FullName, car_makers.Id",
        "real_label": "select car_makers.FullName, car_makers.Id",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Id",
            "select car_makers.Maker, car_makers.FullName, car_makers.Id",
            "select t2.c4, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, car_makers.Maker, car_makers.Id",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker",
            "select car_makers.Id, car_makers.FullName, car_makers.Id",
            "select car_makers.FullName, car_makers.Id, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName & car_makers.Id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the makers who have made 3 or more cars. List the full name and id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4",
        "label": "t2 t3",
        "score": false,
        "real_pred": "car_makers car_names",
        "real_label": "car_makers model_list",
        "topk_preds": [
            "car_makers car_names",
            "",
            "car_makers model_list car_names",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the most horsepower for the models with three cylinders and what make is it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT - GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the most horsepower for the models with three cylinders and what make is it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1, t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select car_names.Model, car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select car_names.Model, car_names.Make",
            "select max(cars_data.Horsepower), car_names.Make",
            "select car_names.Make, max(cars_data.Horsepower)",
            "select car_names.Make, car_names.Model",
            "select cars_data.MPG, car_names.Make",
            "select min(cars_data.Horsepower), car_names.Make",
            "select car_makers.Maker, car_names.Make",
            "select cars_data.Cylinders, car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the most horsepower for the models with three cylinders and what make is it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "model_list cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the biggest amount of power for the three cylinder models, and what brand is it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the biggest amount of power for the three cylinder models, and what brand is it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1, t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select car_names.Model, car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select car_names.Model, car_names.Make",
            "select max(cars_data.Horsepower), car_names.Make",
            "select cars_data.MPG, car_names.Make",
            "select car_makers.Maker, car_names.Make",
            "select min(cars_data.Horsepower), car_names.Make",
            "select car_names.Make, cars_data.Horsepower",
            "select car_names.Make, car_names.Model",
            "select max(cars_data.Horsepower), car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the biggest amount of power for the three cylinder models, and what brand is it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers cars_data",
            "model_list cars_data",
            "continents car_names cars_data",
            "car_makers car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the most amount of horsepower for the models with three cylinders made by what manufacturer?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the most amount of horsepower for the models with three cylinders made by what manufacturer?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1, max(t5.c4)",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select car_names.Model, max(cars_data.Horsepower)",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select car_names.Model, max(cars_data.Horsepower)",
            "select car_names.Make, max(cars_data.Horsepower)",
            "select cars_data.MPG, max(cars_data.Horsepower)",
            "select max(cars_data.Horsepower), car_names.Model",
            "select max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Horsepower), model_list.Maker",
            "select model_list.Maker, max(cars_data.Horsepower)",
            "select car_names.Make, cars_data.Horsepower"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the most amount of horsepower for the models with three cylinders made by what manufacturer?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "model_list cars_data",
            "car_names cars_data",
            "countries car_names cars_data",
            "car_makers model_list cars_data",
            "car_makers cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the model of the car which produces the least horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the model of the car which produces the least horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Make",
            "select car_names.Model, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the model of the car which produces the least horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_names cars_data",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "continents model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which model of the cars is lowest in terms of power?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which model of the cars is lowest in terms of power?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model (car_names.Make)",
            "select model_list.Model, car_names.MakeId",
            "select model_list.Model, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which model of the cars is lowest in terms of power?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_names cars_data",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents model_list car_names cars_data",
            "continents car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model of the car with the lowest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model of the car with the lowest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.Make",
            "select car_names.Model (car_names.Make)",
            "select model_list.Model, car_names.Model",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model of the car with the lowest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all models that weighs less than 3,500 kg but were not produced by Ford Motors., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.E-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2014EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all models that weighs less than 3,500 kg but were not produced by Ford Motors., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, model_list.Model",
            "select model_list.Maker",
            "select car_names.Model, car_names.Make",
            "select model_list.Maker, model_list.Model",
            "select model_list.Model, model_list.Maker",
            "select car_names.Model, model_list.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all models that weighs less than 3,500 kg but were not produced by Ford Motors., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "model_list car_names",
            "model_list cars_data",
            "car_makers model_list car_names",
            "countries model_list car_names",
            "car_makers model_list cars_data",
            "continents model_list car_names",
            "countries model_list cars_data",
            "continents model_list cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which models have less than 3500 lb and are not made by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE AND-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM the-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which models have less than 3500 lb and are not made by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_makers.FullName",
            "select model_list.Model, car_makers.Maker",
            "select model_list.Maker, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName",
            "select car_names.Model, car_names.Make",
            "select model_list.Model",
            "select model_list.Model, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which models have less than 3500 lb and are not made by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers model_list cars_data",
            "countries car_makers model_list car_names",
            "countries car_makers model_list cars_data",
            "continents car_makers model_list car_names",
            "car_makers model_list car_makers car_names",
            "",
            "continents car_makers model_list cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which models weigh less than 3500 pounds but are not made by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE but-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2014EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM the-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which models weigh less than 3500 pounds but are not made by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_makers.FullName",
            "select model_list.Maker, car_makers.FullName",
            "select model_list.Model",
            "select car_makers.Maker, model_list.Model",
            "select car_names.Make",
            "select car_makers.Maker, car_makers.FullName",
            "select model_list.Model, car_makers.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which models weigh less than 3500 pounds but are not made by the Ford Motor Company?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname (Ford Motor Company), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list cars_data",
            "car_makers model_list car_names",
            "countries car_makers model_list cars_data",
            "countries car_makers model_list car_names",
            "continents car_makers model_list cars_data",
            "continents car_makers model_list car_names",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the models that weighs less than 3500 kg but isn't a Ford?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE but-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE BUT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the models that weighs less than 3500 kg but isn't a Ford?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select model_list.ModelId",
            "select model_list.Model, model_list.ModelId",
            "select model_list.Model, car_names.Model",
            "select model_list.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the models that weighs less than 3500 kg but isn't a Ford?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (ford), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (ford)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (ford), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "model_list car_names",
            "car_makers model_list car_names",
            "model_list cars_data",
            "countries model_list car_names",
            "continents model_list car_names",
            "car_names cars_data",
            "car_makers model_list cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest horsepower and the make of the cars with three cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest horsepower and the make of the cars with three cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c4), t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select max(cars_data.Horsepower), car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select max(cars_data.Horsepower), car_names.Make",
            "select cars_data.Horsepower, car_names.Make",
            "select max(cars_data.Horsepower), max(car_names.Make)",
            "select max(cars_data.Accelerate), car_names.Make",
            "select max(cars_data.Horsepower), car_names.Make)",
            "select max(cars_data.Horsepower), cars_data.Cylinders",
            "select max(cars_data.Weight), car_names.Make",
            "select Max(cars_data.Horsepower), car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest horsepower and the make of the cars with three cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "model_list cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest horsepower and the make of cars with three cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest horsepower and the make of cars with three cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c4), t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select max(cars_data.Horsepower), car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select max(cars_data.Horsepower), car_names.Make",
            "select cars_data.Horsepower, car_names.Make",
            "select max(cars_data.Accelerate), car_names.Make",
            "select max(cars_data.Horsepower), car_names.Make)",
            "select max(cars_data.Horsepower), cars_data.Cylinders",
            "select max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Weight), car_names.Make",
            "select Max(cars_data.Horsepower), car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest horsepower and the make of cars with three cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers cars_data",
            "countries car_names cars_data",
            "model_list car_names cars_data",
            "continents car_names cars_data",
            "model_list cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest horsepower and the make of the car models with three cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE - GROUP BY-HAVING",
            "SELECT-FROM-WHERE, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest horsepower and the make of the car models with three cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c4), t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select max(cars_data.Horsepower), car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Horsepower), max(car_names.Make)",
            "select cars_data.Horsepower, car_names.Make",
            "select max(cars_data.Accelerate), car_names.Make",
            "select max(cars_data.Horsepower), cars_data.Cylinders",
            "select max(cars_data.Horsepower), car_names.Make)",
            "select max(cars_data.Weight), car_names.Make",
            "select Max(cars_data.Horsepower), car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest horsepower and the make of the car models with three cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "countries car_names cars_data",
            "car_makers cars_data",
            "model_list car_names cars_data",
            "continents car_names cars_data",
            "model_list cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the largest horsepower and the manufacturer of the car models with 3 cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the largest horsepower and the manufacturer of the car models with 3 cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c4), t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select max(cars_data.Horsepower), car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Horsepower), car_names.Model",
            "select max(cars_data.Horsepower), cars_data.Cylinders",
            "select max(cars_data.Horsepower), model_list.Maker",
            "select max(cars_data.Horsepower), cars_data.MPG",
            "select max(cars_data.Horsepower), car_makers.Maker",
            "select cars_data.Horsepower, car_names.Make",
            "select cars_data.Horsepower, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the largest horsepower and the manufacturer of the car models with 3 cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "car_names cars_data",
            "model_list car_names cars_data",
            "cars_data",
            "car_makers cars_data",
            "cars_data car_names",
            "cars_data car_names cars_data",
            "countries car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the lightest car with 8 cylinders that was produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE - ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the lightest car with 8 cylinders that was produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c5",
        "label": "select min(t5.c5)",
        "score": false,
        "real_pred": "select cars_data.Weight",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select cars_data.Weight",
            "select cars_data.Id",
            "select max(cars_data.Weight)",
            "select car_names.Model",
            "select cars_data.MPG",
            "select min(cars_data.Weight)",
            "select cars_data.Weight5",
            "select cars_data.Id5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the lightest car with 8 cylinders that was produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "cars_data car_names cars_data",
            "car_names cars_data",
            "cars_data car_names",
            "model_list cars_data",
            "",
            "car_makers cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the lowest weight of the car with eight cylinders produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-MIN(t5.c5)",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (MIN(t5.c5)",
            "SELECT-FROM-WHERE, min(t5.c5)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the lowest weight of the car with eight cylinders produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select min(t5.c5)",
        "label": "select min(t5.c5)",
        "score": true,
        "real_pred": "select min(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select min(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Year",
            "select min(cars_data.Weight), cars_data.Accelerate",
            "select min(cars_data.Weight), cars_data.Cylinders",
            "select min(cars_data.Weight), cars_data.Id",
            "select min(cars_data.Weight), t5.c8",
            "select cars_data.Weight",
            "select min(cars_data.Weight), cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the lowest weight of the car with eight cylinders produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the lightest weight car with 8 cylinders produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE - ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the lightest weight car with 8 cylinders produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c5",
        "label": "select min(t5.c5)",
        "score": false,
        "real_pred": "select cars_data.Weight",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select cars_data.Weight",
            "select max(cars_data.Weight)",
            "select car_names.Model",
            "select cars_data.Id",
            "select min(cars_data.Weight)",
            "select t6.c1",
            "select cars_data.MPG",
            "select t1.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the lightest weight car with 8 cylinders produced in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "cars_data car_names cars_data",
            "car_names cars_data",
            "",
            "cars_data car_names",
            "model_list cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the cars that have a higher accelerate than the car with the largest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the cars that have a higher accelerate than the car with the largest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c0",
        "label": "select count(*)",
        "score": false,
        "real_pred": "select cars_data.Id",
        "real_label": "select count(*)",
        "topk_preds": [
            "select cars_data.Id",
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select cars_data.MPG",
            "select cars_data.Id, cars_data.MPG",
            "select car_names.Model, cars_data.Cylinders",
            "select cars_data.Id, cars_data.Accelerate",
            "select cars_data.MPG, cars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the cars that have a higher accelerate than the car with the largest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "car_names cars_data",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cars have an accelerate greater than the car with the biggest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY -LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY the-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cars have an accelerate greater than the car with the biggest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Accelerate",
            "select count(*), cars_data.Horsepower",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.MPG",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cars have an accelerate greater than the car with the biggest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cars have a higher acceleration than the car with the highest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE CIRCUMSTAT-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE CIRCUMSCRIPT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cars have a higher acceleration than the car with the highest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Horsepower",
            "select count(*), cars_data.Id",
            "select count(distinct cars_data.Id)",
            "select count(*), cars_data.Accelerate",
            "select count(*), cars_data.MPG",
            "select count(*), cars_data.Cylinders",
            "select count(*) (cars_data.Id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cars have a higher acceleration than the car with the highest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cars have acceleration larger than the car with the largest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY -LIMIT",
            "SELECT-FROM-WHERE-GROUP BY -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY the-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cars have acceleration larger than the car with the largest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Accelerate",
            "select count(*), cars_data.Horsepower",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Cylinders",
            "select count(*), t5.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cars have acceleration larger than the car with the largest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the highest mpg of the car with 8 cylinders or produced before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the highest mpg of the car with 8 cylinders or produced before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c1)",
        "label": "select max(t5.c1)",
        "score": true,
        "real_pred": "select max(cars_data.MPG)",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select max(cars_data.MPG)",
            "select max(cars_data.MPG), cars_data.Cylinders",
            "select max(cars_data.MPG), cars_data.Year",
            "select cars_data.MPG",
            "select max(cars_data.MPG), cars_data.Accelerate",
            "select max(cars_data.MPG) def. cars_data.Cylinders",
            "select max(cars_data.MPG), cars_data.Id",
            "select min(cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the highest mpg of the car with 8 cylinders or produced before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the highest mileage per gallon of the car with 8 cylinders or made before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the highest mileage per gallon of the car with 8 cylinders or made before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c1)",
        "label": "select max(t5.c1)",
        "score": true,
        "real_pred": "select max(cars_data.MPG)",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select max(cars_data.MPG)",
            "select max(cars_data.MPG), car_names.Make",
            "select max(cars_data.MPG), car_names.Model, car_names.Make",
            "select max(cars_data.MPG) def. car_names.Model, car_names.Make",
            "select max(cars_data.MPG), car_names.Make, t4.c7",
            "select cars_data.MPG",
            "select max(cars_data.MPG), car_names.Model",
            "select max(cars_data.MPG), car_names.Make, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the highest mileage per gallon of the car with 8 cylinders or made before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list car_names cars_data",
            "",
            "car_makers cars_data",
            "",
            "countries cars_data",
            "model_list cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the greatest mileage per gallon of the car with 8 cylinders or produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-SCHEMPT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the greatest mileage per gallon of the car with 8 cylinders or produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c1)",
        "label": "select max(t5.c1)",
        "score": true,
        "real_pred": "select max(cars_data.MPG)",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select max(cars_data.MPG)",
            "select max(cars_data.MPG), cars_data.Cylinders",
            "select cars_data.MPG",
            "select max(cars_data.MPG), cars_data.Year",
            "select max(cars_data.MPG) def. cars_data.Cylinders",
            "select max(cars_data.MPG), cars_data.Accelerate",
            "select max(cars_data.MPG), cars_data.Id",
            "select max(cars_data.MPG), cars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the greatest mileage per gallon of the car with 8 cylinders or produced before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "",
            "model_list cars_data",
            "",
            "car_makers cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the best mileage per gallon in a car with eight cylinders or made before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the best mileage per gallon in a car with eight cylinders or made before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c1",
        "label": "select max(t5.c1)",
        "score": false,
        "real_pred": "select cars_data.MPG",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select cars_data.MPG",
            "select max(cars_data.MPG)",
            "select cars_data.MPG, car_names.Model, car_names.Make",
            "select cars_data.MPG, car_names.Make",
            "select cars_data.MPG, car_names.Make, t4.c7",
            "select cars_data.MPG, car_names.Model",
            "select min(cars_data.MPG)",
            "select cars_data.MPG, car_names.Make, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the best mileage per gallon in a car with eight cylinders or made before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list car_names cars_data",
            "cars_data car_names cars_data",
            "",
            "model_list cars_data",
            "car_makers cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the amount of flights that depart from Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE PER-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the amount of flights that depart from Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airports.City",
            "select count(*), airports.City, flights.SourceAirport",
            "select count(*), airports.City, flights.DestAirport",
            "select count(*), airports.City, airports.AirportName",
            "select count(distinct flights.FlightNo)",
            "select count(*), airports.City, flights.FlightNo",
            "select count(*), airports.City, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the amount of flights that depart from Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the total count of airports., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM, count(*)",
            "SELECT-FROM total(*)",
            "SELECT-FROM Total(*)",
            "SELECT-FROM (count(*)",
            "SELECT SELECT-FROM",
            "SELECT-FROM (*)",
            "SELECT-FROM the count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the total count of airports., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airports.AirportCode",
            "select count(*), airports.AirportCode, airports.AirportName",
            "select count(*), airports.AirportCode - airports.AirportName",
            "select count(*), airports.AirportCode-, airports.AirportName",
            "select t1.c count(*)",
            "select count(*), airports.AirportCode & airports.AirportName",
            "select count(*), airports.AirportCode (airports.AirportName)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the total count of airports., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "airports",
        "real_label": "airports",
        "topk_preds": [
            "airports",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the code of airport that currently has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the code of airport that currently has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode IATA-CONTROL-GROUP BY-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROL-FROM-GROUP BY-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROL-GROUP BY-ORDER BY-LIMIT-INTERSECT-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROL-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROL-GROUP BY-ORDER BY-LIMIT, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the code of airport that currently has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the code of the airport that has the most flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the code of the airport that has the most flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode (airports.AirportName)",
            "select airports.AirportCode IATA, airports.AirportName",
            "select airports.AirportCode de, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the code of the airport that has the most flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the code for the airport that currently has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the code for the airport that currently has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode-, airports.AirportName",
            "select airports.AirportCode (airports.AirportName)",
            "select airports.AirportCode IATA, airports.AirportName",
            "select airports.AirportCode or airports.AirportName",
            "select airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the code for the airport that currently has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the code for the airport that currently has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the code for the airport that currently has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode-, airports.AirportName",
            "select airports.AirportCode (airports.AirportName)",
            "select airports.AirportCode IATA, airports.AirportName",
            "select airports.AirportName",
            "select airports.AirportCode or airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the code for the airport that currently has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the code of airport that has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the code of airport that has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode IATA-CONTROL-GROUP BY-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROL-FROM-GROUP BY-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROL-GROUP BY-ORDER BY-LIMIT-INTERSECT-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROL-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROL-GROUP BY-ORDER BY-LIMIT, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the code of airport that has the most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which city is the one with the most departing flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which city is the one with the most departing flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c0",
        "label": "select t1.c0",
        "score": true,
        "real_pred": "select airports.City",
        "real_label": "select airports.City",
        "topk_preds": [
            "select airports.City",
            "select airports.City, flights.SourceAirport",
            "select airports.City, flights.DestAirport",
            "select airports.City, airports.AirportName",
            "select airports.City, flights.SourceAirport",
            "select airports.City (flights.SourceAirport)",
            "select airports.City, airports.Country",
            "select airports.City as flights.SourceAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which city is the one with the most departing flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show which city has the largest number of departures., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show which city has the largest number of departures., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c0",
        "label": "select t1.c0",
        "score": true,
        "real_pred": "select airports.City",
        "real_label": "select airports.City",
        "topk_preds": [
            "select airports.City",
            "select airports.City, flights.DestAirport",
            "select airports.City, airports.AirportName",
            "select airports.City, flights.SourceAirport",
            "select airports.City, flights.DestAirport",
            "select airports.City, airports.AirportName",
            "select airports.City (airports.AirportName)",
            "select airports.City, airports.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show which city has the largest number of departures., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which city has the largest number of outgoing flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which city has the largest number of outgoing flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c0",
        "label": "select t1.c0",
        "score": true,
        "real_pred": "select airports.City",
        "real_label": "select airports.City",
        "topk_preds": [
            "select airports.City",
            "select airports.City, flights.SourceAirport",
            "select airports.City, airports.AirportName",
            "select airports.City, flights.SourceAirport",
            "select airports.City, flights.DestAirport",
            "select airports.City (flights.SourceAirport)",
            "select airports.City, airports.Country",
            "select airports.City, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which city has the largest number of outgoing flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What city has the largest number of arriving flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What city has the largest number of arriving flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c0",
        "label": "select t1.c0",
        "score": true,
        "real_pred": "select airports.City",
        "real_label": "select airports.City",
        "topk_preds": [
            "select airports.City",
            "select airports.City, flights.SourceAirport",
            "select airports.City, airports.AirportName",
            "select airports.City, flights.SourceAirport",
            "select airports.City, flights.DestAirport",
            "select airports.City, airports.AirportName",
            "select airports.City (flights.SourceAirport)",
            "select airports.City, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What city has the largest number of arriving flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find which city has the greatest number of arriving flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find which city has the greatest number of arriving flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c0",
        "label": "select t1.c0",
        "score": true,
        "real_pred": "select airports.City",
        "real_label": "select airports.City",
        "topk_preds": [
            "select airports.City",
            "select airports.City, flights.SourceAirport",
            "select airports.City, airports.AirportName",
            "select airports.City, flights.SourceAirport",
            "select airports.City, flights.DestAirport",
            "select airports.City, airports.AirportName",
            "select airports.City (flights.SourceAirport)",
            "select airports.City (airports.AirportName)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find which city has the greatest number of arriving flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest number of incoming flights in a city?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest number of incoming flights in a city?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c0",
        "label": "select t1.c0",
        "score": true,
        "real_pred": "select airports.City",
        "real_label": "select airports.City",
        "topk_preds": [
            "select airports.City",
            "select airports.City, max(flights.FlightNo)",
            "select airports.City, count(*)",
            "select airports.City, flights.SourceAirport",
            "select airports.City, count(flights.FlightNo)",
            "select airports.City, count(incoming)",
            "select airports.City, max(flights.FlightNo)",
            "select airports.City, max(incoming flights.FlightNo)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest number of incoming flights in a city?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Where in which city do we find most arriving flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-C0-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Where in which city do we find most arriving flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c0",
        "label": "select t1.c0",
        "score": true,
        "real_pred": "select airports.City",
        "real_label": "select airports.City",
        "topk_preds": [
            "select airports.City",
            "select airports.City, flights.SourceAirport",
            "select airports.City, airports.AirportName",
            "select airports.City, airports.AirportCode",
            "select airports.City, flights.SourceAirport",
            "select airports.City, airports.Country",
            "select airports.City, flights.DestAirport",
            "select airports.City, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Where in which city do we find most arriving flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the airlines with 10 or more scheduled flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the airlines with 10 or more scheduled flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Country",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, flights.FlightNo",
            "select flights.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the airlines with 10 or more scheduled flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all airlines that have at least 10 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all airlines that have at least 10 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, t2",
            "select airlines.Airline, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all airlines that have at least 10 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the airlines that have 10 or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the airlines that have 10 or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, flights.SourceAirport",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the airlines that have 10 or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all airlines that have at least 10 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all airlines that have at least 10 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, flights.DestAirport",
            "select airlines.Airline, t2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all airlines that have at least 10 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all the airlines with a total count of at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all the airlines with a total count of at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.FlightNo",
            "select flights.Airline",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, sum(flights.FlightNo)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all the airlines with a total count of at least ten flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all the airlines that have 10 or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all the airlines that have 10 or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.SourceAirport",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all the airlines that have 10 or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all airlines that have 10 or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROMgROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all airlines that have 10 or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.FlightNo",
            "select flights.Airline",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, flights.SourceAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all airlines that have 10 or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all airlines that have ten or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all airlines that have ten or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.FlightNo",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, flights.SourceAirport",
            "select flights.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all airlines that have ten or more flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of United Airlines flights that leave from AHD airport?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of United Airlines flights that leave from AHD airport?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select flights.Airline count(*)",
            "select flights.SourceAirport, count(*)",
            "select flights.DestAirport, count(*)",
            "select flights.SourceAirport count(*)",
            "select sum(flights.FlightNo)",
            "select count(*), flights.SourceAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of United Airlines flights that leave from AHD airport?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the total count of United Airlines flights leaving from AHD Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the total count of United Airlines flights leaving from AHD Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(*), flights.SourceAirport, flights.DestAirport",
            "select count(*), airlines.Airline, airports.AirportCode",
            "select count(*), flights.SourceAirport",
            "select count(*), airlines.Airline, airports.AirportCode",
            "select flights.Airline count(*)",
            "select t2.c count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the total count of United Airlines flights leaving from AHD Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the airport code that currently has fewest flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT - SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the airport code that currently has fewest flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode (airports.AirportName)",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode, flights.SourceAirport",
            "select airports.AirportCode, airports.AirportNameavg(flights.SourceAirport)",
            "select airports.AirportCode, airports.AirportName, min(flights.SourceAirport)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the airport code that currently has fewest flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the code of airport that has the least number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the code of airport that has the least number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode (airports.AirportName)",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode, airports.AirportName, airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the code of airport that has the least number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the code for the airport that currently has the fewest flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the code for the airport that currently has the fewest flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode (airports.AirportName)",
            "select airports.AirportCode, airports.AirportName, airports.AirportName",
            "select airports.AirportCode IATA, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the code for the airport that currently has the fewest flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the code for the airport that currently has the lowest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT - SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the code for the airport that currently has the lowest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode (airports.AirportName)",
            "select airports.AirportCode, airports.AirportName, airports.AirportName",
            "select airports.AirportName",
            "select airports.AirportCode IATA, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the code for the airport that currently has the lowest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the code for the airport with the highest number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the code for the airport with the highest number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode (airports.AirportName)",
            "select airports.AirportCode IATA, airports.AirportName",
            "select airports.AirportCode-, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the code for the airport with the highest number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the code for the airport with the largest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the code for the airport with the largest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode (airports.AirportName)",
            "select airports.AirportCode IATA, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.AirportName",
            "select airports.AirportCode or airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the code for the airport with the largest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the code of the airport with the least number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the code of the airport with the least number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode IATA-CONTROL-GROUP BY-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROLLED-GROUP BY-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROL-FROM-GROUP BY-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROL-GROUP BY-ORDER BY-LIMIT-INTERSECT-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROLLED-GROUP BY-ORDER BY-LIMIT-INTERSECT-ORDER BY-LIMIT",
            "select airports.AirportCode IATA-CONTROL-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the code of the airport with the least number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the code of the airport that currently has the fewest flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the code of the airport that currently has the fewest flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode (airports.AirportName)",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.AirportCode",
            "select airports.AirportCode, airports.AirportName, airports.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the code of the airport that currently has the fewest flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the code for the airport with the lowest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the code for the airport with the lowest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select airports.AirportCode",
        "real_label": "select airports.AirportCode",
        "topk_preds": [
            "select airports.AirportCode",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportCode (airports.AirportName)",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportCode IATA, airports.AirportName",
            "select airports.AirportCode, airports.AirportName, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the code for the airport with the lowest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the total count of United Airlines flights to Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the total count of United Airlines flights to Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select flights.Airline, count(*)",
            "select count(*), airlines.Airline, airports.AirportName",
            "select count(*), airlines.Airline, airports.City",
            "select flights.Airline, count(*), airports.City",
            "select flights.Airline, count(*), airlines.Airline",
            "select count(*), airlines.Airline, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the total count of United Airlines flights to Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "airlines airports flights",
        "real_label": "airlines airports flights",
        "topk_preds": [
            "airlines airports flights",
            "airlines airports airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the total count of United Airlines flights that have arrived in Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the total count of United Airlines flights that have arrived in Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select flights.Airline, count(*)",
            "select flights.FlightNo, count(*)",
            "select count(*), airports.City",
            "select flights.DestAirport, count(*)",
            "select count(*), flights.Airline",
            "select flights.SourceAirport, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the total count of United Airlines flights that have arrived in Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "airlines airports flights",
        "real_label": "airlines airports flights",
        "topk_preds": [
            "airlines airports flights",
            "airlines airports airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Where can I find the list of air lines having less than 200 flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROMGROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Where can I find the list of air lines having less than 200 flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.DestAirport",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Where can I find the list of air lines having less than 200 flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the airlines that have fewer than 200 flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the airlines that have fewer than 200 flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, airlines.Country",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the airlines that have fewer than 200 flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all the airlines with less than 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all the airlines with less than 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, flights.DestAirport",
            "select airlines.Airline, t2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all the airlines with less than 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the total count of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the total count of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), flights.SourceAirport",
            "select count(*), flights.SourceAirport, flights.DestAirport",
            "select count(*), flights.Airline",
            "select count(*), flights.DestAirport",
            "select t2.c count(*)",
            "select count(*), flights.Airline, flights.FlightNo",
            "select count(*), flights.FlightNo"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the total count of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "flights",
        "real_label": "flights",
        "topk_preds": [
            "flights",
            "airports flights",
            "airlines flights",
            "airlines airports flights",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the current flight count?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY -LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the current flight count?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), flights.Airline",
            "select flights.Airline, count(*)",
            "select count(*), flights.FlightNo",
            "select t2.c count(*)",
            "select count(*), flights.DestAirport",
            "select count(*), flights.SourceAirport",
            "select flights.Airline, flights.FlightNo"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the current flight count?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "flights",
        "real_label": "flights",
        "topk_preds": [
            "flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all United Airlines flights that arrive in ASY Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all United Airlines flights that arrive in ASY Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c0",
        "label": "select count(*)",
        "score": false,
        "real_pred": "select flights.Airline",
        "real_label": "select count(*)",
        "topk_preds": [
            "select flights.Airline",
            "select flights.FlightNo",
            "select flights.Airline, flights.FlightNo",
            "select flights.FlightNo, airlines.Airline",
            "select airlines.Airline",
            "select airlines.Airline, flights.FlightNo",
            "select flights.Airline, airports.AirportCode",
            "select flights.Airline, airlines.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all United Airlines flights that arrive in ASY Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the count of United Airlines flights that arrive in ASY Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE PER-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the count of United Airlines flights that arrive in ASY Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(*), airlines.Airline, airports.AirportCode",
            "select flights.Airline, count(*)",
            "select count(*), airlines.Airline, airports.AirportCode",
            "select count(*), airlines.Airline (flights.FlightNo)",
            "select count(*), airports.AirportCode",
            "select count(*), airlines.Airline, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the count of United Airlines flights that arrive in ASY Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (ASY), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (ASY), c3: destairport (ASY)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List which airlines have under 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List which airlines have under 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, t2",
            "select airlines.Airline (flights.Airline)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List which airlines have under 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the airlines with fewer than 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the airlines with fewer than 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, flights.DestAirport",
            "select airlines.Airline, t2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the airlines with fewer than 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me which airlines have fewer than 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me which airlines have fewer than 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, flights.DestAirport",
            "select airlines.Airline (flights.Airline)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me which airlines have fewer than 200 flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the total count of flights arriving in Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the total count of flights arriving in Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airports.City",
            "select count(*), airports.City, flights.SourceAirport",
            "select flights.DestAirport, count(*)",
            "select count(*), airports.City, flights.FlightNo",
            "select count(*), airports.City, airports.AirportName",
            "select flights.FlightNo, count(*)",
            "select count(*), airports.City, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the total count of flights arriving in Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the airline that has the highest number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the airline that has the highest number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, flights.DestAirport",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline (flights.Airline)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the airline that has the highest number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest number of flights by an airline?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest number of flights by an airline?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, count(*)",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select airlines.Airline, count(*)",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline, count(*)",
            "select airlines.Airline",
            "select airlines.Airline, max(flights.FlightNo)",
            "select airlines.Airline, count(*), flights.Airline",
            "select airlines.Airline, count(*), airlines.Country",
            "select airlines.Airline, count(*), airlines.Abbreviation",
            "select airlines.Airline, max(flights.Airline)",
            "select flights.Airline, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest number of flights by an airline?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "airlines airports flights",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the airline with most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the airline with most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline (flights.Airline)",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the airline with most flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the airline with the most flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the airline with the most flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline (flights.Airline)",
            "select airlines.Airline, flights.DestAirport",
            "select airlines.Airline, t2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the airline with the most flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the airline with the greatest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the airline with the greatest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, flights.SourceAirport",
            "select flights.FlightNo, airlines.Airline",
            "select airlines.Airline (flights.Airline)",
            "select airlines.Airline, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the airline with the greatest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What city has the highest frequency of destination airports?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What city has the highest frequency of destination airports?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c0",
        "label": "select t1.c0",
        "score": true,
        "real_pred": "select airports.City",
        "real_label": "select airports.City",
        "topk_preds": [
            "select airports.City",
            "select airports.City, airports.AirportCode",
            "select airports.City, airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.City, airports.AirportCode-, airports.AirportName",
            "select airports.City, airports.AirportCode - airports.AirportName",
            "select airports.City, airports.AirportCodeavg(airports.AirportName)",
            "select airports.City, airports.AirportName, airports.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What city has the highest frequency of destination airports?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1 t2",
        "score": false,
        "real_pred": "airports",
        "real_label": "airports flights",
        "topk_preds": [
            "airports",
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the airline that has the most number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the airline that has the most number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline (flights.Airline)",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the airline that has the most number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airlines has the highest number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airlines has the highest number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.DestAirport",
            "select airlines.Airline (flights.Airline)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airlines has the highest number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the abbreviation and country of the airline with the fewest flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the abbreviation and country of the airline with the fewest flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select airlines.Abbreviation, airlines.Country",
        "real_label": "select airlines.Abbreviation, airlines.Country",
        "topk_preds": [
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select airlines.uid, airlines.Abbreviation, airlines.Country",
            "select airlines.Airline, airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Country, airlines.Airline",
            "select airlines.Abbreviation, airlines.Country, airlines.uid",
            "select airlines.Abbreviation-, airlines.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the abbreviation and country of the airline with the fewest flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the abbreviation and country of the airline which operates with fewer flights than all others., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the abbreviation and country of the airline which operates with fewer flights than all others., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select airlines.Abbreviation, airlines.Country",
        "real_label": "select airlines.Abbreviation, airlines.Country",
        "topk_preds": [
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select airlines.uid, airlines.Abbreviation, airlines.Country",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Country, airlines.Airline",
            "select airlines.Abbreviation), airlines.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the abbreviation and country of the airline which operates with fewer flights than all others., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the abbreviation and country of the airline that has the least number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the abbreviation and country of the airline that has the least number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select airlines.Abbreviation, airlines.Country",
        "real_label": "select airlines.Abbreviation, airlines.Country",
        "topk_preds": [
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select airlines.uid, airlines.Abbreviation, airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Country, airlines.Airline",
            "select airlines.Abbreviation, airlines.Country, airlines.uid"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the abbreviation and country of the airline that has the least number of flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "airlines airports flights",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the country name and abbreviation of the airline that has the lowest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the country name and abbreviation of the airline that has the lowest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c3, t0.c2",
        "label": "select t0.c2, t0.c3",
        "score": false,
        "real_pred": "select airlines.Country, airlines.Abbreviation",
        "real_label": "select airlines.Abbreviation, airlines.Country",
        "topk_preds": [
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.Country, airlines.Abbreviation, airlines.Airline",
            "select flights.DestAirport, airlines.Abbreviation",
            "select airlines.Country.c3, airlines.Abbreviation",
            "select airlines.Country, airlines.Abbreviation,",
            "select t.c3, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the country name and abbreviation of the airline that has the lowest number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the abbreviation and country of the airline with the smallest count of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the abbreviation and country of the airline with the smallest count of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select airlines.Abbreviation, airlines.Country",
        "real_label": "select airlines.Abbreviation, airlines.Country",
        "topk_preds": [
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select flights.Airline, airlines.Abbreviation, airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Abbreviation, airlines.Country, airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Abbreviation-, airlines.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the abbreviation and country of the airline with the smallest count of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "airlines airports flights",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the flight count for the airline called Jetblue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the flight count for the airline called Jetblue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select flights.Airline, count(*)",
            "select count(*), airlines.Airline, flights.SourceAirport",
            "select count(*), airlines.Airline, flights.Airline",
            "select count(*), airlines.Airline, airlines.Abbreviation",
            "select count(*), airlines.Airline, airlines.Abbreviation",
            "select count(*), airlines.Airline, flights.SourceAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the flight count for the airline called Jetblue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "airlines airports flights",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of Jetblue Airways flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of Jetblue Airways flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select flights.Airline, count(*)",
            "select count(*), airlines.Airline, flights.SourceAirport",
            "select count(*), airlines.Airline, flights.FlightNo",
            "select count(*), airlines.Airline, flights.Airline",
            "select sum(flights.FlightNo)",
            "select count(*), airlines.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of Jetblue Airways flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the amount of flights from JetBlue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE (GROUP BY",
            "SELECT-FROM-WHERE PERCENT(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the amount of flights from JetBlue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(*), airlines.Airline, flights.SourceAirport",
            "select flights.Airline, count(*)",
            "select count(*), airlines.Airline, flights.Airline",
            "select count(*), airlines.Airline",
            "select count(*), airlines.Airline, flights.FlightNo",
            "select count(*), airlines.Airline, flights.SourceAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the amount of flights from JetBlue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which cities have more than one employee who are younger than 30 years old?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERES-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHEREG-GROUP BY-HAVING",
            "SELECT-FROM-WHERECOMPLIMIT-GROUP BY-HAVING",
            "SELECT-FROM-WHERECOMPACT-GROUP BY-HAVING",
            "SELECT-FROM-WHERECOUPHIES-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which cities have more than one employee who are younger than 30 years old?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select employee.City",
        "real_label": "select employee.City",
        "topk_preds": [
            "select employee.City",
            "select employee.City, count(*)",
            "select employee.City Is-GROUP BY-HAVING",
            "select employee.City for employee.Age",
            "select employee.City, count(*), employee.Age",
            "select count(*), employee.City",
            "select employee.City simultaneously",
            "select employee.City, count(*), employee.Employee_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which cities have more than one employee who are younger than 30 years old?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all the cities with more than one employee that are younger than 30., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERES-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSTALL-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERECOUPHIES-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all the cities with more than one employee that are younger than 30., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select employee.City",
        "real_label": "select employee.City",
        "topk_preds": [
            "select employee.City",
            "select employee.City the SELECT-FROM-WHERE-GROUP BY-HAVING",
            "select employee.City, count(*)",
            "select employee.City the SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "select employee.City the SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "select employee.City the SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "select employee.City the SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "select employee.City Suggested by employee.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all the cities with more than one employee that are younger than 30., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all districts where there is a shop with fewer than 3000 products or one with over 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE or-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-2-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all districts where there is a shop with fewer than 3000 products or one with over 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select shop.District",
        "real_label": "select shop.District",
        "topk_preds": [
            "select shop.District",
            "select distinct shop.District",
            "select distinct shop.District, shop.Number_products",
            "select shop.District, shop.Number_products",
            "select distinct shop.District (or shop.Number_products)",
            "select distinct shop.District, shop.Location",
            "select shop.District, shop.Location",
            "select distinct shop.District, shop.Manager_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all districts where there is a shop with fewer than 3000 products or one with over 10,000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me where there are stores that sell 3000 products or less, and 10000 products or greater., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me where there are stores that sell 3000 products or less, and 10000 products or greater., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c2",
        "label": "select t1.c3",
        "score": false,
        "real_pred": "select shop.Location",
        "real_label": "select shop.District",
        "topk_preds": [
            "select shop.Location",
            "select shop.Location, shop.District",
            "select shop.Location for both shop.Name, shop.Location",
            "select shop.Location for both shop.District, shop.Number_products",
            "select shop.Location, shop.District, max(shop.Number_products)",
            "select shop.Location for both shop.Name, shop.District",
            "select shop.Location, shop.District, shop.Number_products",
            "select shop.Location, shop.District, min(shop.Number_products)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me where there are stores that sell 3000 products or less, and 10000 products or greater., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the sum bonus provided for each evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM FOR-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-3-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the sum bonus provided for each evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t3.c0, sum(t3.c2)",
        "label": "select sum(t3.c2)",
        "score": false,
        "real_pred": "select evaluation.Employee_ID, sum(evaluation.Bonus)",
        "real_label": "select sum(evaluation.Bonus)",
        "topk_preds": [
            "select evaluation.Employee_ID, sum(evaluation.Bonus)",
            "select evaluation.Year_awarded, sum(evaluation.Bonus)",
            "select sum(evaluation.Bonus), evaluation.Employee_ID",
            "select sum(evaluation.Bonus), evaluation.Year_awarded",
            "select evaluation.Bonus, evaluation.Year_awarded",
            "select evaluation.Employee_ID1, sum(evaluation.Bonus)",
            "select t3.c3, sum(evaluation.Bonus)",
            "select evaluation.Employee_ID0, sum(evaluation.Bonus)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the sum bonus provided for each evaluation?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "evaluation",
        "real_label": "evaluation",
        "topk_preds": [
            "evaluation",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the shop that is currently hiring the most number of employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the shop that is currently hiring the most number of employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, hiring.Is_full_time"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the shop that is currently hiring the most number of employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the shop that is hiring the most employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the shop that is hiring the most employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, hiring.Is_full_time",
            "select shop.Name, shop.Manager_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the shop that is hiring the most employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the shop that is currently hiring the most number of people?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEO-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GIG-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the shop that is currently hiring the most number of people?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Location",
            "select shop.Name, hiring.Is_full_time"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the shop that is currently hiring the most number of people?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the store that is hiring the most employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the store that is hiring the most employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, shop.Location",
            "select shop.Name, hiring.Is_full_time",
            "select shop.Name, shop.District",
            "select shop.Name (shop.Location)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the store that is hiring the most employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the count of the employees per city., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY (t0.c3)",
            "SELECT-FROM per-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the count of the employees per city., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c3, count(*)",
        "label": "select count(*), t0.c3",
        "score": false,
        "real_pred": "select employee.City, count(*)",
        "real_label": "select count(*), employee.City",
        "topk_preds": [
            "select employee.City, count(*)",
            "select count(*), employee.City",
            "select employee.City.c3, count(*)",
            "select employee.City, count(*), employee.Employee_ID",
            "select counts(*), employee.City",
            "select employee.City, count(*)",
            "select employee.Name, count(*)",
            "select the employee.City, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the count of the employees per city., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of shops in each location?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM in-GROUP BY",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM-1-GROUP BY",
            "SELECT-FROM-3-GROUP BY",
            "SELECT-FROM-GROUP BY."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of shops in each location?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c2, count(*)",
        "label": "select count(*), t1.c2",
        "score": false,
        "real_pred": "select shop.Location, count(*)",
        "real_label": "select count(*), shop.Location",
        "topk_preds": [
            "select shop.Location, count(*)",
            "select count(*), shop.Location",
            "select shop.Location, count(*), shop.District",
            "select sum(shop.Location), shop.District",
            "select shop_shop.Location, count(*)",
            "select shop.Location.c3, count(*)",
            "select sum(shop.Location), shop.Location",
            "select shop.Location, sum(shop.Shop_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of shops in each location?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the total count of shops in each location., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM in-GROUP BY",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM-1-GROUP BY",
            "SELECT-FROM-3-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the total count of shops in each location., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c2, count(*)",
        "label": "select count(*), t1.c2",
        "score": false,
        "real_pred": "select shop.Location, count(*)",
        "real_label": "select count(*), shop.Location",
        "topk_preds": [
            "select shop.Location, count(*)",
            "select count(*), shop.Location",
            "select shop.Location, count(*), shop.District",
            "select sum(shop.Location), shop.Location",
            "select sum(shop.Location), shop.District",
            "select shop_shop.Location, count(*)",
            "select shop.Location.c3, count(*)",
            "select the shop.Location, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the total count of shops in each location., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the employee's name sorted by his/her age from the youngest to the oldest., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY (t0.c1)",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the employee's name sorted by his/her age from the youngest to the oldest., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, employee.Age",
            "select employee.Name (ordered by employee.Age)",
            "select employee.Name-ordered",
            "select employee.Name in employee.Age",
            "select employee.Name sort(employee.Age)",
            "select employee.Name-ORDER BY",
            "select employee.Name or employee.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the employee's name sorted by his/her age from the youngest to the oldest., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What shops sell more products than average? Give me the shop names., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What shops sell more products than average? Give me the shop names., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, shop.Number_products",
            "select shop.Name, t1.c6",
            "select shop.Name, t1.c7",
            "select shop.Name, shop.Shop_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What shops sell more products than average? Give me the shop names., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name any of the shops whose product numbers is larger than the average., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name any of the shops whose product numbers is larger than the average., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, shop.Number_products",
            "select shop.Name, shop.District",
            "select shop.Name, t1.c6",
            "select shop.Name, t1.c7",
            "select shop.Name ou shop.Location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name any of the shops whose product numbers is larger than the average., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which shops have a higher number of products than the average? List the names of the shops., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which shops have a higher number of products than the average? List the names of the shops., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Number_products",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, t1.c6",
            "select shop.Name - shop.Number_products",
            "select shop.Name, shop.Shop_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which shops have a higher number of products than the average? List the names of the shops., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of employees from each city?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM by-GROUP BY",
            "SELECT-FROM each-GROUP BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM in-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of employees from each city?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c3, count(*)",
        "label": "select count(*), t0.c3",
        "score": false,
        "real_pred": "select employee.City, count(*)",
        "real_label": "select count(*), employee.City",
        "topk_preds": [
            "select employee.City, count(*)",
            "select count(*), employee.City",
            "select sum(employee.City), employee.City",
            "select employee.City, count(*), employee.Employee_ID",
            "select employee.City, count(*)",
            "select employee.City.c3, count(*)",
            "select employee.City, sum(t0.c4)",
            "select employee.City, count(*), employee.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of employees from each city?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the shop with the largest number of employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the shop with the largest number of employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, hiring.Is_full_time",
            "select shop.Name, shop.Manager_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the shop with the largest number of employees?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which shop has the largest employee count? Give me the shop name., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which shop has the largest employee count? Give me the shop name., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, hiring.Employee_ID",
            "select shop.Name, hiring.Shop_ID",
            "select shop.Name, hiring.Start_from",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, hiring.Is_full_time",
            "select shop.Name (shop.Location)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which shop has the largest employee count? Give me the shop name., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "shop hiring",
        "real_label": "shop hiring",
        "topk_preds": [
            "shop hiring",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which employee was given the largest bonus? Give me his/her name., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which employee was given the largest bonus? Give me his/her name., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, employee.Employee_ID",
            "select employee.Name, employee.Age",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, employee.City",
            "select evaluation.Employee_ID, employee.Name",
            "select employee.Employee_ID, employee.Name",
            "select employee.Name (employee.Employee_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which employee was given the largest bonus? Give me his/her name., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who got the largest bonus, give me their name., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who got the largest bonus, give me their name., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, employee.Employee_ID",
            "select employee.Name, employee.Age",
            "select employee.Name, employee.City",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, evaluation.Bonus",
            "select employee.Name, employee.Name",
            "select employee.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who got the largest bonus, give me their name., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "employee shop evaluation",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the stores whose number of products is larger than the average., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the stores whose number of products is larger than the average., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Shop_ID",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Number_products",
            "select shop.Shop_ID, shop.Name",
            "select shop.Name, shop.Name",
            "select shop.Name, shop.Manager_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the stores whose number of products is larger than the average., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of stores whose number of products is larger than the average., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of stores whose number of products is larger than the average., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Number_products",
            "select shop.Name (or shop.Manager_name)",
            "select shop.Name - shop.Manager_name",
            "select shop.Name, t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of stores whose number of products is larger than the average., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the store names whose total products is greater than the average products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROMGROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the store names whose total products is greater than the average products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Number_products",
            "select shop.Name, t1.c6",
            "select shop.Name, t1.c7",
            "select shop.Name (shop.Number_products)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the store names whose total products is greater than the average products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of stores which sell an above-average number of products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of stores which sell an above-average number of products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Number_products",
            "select shop.Name - shop.Manager_name",
            "select shop.Name, t1.c6",
            "select shop.Name (or shop.Manager_name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of stores which sell an above-average number of products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the smallest and largest number of products across all shops?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM, UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the smallest and largest number of products across all shops?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select min(t1.c4), max(t1.c4)",
        "label": "select min(t1.c4), max(t1.c4)",
        "score": true,
        "real_pred": "select min(shop.Number_products), max(shop.Number_products)",
        "real_label": "select min(shop.Number_products), max(shop.Number_products)",
        "topk_preds": [
            "select min(shop.Number_products), max(shop.Number_products)",
            "select max(shop.Number_products), min(shop.Number_products)",
            "select shop.Number_products, min(shop.Number_products), max(shop.Number_products)",
            "select min(shop.Location), max(shop.Number_products)",
            "select min(shop.District), max(shop.Number_products)",
            "select min(shop.Number_products), max(shop.Number_products), shop.Shop_ID",
            "select shop.Number_products, max(shop.Number_products)",
            "select min(shop.Manager_name), max(shop.Number_products)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the smallest and largest number of products across all shops?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all cities where there are two or more employees under the age of thirty., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERES-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHEREGROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all cities where there are two or more employees under the age of thirty., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select employee.City",
        "real_label": "select employee.City",
        "topk_preds": [
            "select employee.City",
            "select employee.City, count(*)",
            "select employee.City as a possible employee.City",
            "select employee.City as the employee.City",
            "select employee.City as employee.Age",
            "select employee.City as employee.City",
            "select employee.City (or employee.Age)",
            "select employee.City as a possible match-grouping.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all cities where there are two or more employees under the age of thirty., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the cities that have two or more employees under the age of 30., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERES-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHEREGROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the cities that have two or more employees under the age of 30., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c3",
        "label": "select t0.c3",
        "score": true,
        "real_pred": "select employee.City",
        "real_label": "select employee.City",
        "topk_preds": [
            "select employee.City",
            "select employee.City, count(*)",
            "select employee.City for employee.Age",
            "select employee.City, employee.Age",
            "select t0, employee.City",
            "select employee.City (employee.Age)",
            "select employee.City delhi",
            "select employee.City for employee.City"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the cities that have two or more employees under the age of 30., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "employee",
        "real_label": "employee",
        "topk_preds": [
            "employee",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the manager name and district of the shop that sells the most products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the manager name and district of the shop that sells the most products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c3",
        "label": "select t1.c5, t1.c3",
        "score": true,
        "real_pred": "select shop.Manager_name, shop.District",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name, shop.District",
            "select shop.Name, shop.District",
            "select shop.Manager_name, shop.District, shop.Location",
            "select shop.Manager_name, shop.Location",
            "select shop.Manager_name, shop.District,",
            "select shop.Location, shop.Manager_name",
            "select shop.Manager_name.c5, shop.District",
            "select shop.Manager_name, shop.District, max(shop.Number_products)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the manager name and district of the shop that sells the most products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the manager's name and district for the shop with the highest sales volume., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city (Sale)). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the manager's name and district for the shop with the highest sales volume., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city (Sale)). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c3",
        "label": "select t1.c5, t1.c3",
        "score": true,
        "real_pred": "select shop.Manager_name, shop.District",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name, shop.District",
            "select shop.Name, shop.District",
            "select shop.Location, shop.Manager_name",
            "select shop.Manager_name, shop.Location",
            "select shop.Manager_name, shop.District,",
            "select shop.Manager_name, shop.District.",
            "select shop.District, shop.Manager_name",
            "select shop.Number_products, shop.District"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the manager's name and district for the shop with the highest sales volume., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city (Sale)). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the manager's name and the district of the store that sells the most items?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the manager's name and the district of the store that sells the most items?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c3",
        "label": "select t1.c5, t1.c3",
        "score": true,
        "real_pred": "select shop.Manager_name, shop.District",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name, shop.District",
            "select shop.Name, shop.District",
            "select shop.Location, shop.Manager_name",
            "select shop.Manager_name, shop.Location",
            "select shop.District, shop.Manager_name",
            "select shop.Manager_name, shop.District,",
            "select shop.Number_products, shop.District",
            "select shop.Manager_name, shop.District."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the manager's name and the district of the store that sells the most items?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of employee that received the largest one-time bonus?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of employee that received the largest one-time bonus?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, employee.Employee_ID",
            "select employee.Name, employee.Age",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, employee.City",
            "select employee.Name, evaluation.Bonus",
            "select employee.Name (employee.Employee_ID)",
            "select employee.Name, employee.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of employee that received the largest one-time bonus?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "",
            "",
            "employee shop evaluation",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which employee got the biggest one time bonus?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which employee got the biggest one time bonus?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select evaluation.Employee_ID",
            "select evaluation.Employee_ID, employee.Name",
            "select evaluation.Year_awarded",
            "select employee.Name, evaluation.Employee_ID",
            "select evaluation.Employee_ID, evaluation.Year_awarded",
            "select employee.Employee_ID, employee.Name",
            "select employee.Name, employee.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which employee got the biggest one time bonus?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "evaluation",
            "hiring evaluation",
            "shop evaluation",
            "employee shop evaluation",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the name of the individual that received a one-time bonus of the greatest amount?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT",
            "SELECT-FROM-OF-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the name of the individual that received a one-time bonus of the greatest amount?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select employee.Name",
        "real_label": "select employee.Name",
        "topk_preds": [
            "select employee.Name",
            "select employee.Name, employee.Employee_ID",
            "select employee.Name, employee.Age",
            "select employee.Name, employee.City",
            "select employee.Name, evaluation.Employee_ID",
            "select employee.Name, evaluation.Bonus",
            "select employee.Name, employee.Name",
            "select employee.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the name of the individual that received a one-time bonus of the greatest amount?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "employee evaluation",
        "real_label": "employee evaluation",
        "topk_preds": [
            "employee evaluation",
            "employee hiring evaluation",
            "",
            "employee shop evaluation",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the lowest and the highest numbers of products sold in all stores., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the lowest and the highest numbers of products sold in all stores., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select min(t1.c4), max(t1.c4)",
        "label": "select min(t1.c4), max(t1.c4)",
        "score": true,
        "real_pred": "select min(shop.Number_products), max(shop.Number_products)",
        "real_label": "select min(shop.Number_products), max(shop.Number_products)",
        "topk_preds": [
            "select min(shop.Number_products), max(shop.Number_products)",
            "select max(shop.Number_products), min(shop.Number_products)",
            "select min(shop.District), max(shop.Number_products)",
            "select minimum(shop.Number_products), max(shop.Number_products)",
            "select min(shop.Location), max(shop.Number_products)",
            "select shop.Number_products, max(shop.Number_products)",
            "select min(shop.Manager_name), max(shop.Number_products)",
            "select min(t1.c6), max(shop.Number_products)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the lowest and the highest numbers of products sold in all stores., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the smallest and largest number of products of all stores., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the smallest and largest number of products of all stores., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select min(t1.c4), max(t1.c4)",
        "label": "select min(t1.c4), max(t1.c4)",
        "score": true,
        "real_pred": "select min(shop.Number_products), max(shop.Number_products)",
        "real_label": "select min(shop.Number_products), max(shop.Number_products)",
        "topk_preds": [
            "select min(shop.Number_products), max(shop.Number_products)",
            "select shop.Number_products, min(shop.Number_products), max(shop.Number_products)",
            "select max(shop.Number_products), min(shop.Number_products)",
            "select min(shop.District), max(shop.Number_products)",
            "select min(shop.Location), max(shop.Number_products)",
            "select shop.Number_products, min(shop.Number_products)",
            "select min(shop.Manager_name), max(shop.Number_products)",
            "select min(shop.Number_products), max(shop.Number_products), shop.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the smallest and largest number of products of all stores., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of stores?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM, sum(t1.c4)",
            "SELECT-FROM, count(*)",
            "SELECT-FROM, sum(t1.c6)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of stores?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(distinct t1.c2)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(distinct shop.Location)",
        "topk_preds": [
            "select count(*)",
            "select count(*), shop.Shop_ID",
            "select count(*), shop.Location",
            "select t1.c count(*)",
            "select count(*), shop.District",
            "select count(*), shop.Name",
            "select count(*), shop.Number_products",
            "select count(*), shop.Manager_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of stores?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "shop hiring",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the total count of distinct store locations., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM count(distinct t1.c2)",
            "SELECT-FROM the count(distinct t1.c2)",
            "SELECT-FROM (count(distinct t1.c2)",
            "SELECT-FROM total count(distinct t1.c2)",
            "SELECT-FROM count(*)",
            "SELECT-FROM (count(*)",
            "SELECT-FROM the count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the total count of distinct store locations., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select count(distinct t1.c2)",
        "label": "select count(distinct t1.c2)",
        "score": true,
        "real_pred": "select count(distinct shop.Location)",
        "real_label": "select count(distinct shop.Location)",
        "topk_preds": [
            "select count(distinct shop.Location)",
            "select count(*)",
            "select count(count(distinct shop.Location)",
            "select count((distinct shop.Location)",
            "select count(distinct t1.c6)",
            "select count(shop.Location)",
            "select count(distinct t1.c 2)",
            "select count( distinct shop.Location)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the total count of distinct store locations., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the districts that have stores with fewer than 3000 products, and those with over 10000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTRICT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE AND-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the districts that have stores with fewer than 3000 products, and those with over 10000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select shop.District",
        "real_label": "select shop.District",
        "topk_preds": [
            "select shop.District",
            "select shop.District, shop.Number_products",
            "select shop.District (shop.Number_products), shop.District",
            "select shop.District (*), shop.District",
            "select shop.District, shop.Location",
            "select shop.District (*), shop.Number_products",
            "select shop.District, shop.District",
            "select shop.District delimited by shop.Number_products"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the districts that have stores with fewer than 3000 products, and those with over 10000 products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What district has stores that have either product with less than 3000 or products greater than 10000?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE or-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-2-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What district has stores that have either product with less than 3000 or products greater than 10000?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select shop.District",
        "real_label": "select shop.District",
        "topk_preds": [
            "select shop.District",
            "select distinct shop.District",
            "select shop.District, shop.Number_products",
            "select shop.District (refers to shop.Number_products)",
            "select shop.District, shop.Location",
            "select shop.District (refers to shop.Location)",
            "select shop.District (or shop.Number_products)",
            "select distinct shop.District, shop.Number_products"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What district has stores that have either product with less than 3000 or products greater than 10000?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which districts have stores that have over 10,000 products and stores with less than 3,000 products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTRICT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-JUNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which districts have stores that have over 10,000 products and stores with less than 3,000 products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select shop.District",
        "real_label": "select shop.District",
        "topk_preds": [
            "select shop.District",
            "select shop.District, shop.Number_products",
            "select shop.District, shop.Location",
            "select shop.District, shop.District",
            "select shop.District, min(shop.Number_products)",
            "select shop.District, shop.Name",
            "select shop.District, t1.c6",
            "select shop.District, shop.Manager_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which districts have stores that have over 10,000 products and stores with less than 3,000 products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the manager name and district of the shop with the most products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the manager name and district of the shop with the most products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c3",
        "label": "select t1.c5, t1.c3",
        "score": true,
        "real_pred": "select shop.Manager_name, shop.District",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name, shop.District",
            "select shop.Name, shop.District",
            "select shop.Manager_name, shop.District, shop.Location",
            "select shop.Manager_name, shop.Location",
            "select shop.Manager_name.c5, shop.District",
            "select shop.Manager_name, shop.District,",
            "select shop.Location, shop.Manager_name",
            "select shop.Manager_name, shop.District, max(shop.Number_products)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the manager name and district of the shop with the most products., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the ID of the manager and district of the shop with the highest number of products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the ID of the manager and district of the shop with the highest number of products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c3",
        "label": "select t1.c5, t1.c3",
        "score": true,
        "real_pred": "select shop.Manager_name, shop.District",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name, shop.District",
            "select shop.Name, shop.District",
            "select shop.Location, shop.District",
            "select shop.District, shop.Manager_name",
            "select shop.Shop_ID, shop.District",
            "select shop.Manager_name, shop.Location",
            "select shop.Number_products, shop.District",
            "select t2.c5, shop.District"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the ID of the manager and district of the shop with the highest number of products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the manager's name and district of the shop that has the highest product number., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the manager's name and district of the shop that has the highest product number., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c3",
        "label": "select t1.c5, t1.c3",
        "score": true,
        "real_pred": "select shop.Manager_name, shop.District",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name, shop.District",
            "select shop.Name, shop.District",
            "select shop.Manager_name, shop.Location",
            "select shop.Location, shop.Manager_name",
            "select shop.District, shop.Manager_name",
            "select shop.Manager_name, shop.District,",
            "select shop.Number_products, shop.District",
            "select shop.Manager_name, shop.District."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the manager's name and district of the shop that has the highest product number., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total sum of bonuses received on evaluations?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM ADDIT-SELECT-FROM",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM the sum(t3.c2)",
            "SELECT-FROM, sum(t3.c2)",
            "SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total sum of bonuses received on evaluations?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select sum(t3.c2)",
        "label": "select sum(t3.c2)",
        "score": true,
        "real_pred": "select sum(evaluation.Bonus)",
        "real_label": "select sum(evaluation.Bonus)",
        "topk_preds": [
            "select sum(evaluation.Bonus)",
            "select sum(evaluation.Bonus), evaluation.Employee_ID",
            "select sum(evaluation.Bonus) delegated to evaluation.Employee_ID",
            "select sum(evaluation.Bonus), evaluation.Year_awarded",
            "select sum(evaluation.Bonus) denoted by evaluation.Employee_ID",
            "select sum(evaluation.Bonus)",
            "select sum(evaluation.Bonus),",
            "select sum(evaluation.Bonus) denoted evaluation.Employee_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total sum of bonuses received on evaluations?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "evaluation",
        "real_label": "evaluation",
        "topk_preds": [
            "evaluation",
            "",
            "shop evaluation",
            "",
            "",
            "",
            "",
            "employee evaluation"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the total bonus given in all evaluations., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (GROUP BY",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM, sum(t3.c2)",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the total bonus given in all evaluations., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select sum(t3.c2)",
        "label": "select sum(t3.c2)",
        "score": true,
        "real_pred": "select sum(evaluation.Bonus)",
        "real_label": "select sum(evaluation.Bonus)",
        "topk_preds": [
            "select sum(evaluation.Bonus)",
            "select sum(evaluation.Bonus),",
            "select sum(evaluation.Bonus)",
            "select Sum(evaluation.Bonus)",
            "select sum (evaluation.Bonus)",
            "select sum(evaluation.Bonus).",
            "select sum(t3.c 2)",
            "select sum(t3.c5)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the total bonus given in all evaluations., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "evaluation",
        "real_label": "evaluation",
        "topk_preds": [
            "evaluation",
            "shop evaluation",
            "employee evaluation",
            "",
            "hiring evaluation",
            "employee hiring evaluation",
            "employee hiring",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the totals on evaluation bonuses., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM, sum(t3.c2)",
            "SELECT-FROM the sum(t3.c2)",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM sum(t3.c2)",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the totals on evaluation bonuses., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select sum(t3.c2)",
        "label": "select sum(t3.c2)",
        "score": true,
        "real_pred": "select sum(evaluation.Bonus)",
        "real_label": "select sum(evaluation.Bonus)",
        "topk_preds": [
            "select sum(evaluation.Bonus)",
            "select sums(evaluation.Bonus)",
            "select sum(evaluation.Bonus),",
            "select evaluation.Bonus",
            "select sum(t3.c 2)",
            "select sum(evaluation.Bonus).",
            "select Sum(evaluation.Bonus)",
            "select total(evaluation.Bonus)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the totals on evaluation bonuses., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "evaluation",
        "real_label": "evaluation",
        "topk_preds": [
            "evaluation",
            "shop evaluation",
            "",
            "",
            "employee evaluation",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the smallest version and its template type code?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the smallest version and its template type code?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select min(t1.c1), t1.c2",
        "score": false,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select min(Templates.Version_Number), Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select min(Templates.Version_Number), Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select min(Templates.Template_ID), Templates.Template_Type_Code",
            "select min(Templates.Template_Type_Code), Templates.Template_Type_Code",
            "select max(Templates.Version_Number), Templates.Template_Type_Code",
            "select min(Templates.Version_Number)., Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the smallest version and its template type code?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the earliest version number and show it's template type code., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the earliest version number and show it's template type code., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select min(t1.c1), t1.c2",
        "score": false,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select min(Templates.Version_Number), Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Templates.Version_Number.c1, Templates.Template_Type_Code",
            "select t1.c 1, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code.",
            "select Templates.Version_Number), Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the earliest version number and show it's template type code., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of documents that use the PPT template type?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE (t2.c0)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of documents that use the PPT template type?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Templates.Template_Type_Code",
            "select Documents.Document_ID, count(*)",
            "select count(*), Templates.Template_ID",
            "select count(*), Templates.Template_Details",
            "select count(Documents.Document_ID)",
            "select count(*), Templates.Date_Effective_To",
            "select count(*), Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of documents that use the PPT template type?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the count of documents that use the PPT template type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE (t2.c0)",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the count of documents that use the PPT template type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Templates.Template_Type_Code",
            "select count(*), Templates.Template_ID",
            "select Documents.Document_ID, count(*)",
            "select count(Documents.Document_ID)",
            "select count(*), Documents.Template_ID",
            "select count(*), Templates.Template_Details",
            "select count(*), Templates.Date_Effective_To"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the count of documents that use the PPT template type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the count of documents that use PPT template type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE (t2.c0)",
            "SELECT-FROM-WHERE (t2.c0"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the count of documents that use PPT template type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Templates.Template_Type_Code",
            "select count(*), Templates.Template_ID",
            "select count(*), Documents.Template_ID",
            "select count(*), Templates.Template_Details",
            "select count(*), Templates.Version_Number",
            "select count(Documents.Document_ID)",
            "select count(*), Templates.Date_Effective_To"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the count of documents that use PPT template type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the total count of documents with the PPT template type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the total count of documents with the PPT template type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Templates.Template_Type_Code",
            "select Documents.Document_ID, count(*)",
            "select count(*), Documents.Template_ID",
            "select count(*), Templates.Template_ID",
            "select count(*), Templates.Template_Details",
            "select count(*), Templates.Version_Number",
            "select count(*), Templates.Date_Effective_To"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the total count of documents with the PPT template type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the id and name of the document that has the highest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C0-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C0, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the id and name of the document that has the highest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c2",
        "label": "select t3.c1, t2.c2",
        "score": false,
        "real_pred": "select Documents.Document_ID, Documents.Document_Name",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Name, Documents.Document_Description",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Name",
            "select t2, Documents.Document_ID, Documents.Document_Name",
            "select Templates.Template_ID, Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_ID",
            "select Documents.Document_ID, Documents.Document_Name, Paragraphs.Other_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the id and name of the document that has the highest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all document ids and the total count of paragraphs in each document. Order by id., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY",
        "label": "SELECT-FROM-GROUP BY-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY t3.c1, count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY.",
            "SELECT-FROM-GROUP BY-ORDER BY t3.c1, sum(t3.c2)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY t3.c1",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all document ids and the total count of paragraphs in each document. Order by id., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1, count(*)",
        "label": "select t3.c1, count(*)",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID, count(*)",
        "real_label": "select Paragraphs.Document_ID, count(*)",
        "topk_preds": [
            "select Paragraphs.Document_ID, count(*)",
            "select Documents.Document_ID, count(*)",
            "select Paragraphs.Document_ID, sum(Paragraphs.Paragraph_Text)",
            "select Paragraphs.Document_ID, count(*), Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, count(*)",
            "select Paragraphs.Paragraph_ID, count(*)",
            "select Paragraphs.Document_ID, count(*), Documents.Document_Name",
            "select Paragraphs.Document_ID, count(*), Paragraphs.Other_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all document ids and the total count of paragraphs in each document. Order by id., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            "Documents Paragraphs"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the total count of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the total count of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Templates.Template_Type_Code",
            "select count(*), Templates.Template_ID",
            "select count(*), Templates.Date_Effective_To",
            "select count(*), Templates.Template_Details",
            "select count(*), Templates.Version_Number",
            "select count(*), Templates.Date_Effective_From",
            "select count(*), t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the total count of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            "Templates Documents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: what is the total count of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, sum(t1.c0)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: what is the total count of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Templates.Template_Type_Code",
            "select count(*), Templates.Template_ID",
            "select count(*), Templates.Date_Effective_To",
            "select count(*), Templates.Version_Number",
            "select count(*), Templates.Template_Details",
            "select count(*), Templates.Date_Effective_From",
            "select t1.c count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: what is the total count of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            "Templates Documents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the code of the template type that is used in the most number of documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the code of the template type that is used in the most number of documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Templates.Template_Type_Code, Documents.Document_Description",
            "select Documents.Document_Name",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_ID",
            "select Templates.Template_Type_Code, Documents.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the code of the template type that is used in the most number of documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the code of the template type used most in the documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the code of the template type used most in the documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Documents.Document_Name",
            "select Templates.Version_Number",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code (or Documents.Template_ID)",
            "select Templates.Template_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the code of the template type used most in the documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            "Templates"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the code of the template type that appears the most in documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the code of the template type that appears the most in documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Templates.Template_Type_Code, Documents.Document_Description",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, Documents.Document_ID",
            "select Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the code of the template type that appears the most in documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "Templates",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the document with one to two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the document with one to two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c2",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Documents.Document_Name",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_Name ou Documents.Document_Description",
            "select Documents.Document_Name or Documents.Document_Description",
            "select Documents.Document_Name, Paragraphs.Document_ID",
            "select Documents.Document_Name (or Documents.Document_Description)",
            "select Documents.Document_Name (Documents.Document_Description)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the document with one to two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "Documents Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the document id that has a count between 1 and 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the document id that has a count between 1 and 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_ID)",
            "select Paragraphs.Document_ID, t3.c4",
            "select Paragraphs.Document_ID,",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_ID",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_Text)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the document id that has a count between 1 and 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the ids of the documents that has more or equal to 1 or 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING or-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-2-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING,-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the ids of the documents that has more or equal to 1 or 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Documents.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID",
            "select t4.c1",
            "select Templates.Template_ID",
            "select Paragraphs.Paragraph_ID",
            "select t4.c0",
            "select t5.c1",
            "select t5.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the ids of the documents that has more or equal to 1 or 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the ID of document with one or two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-2-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING or-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING,-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the ID of document with one or two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Paragraphs.Paragraph_ID",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Paragraphs.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the ID of document with one or two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the document id with one paragraph or two., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-OPTION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-DECIS-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUPGROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the document id with one paragraph or two., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID (or Paragraphs.Paragraph_Text)",
            "select Paragraphs.Document_ID - Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text.c2",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_Text)",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_ID)",
            "select Paragraphs.Document_ID (see Paragraphs.Paragraph_Text)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the document id with one paragraph or two., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "",
            "",
            "",
            "Templates Documents Paragraphs",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the document ids, names, and paragraph counts for each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GEOGRAPHS-GROUP BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM",
            "SELECT-FROM-VARIATION-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the document ids, names, and paragraph counts for each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c2, count(*)",
        "label": "select t3.c1, t2.c2, count(*)",
        "score": false,
        "real_pred": "select Documents.Document_ID, Documents.Document_Name, count(*)",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, Paragraphs.Document_ID, count(*)",
            "select Documents.Document_ID, Documents.Template_ID, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*), Documents.Document_Description",
            "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name.c2, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the document ids, names, and paragraph counts for each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the document ids, names and the total count of paragraphs in each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY (t2.c0, t2.c2, count(*)",
            "SELECT-FROM-GROUP BY (t2.c0, t2.c2), count(*)",
            "SELECT-FROM-GROUP BY (T2.c0, t2.c2, count(*)",
            "SELECT-FROM for t2.c0, t2.c2, count(*)",
            "SELECT-FROM-GROUP BY (T2.c0, t2.c2), count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (t2.c0, t2.c2, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the document ids, names and the total count of paragraphs in each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c2, count(*)",
        "label": "select t3.c1, t2.c2, count(*)",
        "score": false,
        "real_pred": "select Documents.Document_ID, Documents.Document_Name, count(*)",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name.c2, count(*)",
            "select Documents.Document_ID, Documents.Template_ID, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, sum(Paragraphs.Paragraph_Text)",
            "select Documents.Document_ID, Documents.Document_Name, count(*),",
            "select Documents.Document_ID, Documents.Document_Name, sum(Paragraphs.Paragraph_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the document ids, names and the total count of paragraphs in each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me an list of all the document ids, name and paragraph counts for each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-VARIATION-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me an list of all the document ids, name and paragraph counts for each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c2, count(*)",
        "label": "select t3.c1, t2.c2, count(*)",
        "score": false,
        "real_pred": "select Documents.Document_ID, Documents.Document_Name, count(*)",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Template_ID, count(*)",
            "select Documents.Document_ID, Documents.Document_Name.c2, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*),",
            "select Documents.Document_ID, Documents.Document_Name.c3, count(*)",
            "select Documents.Document_ID, Documents.Other_Details, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me an list of all the document ids, name and paragraph counts for each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the ids, names and paragraph counts for each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-VARIATION-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the ids, names and paragraph counts for each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c2, count(*)",
        "label": "select t3.c1, t2.c2, count(*)",
        "score": false,
        "real_pred": "select Documents.Document_ID, Documents.Document_Name, count(*)",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*), Documents.Document_Description",
            "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*),",
            "select Documents.Document_ID, Documents.Template_ID, count(*)",
            "select Documents.Document_ID, Documents.Document_Name.c2, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*), Paragraphs.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the ids, names and paragraph counts for each document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and ids of each document, as well as the total count of paragraphs per document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY, t3.c2, count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY, t3.c2, t3.c1",
            "SELECT-FROM-GROUP BY, t3.c2, t2.c0",
            "SELECT-FROM-GIGMENT-GROUP BY",
            "SELECT-FROM-GROUP BY, AND-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and ids of each document, as well as the total count of paragraphs per document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c2, t3.c1, count(*)",
        "label": "select t3.c1, t2.c2, count(*)",
        "score": false,
        "real_pred": "select Documents.Document_Name, Paragraphs.Document_ID, count(*)",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
        "topk_preds": [
            "select Documents.Document_Name, Paragraphs.Document_ID, count(*)",
            "select Documents.Document_Name, Documents.Document_ID, count(*)",
            "select Documents.Document_Name, Paragraphs.Document_ID, count(*),",
            "select Documents.Document_Name, Paragraphs.Document_ID, count(*)",
            "select Documents.Document_Name, Paragraphs.Document_ID, count(*), Documents.Document_ID",
            "select Documents.Document_Name, Paragraphs.Document_ID, count(*), Documents.Document_Description",
            "select Documents.Document_Name, Paragraphs.Paragraph_ID, count(*)",
            "select Documents.Document_Name, Documents.Template_ID, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and ids of each document, as well as the total count of paragraphs per document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the ids and names of each document, as well as the total count of paragraphs in each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY, COUNT(*)",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GROUP BY (GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GROUP BY, TOTAL(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the ids and names of each document, as well as the total count of paragraphs in each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1, t2.c2, count(*)",
        "label": "select t3.c1, t2.c2, count(*)",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
        "topk_preds": [
            "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*), Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Documents.Document_Name, count(*), Documents.Document_ID",
            "select t4.c1, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*),",
            "select Paragraphs.Document_ID, Documents.Document_Name and count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the ids and names of each document, as well as the total count of paragraphs in each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the ids and names of each document, along with the total count of paragraphs in each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY, t2.c0, t2.c2, count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY, t2.c0, t2.c2 - count(*)",
            "SELECT-FROM-GROUP BY, t2.c0, t2.c2 + count(*)",
            "SELECT-FROM-GROUP BY, t2.c0, t2.c2",
            "SELECT-FROM-GROUP BY, t2.c0, t2.c2, count(*)",
            "SELECT-FROM-GROUP BY, COUNT(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the ids and names of each document, along with the total count of paragraphs in each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c2, count(*)",
        "label": "select t3.c1, t2.c2, count(*)",
        "score": false,
        "real_pred": "select Documents.Document_ID, Documents.Document_Name, count(*)",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Paragraphs.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*), Paragraphs.Document_ID",
            "select Documents.Template_ID, Documents.Document_Name, count(*)",
            "select Documents.Document_ID, Documents.Document_Name, count(*),",
            "select Documents.Document_ID, Documents.Document_Name.c2, count(*)",
            "select t4.c1, Documents.Document_Name, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the ids and names of each document, along with the total count of paragraphs in each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me which template type code has the largest number of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me which template type code has the largest number of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Date_Effective_To",
            "select Templates.Template_Type_Code (http://www.Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me which template type code has the largest number of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the code of a type with most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the code of a type with most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code (symbol Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (ref. Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code (http://www.Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (symbol Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (ref. Templates.Template_Type_Code)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the code of a type with most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which template type has the most count of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which template type has the most count of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Ref_Template_Types.Template_Type_Description, Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_To",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Template_Type_Code, t1.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which template type has the most count of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which template type code has the most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which template type code has the most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Date_Effective_To",
            "select Templates.Template_Type_Code (symbol Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code (http://www.Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which template type code has the most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the template type codes with the highest number of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the template type codes with the highest number of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Date_Effective_To",
            "select Templates.Template_Type_Code (http://www.Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code, Templates.Version_Number, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Template_Details",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, max(Templates.Date_Effective_To)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the template type codes with the highest number of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: which template type code has the most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: which template type code has the most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Date_Effective_To",
            "select Templates.Template_Type_Code (symbol Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code (http://www.Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: which template type code has the most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the template id and type code of the largest number of documents using it., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the template id and type code of the largest number of documents using it., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1, t1.c2",
        "label": "select t2.c1, t1.c2",
        "score": true,
        "real_pred": "select Documents.Template_ID, Templates.Template_Type_Code",
        "real_label": "select Documents.Template_ID, Templates.Template_Type_Code",
        "topk_preds": [
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Documents.Template_ID, Templates.Template_Type_Code, Templates.Template_Details",
            "select Documents.Template_ID, Templates.Template_Type_Code, Documents.Document_Description",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Type_Code, Templates.Template_ID",
            "select Documents.Template_ID, Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the template id and type code of the largest number of documents using it., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "",
            "",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all template type codes and list the total count of templates for each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY, count(*)",
            "SELECT-FROM-GROUP BY (t1.c2)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GROUP BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all template type codes and list the total count of templates for each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2, count(*)",
        "label": "select t1.c2, count(*)",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code, count(*)",
        "real_label": "select Templates.Template_Type_Code, count(*)",
        "topk_preds": [
            "select Templates.Template_Type_Code, count(*)",
            "select Templates.Template_Type_Code, count(*), Templates.Date_Effective_From",
            "select Templates.Template_Type_Code.c2, count(*)",
            "select Templates.Template_Type_Code, count(**)",
            "select Templates.Template_Type_Code, count(*),",
            "select Templates.Template_Type_Code, count(*), http://www.Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, count(*), http://www.Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, count(*), Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all template type codes and list the total count of templates for each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the id and type code of the template that is used for the most documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C0, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the id and type code of the template that is used for the most documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c0, t1.c2",
        "label": "select t2.c1, t1.c2",
        "score": false,
        "real_pred": "select Templates.Template_ID, Templates.Template_Type_Code",
        "real_label": "select Documents.Template_ID, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Documents.Document_ID, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_ID, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Documents.Template_ID, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Documents.Template_ID, Templates.Template_Type_Code, Templates.Template_Details",
            "select t4.c0, Templates.Template_Type_Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the id and type code of the template that is used for the most documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "",
            "",
            "",
            "",
            "",
            "Ref_Template_Types Templates Documents",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the template id and type code for the template used for the largest number of documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the template id and type code for the template used for the largest number of documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1, t1.c2",
        "label": "select t2.c1, t1.c2",
        "score": true,
        "real_pred": "select Documents.Template_ID, Templates.Template_Type_Code",
        "real_label": "select Documents.Template_ID, Templates.Template_Type_Code",
        "topk_preds": [
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Documents.Template_ID, Templates.Template_Type_Code, Templates.Template_Details",
            "select Documents.Document_ID, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_ID, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Documents.Template_ID, Documents.Document_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the template id and type code for the template used for the largest number of documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "",
            "",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the template type code and id of the template used for the most documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C2, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the template type code and id of the template used for the most documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2, t1.c0",
        "label": "select t2.c1, t1.c2",
        "score": false,
        "real_pred": "select Templates.Template_Type_Code, Templates.Template_ID",
        "real_label": "select Documents.Template_ID, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code, Templates.Template_ID",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Documents.Document_Name, Documents.Template_ID",
            "select Templates.Template_Type_Code, t1.1.c0",
            "select Templates.Template_Details, Templates.Template_ID",
            "select Templates.Template_Type_Code, t01.c0",
            "select Templates.Template_Type_Code, Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the template type code and id of the template used for the most documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the id and type code of the template for the largest document counts., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the id and type code of the template for the largest document counts., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c0, t1.c2",
        "label": "select t2.c1, t1.c2",
        "score": false,
        "real_pred": "select Templates.Template_ID, Templates.Template_Type_Code",
        "real_label": "select Documents.Template_ID, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_ID, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Documents.Document_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_Type_Code, Templates.Template_Details",
            "select t4.c0, Templates.Template_Type_Code",
            "select Ref_Template_Types.Template_Type_Code, Templates.Template_Type_Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the id and type code of the template for the largest document counts., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "",
            "",
            "",
            "",
            "",
            "",
            "Ref_Template_Types Templates Documents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the id of the document with the lowest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the id of the document with the lowest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Documents.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Document_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the id of the document with the lowest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "Documents Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            "Templates Paragraphs"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the ID of the document with the smallest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT.",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the ID of the document with the smallest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Documents.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Documents.Document_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the ID of the document with the smallest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "Documents Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "",
            "Templates Documents Paragraphs",
            "",
            "Templates Paragraphs",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the ID of the document that has the least amount of paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the ID of the document that has the least amount of paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Documents.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Documents.Document_ID",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Description",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Documents.Document_ID, t2.c5",
            "select Documents.Document_ID, Documents.Template_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the ID of the document that has the least amount of paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "Documents Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out the id of the document with the minimum amount of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out the id of the document with the minimum amount of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Documents.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Documents.Document_ID",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Template_ID",
            "select Documents.Document_ID, t2.c5",
            "select Documents.Document_ID, Documents.Document_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out the id of the document with the minimum amount of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "Documents Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the document id with the fewest paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the document id with the fewest paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_ID)",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_Text)",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, t3.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the document id with the fewest paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "Ref_Template_Types Documents Paragraphs",
            "",
            "Ref_Template_Types Paragraphs",
            "Templates Documents Paragraphs",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the document ids whose paragraph numbers is greater or equal to two., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the document ids whose paragraph numbers is greater or equal to two., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID - Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID,",
            "select distinct Paragraphs.Document_ID",
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_Text)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the document ids whose paragraph numbers is greater or equal to two., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the ids of the documents that has at least 2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the ids of the documents that has at least 2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Documents.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Template_ID",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, t2.c5",
            "select Documents.Document_ID, Documents.Document_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the ids of the documents that has at least 2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "Documents Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "Paragraphs",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "Templates Documents Paragraphs",
            "Templates Paragraphs",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of documents that have more or equal to 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of documents that have more or equal to 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Template_ID",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of documents that have more or equal to 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the ID's of the documents which contains more or equal to two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the ID's of the documents which contains more or equal to two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Documents.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID",
            "select t4.c0",
            "select t5.c0",
            "select Paragraphs.Paragraph_ID",
            "select Templates.Template_ID",
            "select t4.c1",
            "select t12.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the ID's of the documents which contains more or equal to two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "Documents Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "Templates Paragraphs",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the ids of documents that have more or equal to 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the ids of documents that have more or equal to 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Template_ID",
            "select Paragraphs.Document_ID, Documents.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the ids of documents that have more or equal to 2 paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORSDER BY-LIMIT",
            "SELECT-FROM Total(t2.c0)",
            "SELECT-FROM total(t2.c0)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Documents.Template_ID",
            "select count(*), Documents.Document_ID",
            "select t2.c count(*)",
            "select count(Documents.Document_ID)",
            "select count(*), Documents.Other_Details",
            "select count(*), t2.c5",
            "select count(*), Documents.Document_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "",
            "",
            "",
            "",
            "",
            "Templates Documents",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the ids of the documents with one or two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING\u2013UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the ids of the documents with one or two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Template_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the ids of the documents with one or two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the ids of documents that have 1 or 2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-2-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING or-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING,-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the ids of documents that have 1 or 2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Template_ID",
            "select Paragraphs.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the ids of documents that have 1 or 2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of documents that have one and two paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-HAVE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of documents that have one and two paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Template_ID",
            "select Paragraphs.Document_ID, Documents.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of documents that have one and two paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Ref_Template_Types Documents Paragraphs",
            "Templates Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "Ref_Template_Types Paragraphs",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the ids of documents with 1-2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the ids of documents with 1-2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_ID",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID (Paragraphs.Paragraph_ID)",
            "select Paragraphs.Document_ID, Documents.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the ids of documents with 1-2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Documents Paragraphs",
            "Templates Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all template types that have been used multiple times and show their IDs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all template types that have been used multiple times and show their IDs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2, t1.c0",
        "label": "select t2.c1",
        "score": false,
        "real_pred": "select Templates.Template_Type_Code, Templates.Template_ID",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Templates.Template_Type_Code, Templates.Template_ID",
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, count(*)",
            "select Templates.Template_Type_Code, show Templates.Template_ID",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Template_Type_Code, max(Templates.Template_ID)",
            "select Templates.Template_Type_Code, Templates.Template_ID3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all template types that have been used multiple times and show their IDs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t2",
        "score": false,
        "real_pred": "Templates",
        "real_label": "Documents",
        "topk_preds": [
            "Templates",
            "Ref_Template_Types Templates",
            "Templates Documents",
            "Documents Templates",
            "Templates Paragraphs",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show ids for all template types used by two or more documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show ids for all template types used by two or more documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t2.c1",
        "score": false,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Templates.Template_Type_Code, Templates.Template_ID",
            "select Templates.Template_Type_Code.c2",
            "select Templates.Template_Type_Code (Documents.Template_ID)",
            "select Templates.Template_Type_Code, Documents.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show ids for all template types used by two or more documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t2",
        "score": false,
        "real_pred": "Templates Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the ids of templates that have been used in two or more documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the ids of templates that have been used in two or more documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Documents.Template_ID",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Description",
            "select Documents.Template_ID,",
            "select Documents.Template_ID (Documents.Document_ID)",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID, Templates.Template_ID",
            "select Documents.Template_ID, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the ids of templates that have been used in two or more documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Retrieve the version numbers and template type codes for the templates with a version number higher than 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Retrieve the version numbers and template type codes for the templates with a version number higher than 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Version_Number.c2, Templates.Version_Number",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_ID",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_Type_Code, Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Retrieve the version numbers and template type codes for the templates with a version number higher than 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the version number and template type code of every template which has a higher version number than 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the version number and template type code of every template which has a higher version number than 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Version_Number.c2, Templates.Version_Number",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select t1.c 1, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code,",
            "select Templates.Version_Number, Templates.Template_Type_Code.",
            "select Templates.Template_Type_Code, Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the version number and template type code of every template which has a higher version number than 5., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all template ids and list the total count of documents per template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-1-GROUP BY",
            "SELECT-FROM_GROUP BY",
            "SELECT-FROM-GROUP BY (t2.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all template ids and list the total count of documents per template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1, count(*)",
        "label": "select t2.c1, count(*)",
        "score": true,
        "real_pred": "select Documents.Template_ID, count(*)",
        "real_label": "select Documents.Template_ID, count(*)",
        "topk_preds": [
            "select Documents.Template_ID, count(*)",
            "select Documents.Template_ID, sum(Documents.Document_ID)",
            "select Documents.Template_ID, count(Documents.Document_ID)",
            "select Documents.Template_ID, count(per_Documents.Document_ID)",
            "select Documents.Template_ID, count(**)",
            "select Documents.Template_ID, count(*), Documents.Document_Name",
            "select Documents.Template_ID, sum(t2.c5)",
            "select Documents.Template_ID, count(*), Documents.Document_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all template ids and list the total count of documents per template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all documents that have at least 2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all documents that have at least 2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c2",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Documents.Document_Name",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_Name, Documents.Document_Description, Documents.Other_Details",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_Description, Documents.Other_Details",
            "select Documents.Document_Name descriptio, Documents.Document_Description",
            "select Documents.Document_Name, Documents.Document_Description, Documents.Document_Description",
            "select Documents.Document_Name ou Documents.Document_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all documents that have at least 2 paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "Documents Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "Ref_Template_Types Documents Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all documents with id and two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HaVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HavING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all documents with id and two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID",
            "select Documents.Document_ID, Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Paragraphs.Paragraph_Text",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Description",
            "select Documents.Document_ID, Paragraphs.Paragraph_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all documents with id and two or more paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "",
            "Templates Paragraphs",
            "",
            "Templates Documents Paragraphs",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the ids of documents that have more or equal to two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the ids of documents that have more or equal to two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Documents.Document_ID",
            "select Paragraphs.Document_ID",
            "select t4.c1",
            "select Paragraphs.Document_ID,",
            "select Paragraphs.Paragraph_ID",
            "select t5.c1",
            "select Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the ids of documents that have more or equal to two paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "Templates Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the count of the templates of the type CV., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE.GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the count of the templates of the type CV., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Templates.Template_Type_Code",
            "select count(*), Templates.Template_ID",
            "select count(*),",
            "select count(*), Templates.Version_Number",
            "select count(*), Templates.Date_Effective_To",
            "select count(*), Templates.Template_ID2",
            "select count(*), Templates.Template_Type_Code0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the count of the templates of the type CV., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the ID of any templates used in at least two documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the ID of any templates used in at least two documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Documents.Template_ID",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Template_ID, Templates.Template_Details",
            "select Documents.Template_ID, Documents.Document_Description",
            "select Documents.Template_ID (document_Documents.Document_ID)",
            "select Documents.Template_ID, Templates.Template_Type_Code",
            "select Documents.Template_ID(Documents.Document_ID)",
            "select Documents.Template_ID,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the ID of any templates used in at least two documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "Templates Documents",
            "",
            "",
            "",
            "",
            "Ref_Template_Types Documents",
            "Ref_Template_Types Templates Documents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the template ids of any templates used in multiple documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the template ids of any templates used in multiple documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Documents.Template_ID",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Description",
            "select Documents.Template_ID (Documents.Document_ID)",
            "select Documents.Template_ID,",
            "select Documents.Template_ID, Documents.Document_ID",
            "select Documents.Template_ID, Documents.Other_Details",
            "select Documents.Template_ID, t2.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the template ids of any templates used in multiple documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "Ref_Template_Types Documents",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the template ids of any templates used in multiple documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the template ids of any templates used in multiple documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Documents.Template_ID",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Description",
            "select Documents.Template_ID (Documents.Document_ID)",
            "select double-documented Documents.Template_ID",
            "select Documents.Template_ID,",
            "select Documents.Template_ID, Documents.Document_ID",
            "select Documents.Template_ID, Documents.Other_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the template ids of any templates used in multiple documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "Templates Documents",
            "",
            "",
            "Ref_Template_Types Templates Documents",
            "",
            "Ref_Template_Types Documents",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the template ids of templates used in at least two documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the template ids of templates used in at least two documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Documents.Template_ID",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Description",
            "select Documents.Template_ID (Documents.Document_ID)",
            "select Documents.Template_ID,",
            "select Documents.Template_ID, Documents.Document_ID",
            "select Documents.Template_ID, Templates.Template_Details",
            "select Documents.Template_ID, Templates.Template_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the template ids of templates used in at least two documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the template ids of any templates used in two or more documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the template ids of any templates used in two or more documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Documents.Template_ID",
        "real_label": "select Documents.Template_ID",
        "topk_preds": [
            "select Documents.Template_ID",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Description",
            "select Documents.Template_ID,",
            "select Documents.Template_ID (or Documents.Document_Name)",
            "select Documents.Template_ID, Documents.Document_ID",
            "select Documents.Template_ID, Documents.Other_Details",
            "select Documents.Template_ID (Documents.Document_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the template ids of any templates used in two or more documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "Templates Documents",
            "",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "Ref_Template_Types Documents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which template type code has the most documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which template type code has the most documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Templates.Template_Type_Code (ref. Documents.Template_ID)",
            "select Templates.Template_Type_Code (or Documents.Template_ID)",
            "select Templates.Template_Type_Code, Documents.Document_ID",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (http://Documents.Template_ID)",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which template type code has the most documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the template type code that is used by most documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHIC-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the template type code that is used by most documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code (or Documents.Template_ID)",
            "select Documents.Document_Name",
            "select Templates.Template_ID",
            "select Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the template type code that is used by most documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "Templates",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the template type code used by the largest number of documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the template type code used by the largest number of documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Documents.Document_Name",
            "select Templates.Template_Type_Code (or Documents.Template_ID)",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code(Documents.Template_ID)",
            "select Templates.Template_Type_Code (Documents.Template_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the template type code used by the largest number of documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Out of which template types, which ones have the largest total number of documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Out of which template types, which ones have the largest total number of documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Ref_Template_Types.Template_Type_Description, Templates.Template_Type_Code",
            "select Templates.Version_Number, Documents.Template_ID",
            "select Templates.Version_Number, Documents.Document_Name",
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Documents.Document_ID",
            "select Templates.Template_Type_Code, Documents.Document_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Out of which template types, which ones have the largest total number of documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM (count(*)",
            "SELECT-FROM total(*)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (total count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Paragraphs.Paragraph_ID",
            "select count(*), Paragraphs.Document_ID",
            "select count(*), Paragraphs.Paragraph_Text",
            "select t3.c count(*)",
            "select t3.count(*)",
            "select count(*), t3.c4",
            "select count(*), Paragraphs.Other_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            "Templates Paragraphs"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the template type codes with less than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ACCESS-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the template type codes with less than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code Suffice-to-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "select Templates.Template_Type_Code SAMPLE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "select Templates.Template_Type_Code Suffice-to-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "select Templates.Template_Type_Code SAMPLE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "select Templates.Template_Type_Code SAMPLE-GROUP BY-HAVING-UNION-SAMPLE-GROUP BY-HAVING",
            "select Templates.Template_Type_Code Suffice-to-GROUP BY-HAVING",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the template type codes with less than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the codes of template types that have fewer than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-PROGRAM-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the codes of template types that have fewer than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_Type_Code,",
            "select Templates.Template_Type_Code, http://Templates.Date_Effective_From",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the codes of template types that have fewer than three templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all the template type codes and show the total count of documents per type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUPS-GROUP BY",
            "SELECT-FROM-GROUP BY (t2.c1)",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-1-GROUP BY",
            "SELECT-FROM for-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all the template type codes and show the total count of documents per type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2, count(*)",
        "label": "select t1.c2, count(*)",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code, count(*)",
        "real_label": "select Templates.Template_Type_Code, count(*)",
        "topk_preds": [
            "select Templates.Template_Type_Code, count(*)",
            "select Documents.Template_ID, count(*)",
            "select Documents.Document_Name, count(*)",
            "select Templates.Template_Type_Code, sum(Documents.Document_ID)",
            "select Documents.Template_ID, sum(Documents.Document_ID)",
            "select Templates.Template_Type_Code, count(*), Documents.Template_ID",
            "select Templates.Template_Type_Code.c2, count(*)",
            "select Templates.Template_Type_Code, count(**)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all the template type codes and show the total count of documents per type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "Documents",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the code of the template type that has the most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the code of the template type that has the most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Date_Effective_To",
            "select Templates.Template_Type_Code (symbol Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code (http://www.Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the code of the template type that has the most templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which template type code shows the largest count of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which template type code shows the largest count of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Date_Effective_To",
            "select Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_Type_Code (http://www.Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From, Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which template type code shows the largest count of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the type code of the template type that has the largest number of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the type code of the template type that has the largest number of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code (http://www.Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_Type_Code (http://Templates.Template_Type_Code)",
            "select Templates.Template_Type_Code (or Templates.Date_Effective_From)",
            "select Templates.Template_Type_Code,",
            "select Templates.Template_Type_Code, Templates.Date_Effective_To"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the type code of the template type that has the largest number of templates?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the total count of the different templates used for documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM the count(distinct t2.c1)",
            "SELECT-FROM count(distinct t2.c1)",
            "SELECT-FROM (count(distinct t2.c1)",
            "SELECT-FROM total(distinct t2.c1)",
            "SELECT-FROM a count(distinct t2.c1)",
            "SELECT-FROM total count(distinct t2.c1)",
            "SELECT-FROM t2.c1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the total count of the different templates used for documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(distinct t2.c1)",
        "label": "select count(distinct t2.c1)",
        "score": true,
        "real_pred": "select count(distinct Documents.Template_ID)",
        "real_label": "select count(distinct Documents.Template_ID)",
        "topk_preds": [
            "select count(distinct Documents.Template_ID)",
            "select Documents.Template_ID, count(distinct Documents.Template_ID)",
            "select count(select count(distinct Documents.Template_ID)",
            "select count(selection count(distinct Documents.Template_ID)",
            "select count(different Documents.Template_ID)",
            "select Documents.Template_ID, count(distinct Documents.Document_ID)",
            "select count(distinct Documents.Template_ID),",
            "select count(distinct Documents.Document_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the total count of the different templates used for documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "",
            "Templates Documents",
            "",
            "",
            "Ref_Template_Types Templates Documents",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which document id and name have the largest number of paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C0-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C0, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which document id and name have the largest number of paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c2",
        "label": "select t3.c1, t2.c2",
        "score": false,
        "real_pred": "select Documents.Document_ID, Documents.Document_Name",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name, Paragraphs.Other_Details",
            "select Documents.Document_ID, Documents.Document_Name, Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Documents.Document_Name, Documents.Document_Description",
            "select t4.c1, Documents.Document_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which document id and name have the largest number of paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the document id and name that has the highest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C0-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the document id and name that has the highest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c2",
        "label": "select t3.c1, t2.c2",
        "score": false,
        "real_pred": "select Documents.Document_ID, Documents.Document_Name",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name, Paragraphs.Other_Details",
            "select Documents.Document_Name, Documents.Document_ID",
            "select Documents.Document_ID, Documents.Document_Name, Paragraphs.Document_ID",
            "select t4.c1, Documents.Document_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the document id and name that has the highest number of paragraphs., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the document id and name with most paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the document id and name with most paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c1, t2.c2",
        "label": "select t3.c1, t2.c2",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID, Documents.Document_Name",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name",
        "topk_preds": [
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Documents.Document_Name, Documents.Document_Description",
            "select Paragraphs.Paragraph_ID, Documents.Document_Name",
            "select t3, Paragraphs.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Documents.Document_Name, Paragraphs.Other_Details",
            "select t4.c1, Documents.Document_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the document id and name with most paragraphs?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the document id and name whose number of paragraph exceeds the others?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the document id and name whose number of paragraph exceeds the others?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c2",
        "label": "select t3.c1, t2.c2",
        "score": false,
        "real_pred": "select Documents.Document_ID, Documents.Document_Name",
        "real_label": "select Paragraphs.Document_ID, Documents.Document_Name",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Document_Name",
            "select Paragraphs.Document_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Name, Documents.Document_Description",
            "select t2, Documents.Document_ID, Documents.Document_Name",
            "select Documents.Template_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Name, Paragraphs.Other_Details",
            "select Templates.Template_ID, Documents.Document_Name",
            "select Documents.Document_ID, Documents.Document_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the document id and name whose number of paragraph exceeds the others?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers in order from youngest to oldest?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY ("
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers in order from youngest to oldest?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Age, teacher.Hometown",
            "select teacher.Name (ordered by teacher.Age)",
            "select teacher.Name (ordered teacher.Age)",
            "select teacher.Name (ordinal)",
            "select teacher.Name or teacher.Age",
            "select teacher.Name in teacher.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers in order from youngest to oldest?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of the teachers starting with the youngest., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY (SELECT-FROM-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of the teachers starting with the youngest., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Age, teacher.Hometown",
            "select teacher.Name (orthodox teacher.Age)",
            "select teacher.Name (or teacher.Age)",
            "select teacher.Name (or teacher.Age, teacher.Hometown)",
            "select teacher.Name (or teacher.Age), teacher.Hometown",
            "select teacher.Name (or teacher.Age, teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of the teachers starting with the youngest., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the hometown that the largest number of teachers from?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the hometown that the largest number of teachers from?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown (GROUP BY-ORDER BY-LIMIT)",
            "select teacher.Hometown, teacher.Age",
            "select teacher.Hometown, t1.c4",
            "select teacher.Hometown (GROUP BY-ORDER BY-LIMIT",
            "select teacher.Hometown, teacher.Teacher_ID",
            "select teacher.Hometown, teacher.Age, teacher.Hometown",
            "select teacher.Hometown, teacher.Age, teacher.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the hometown that the largest number of teachers from?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out the names of teachers and the amount of courses they teach., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY, UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY, SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GROUP BY -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out the names of teachers and the amount of courses they teach., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, count(*)",
        "label": "select t1.c1, count(*)",
        "score": true,
        "real_pred": "select teacher.Name, count(*)",
        "real_label": "select teacher.Name, count(*)",
        "topk_preds": [
            "select teacher.Name, count(*)",
            "select teacher.Name, count(*), course.Course",
            "select teacher.Name, count(distinct course.Course)",
            "select teacher.Name, count(course.Course)",
            "select teacher.Name, count(*), course.Course_ID",
            "select teacher.Name, count(*), teacher.Teacher_ID",
            "select teacher.Name, count(*), course_arrange.Teacher_ID",
            "select teacher.Name, count(*), course.Staring_Date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out the names of teachers and the amount of courses they teach., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find names of teachers and list their total counts in courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GEOGRAPHIC-GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY ORDINARY-ORDER BY",
            "SELECT-FROM-GROUPS-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find names of teachers and list their total counts in courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, count(*)",
        "label": "select t1.c1, count(*)",
        "score": true,
        "real_pred": "select teacher.Name, count(*)",
        "real_label": "select teacher.Name, count(*)",
        "topk_preds": [
            "select teacher.Name, count(*)",
            "select teacher.Name, sum(course_arrange.Teacher_ID)",
            "select teacher.Name, count(*), course_arrange.Teacher_ID",
            "select teacher.Name, sum(course_arrange.Course_ID)",
            "select teacher.Name, count(*), course.Course",
            "select teacher.Name, count(*),",
            "select teacher.Name, count(**)",
            "select teacher.Name, count(*), course_arrange.Course_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find names of teachers and list their total counts in courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "teacher course_arrange",
            "course teacher course_arrange",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the professors who teach two or more courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the professors who teach two or more courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, t0.c3",
            "select teacher.Name, teacher.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the professors who teach two or more courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of teachers that teach two or more courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of teachers that teach two or more courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, t0.c3",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name,",
            "select teacher.Name (course.Course)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of teachers that teach two or more courses., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me a list of teachers in increasing order of age., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me a list of teachers in increasing order of age., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select teacher.Name, teacher.Age",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name, teacher.Age",
            "select teacher.Name",
            "select teacher.Name, teacher.Age, teacher.Hometown",
            "select teacher.Teacher_ID, teacher.Name",
            "select teacher.Teacher_ID, teacher.Name, teacher.Age",
            "select teacher.Name und teacher.Age",
            "select teacher.Name \u015fi teacher.Age",
            "select teacher.Name and teacher.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me a list of teachers in increasing order of age., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Rank the teachers from youngest to oldest., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY(t1.c2)",
            "SELECT-FROM\u2013ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Rank the teachers from youngest to oldest., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c2",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select teacher.Age",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Age",
            "select teacher.Name, teacher.Age",
            "select teacher.Age, teacher.Name",
            "select teacher.Teacher_ID, teacher.Age",
            "select teacher.Age, order(*)",
            "select teacher.Hometown, teacher.Age",
            "select t1.crank(teacher.Age)",
            "select teacher.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Rank the teachers from youngest to oldest., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the list of teacher names in the order of youngest to oldest., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the list of teacher names in the order of youngest to oldest., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Age, teacher.Hometown",
            "select teacher.Name (ordered by teacher.Age)",
            "select teacher.Name (ordered teacher.Age)",
            "select teacher.Name in teacher.Age",
            "select teacher.Name, teacher.Age - teacher.Hometown",
            "select teacher.Name, teacher.Age, native_teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the list of teacher names in the order of youngest to oldest., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the teachers who were born in other districts except Little Lever Urban District?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the teachers who were born in other districts except Little Lever Urban District?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age",
            "select teacher.Name - teacher.Age",
            "select teacher.Name (not teacher.Age)",
            "select teacher.Name - teacher.Hometown",
            "select teacher.Name (or teacher.Age)",
            "select teacher.Name, teacher.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the teachers who were born in other districts except Little Lever Urban District?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of those teachers which teach two or more courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of those teachers which teach two or more courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, t0.c3",
            "select teacher.Name (course.Course)",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name de, course.Course"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of those teachers which teach two or more courses?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me a list of the teachers that are teaching more than one course., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOMETRY-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me a list of the teachers that are teaching more than one course., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select course_arrange.Teacher_ID, teacher.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me a list of the teachers that are teaching more than one course., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1 t2",
        "score": false,
        "real_pred": "course teacher course_arrange",
        "real_label": "teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "teacher course_arrange",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the list of hometowns shared by two or more teachers?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the list of hometowns shared by two or more teachers?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown, teacher.Age",
            "select teacher.Hometown, count(*)",
            "select teacher.Hometown, t1.c4",
            "select teacher.Hometown, teacher.Hometown",
            "select teacher.Hometown, teacher.Teacher_ID",
            "select teacher.Hometown, max(teacher.Hometown)",
            "select teacher.Hometown, min(teacher.Hometown)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the list of hometowns shared by two or more teachers?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the hometowns shared by more than a single teacher?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-INSTEAD-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the hometowns shared by more than a single teacher?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown, teacher.Hometown",
            "select teacher.Hometown, teacher.Age",
            "select teacher.Hometown, count(*)",
            "select teacher.Hometown, t1.c4",
            "select teacher.Hometown, if teacher.Hometown",
            "select teacher.Hometown, teacher.Name",
            "select teacher.Hometown, max(teacher.Hometown)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the hometowns shared by more than a single teacher?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the teachers who live in towns other than Little Lever Urban District., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the teachers who live in towns other than Little Lever Urban District., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c0",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select teacher.Teacher_ID",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Teacher_ID",
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Teacher_ID, teacher.Name",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Teacher_ID, teacher.Hometown",
            "select teacher.Name, teacher.Teacher_ID3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the teachers who live in towns other than Little Lever Urban District., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all the towns from which two or more teachers come from., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all the towns from which two or more teachers come from., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown, count(*)",
            "select teacher.Hometown, teacher.Hometown",
            "select teacher.Hometown, teacher.Age",
            "select teacher.Hometown, t1.c4",
            "select teacher.Hometown, min(teacher.Hometown)",
            "select teacher.Hometown, teacher.Teacher_ID",
            "select teacher.Hometown, max(teacher.Hometown)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all the towns from which two or more teachers come from., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the id, name and membership level of visitors who have spent the most money in total in all museum tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the id, name and membership level of visitors who have spent the most money in total in all museum tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t2.c1, t1.c1, t1.c2",
        "label": "select t2.c1, t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
        "real_label": "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
        "topk_preds": [
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
            "select visitor.ID, visitor.Name, visitor.Level_of_membership",
            "select visit.Museum_ID, visitor.Name, visitor.Level_of_membership",
            "select visitor.ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID), visitor.Name, visitor.Level_of_membership",
            "select t3.c1, visitor.Name, visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the id, name and membership level of visitors who have spent the most money in total in all museum tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the id, name and membership level of visitors who has spent the most in all museum tickets., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the id, name and membership level of visitors who has spent the most in all museum tickets., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t2.c1, t1.c1, t1.c2",
        "label": "select t2.c1, t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
        "real_label": "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
        "topk_preds": [
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
            "select visitor.ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.ID, visitor.Name, visitor.Level_of_membership",
            "select visit.Museum_ID, visitor.Name, visitor.Level_of_membership",
            "select visitor.ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the id, name and membership level of visitors who has spent the most in all museum tickets., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the ID, name, and membership level of visitors who have spent the most in total at all museum tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the ID, name, and membership level of visitors who have spent the most in total at all museum tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t2.c1, t1.c1, t1.c2",
        "label": "select t2.c1, t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
        "real_label": "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
        "topk_preds": [
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
            "select visitor.ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.ID, visitor.Name, visitor.Level_of_membership",
            "select visit.Museum_ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
            "select visitor.ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.Level_of_membership, visitor.Name",
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the ID, name, and membership level of visitors who have spent the most in total at all museum tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the id, name and membership level of visitors who have spent the most money for the total museum tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the id, name and membership level of visitors who have spent the most money for the total museum tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c0, t1.c1, t1.c2",
        "label": "select t2.c1, t1.c1, t1.c2",
        "score": false,
        "real_pred": "select visitor.ID, visitor.Name, visitor.Level_of_membership",
        "real_label": "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
        "topk_preds": [
            "select visitor.ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
            "select visitor.ID, visitor.Name, visitor.Level_of_membership",
            "select visit.Museum_ID, visitor.Name, visitor.Level_of_membership",
            "select t4.c0, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
            "select visit.visitor_ID, visitor.Name, visitor.Level_of_membership",
            "select t3.c0, visitor.Name, visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the id, name and membership level of visitors who have spent the most money for the total museum tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the sum of the ticket expense for the visitors with membership level 1?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ADD(t2.c3)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the sum of the ticket expense for the visitors with membership level 1?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select sum(t2.c3)",
        "label": "select sum(t2.c3)",
        "score": true,
        "real_pred": "select sum(visit.Total_spent)",
        "real_label": "select sum(visit.Total_spent)",
        "topk_preds": [
            "select sum(visit.Total_spent)",
            "select sum(visit.Total_spent), visitor.ID",
            "select sum(visit.Num_of_Ticket)",
            "select sum(visit.Total_spent)avg(visit.Num_of_Ticket)",
            "select sum(visit.Total_spent), visitor.Name",
            "select sum(visit.Total_spent)aft visitor.ID",
            "select sum(t2.c4)",
            "select sum(visit.Total_spent),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the sum of the ticket expense for the visitors with membership level 1?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "museum visitor visit",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many visitors under the age of 30 are there?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many visitors under the age of 30 are there?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), visitor.ID",
            "select count(*), visitor.Age",
            "select count(*),",
            "select count(*), visitor.Name",
            "select count(*), visitor.ID3",
            "select count(*), visitor.Level_of_membership",
            "select count(*) (visitor.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many visitors under the age of 30 are there?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many guests are under 30 years old?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many guests are under 30 years old?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), visitor.ID",
            "select count(*), visitor.Age",
            "select count(*) (visitor.ID)",
            "select count(*),",
            "select count(*), visitor.Name",
            "select count(*), http://visitor.ID",
            "select count(*), visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many guests are under 30 years old?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many visitors under 30 years old are there?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-CUMULAT-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many visitors under 30 years old are there?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), visitor.ID",
            "select count(*), visitor.Age",
            "select count(*), visitor.ID3",
            "select count(*), visitor.Name",
            "select count(*),",
            "select count(*), visitor.Level_of_membership",
            "select count(*) (visitor.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many visitors under 30 years old are there?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "visitor visit",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total number of visitors under age 30?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total number of visitors under age 30?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select sum(visitor.Age)",
            "select visitor.Age, count(*)",
            "select count(*), visitor.Age",
            "select count(*), visitor.ID",
            "select sum(visitor.ID)",
            "select t1.c count(*)",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total number of visitors under age 30?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many visitors are there who are less than 30 years old?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many visitors are there who are less than 30 years old?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), visitor.ID",
            "select count(*) (visitor.ID)",
            "select count(*),",
            "select count(*), http://visitor.ID",
            "select count(*), visitor.Age",
            "select count(*), visitor.Name",
            "select count(*), visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many visitors are there who are less than 30 years old?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the visitor\u2019s name and how old he/she was for who bought the largest volume of tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the visitor\u2019s name and how old he/she was for who bought the largest volume of tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": true,
        "real_pred": "select visitor.Name, visitor.Age",
        "real_label": "select visitor.Name, visitor.Age",
        "topk_preds": [
            "select visitor.Name, visitor.Age",
            "select visitor.Name, visitor.Age, visitor.ID",
            "select visitor.ID, visitor.Name, visitor.Age",
            "select visitor.Name, visitor.Age, visit.visitor_ID",
            "select visit.visitor_ID, visitor.Age",
            "select t1, visitor.Name, visitor.Age",
            "select visitor.Name, visitor.Age, t1.c4",
            "select visitor.Name, visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the visitor\u2019s name and how old he/she was for who bought the largest volume of tickets?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the visitor who visited a museum with an open date earlier than 2009 and later than 2011?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the visitor who visited a museum with an open date earlier than 2009 and later than 2011?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select visitor.Name",
        "real_label": "select visitor.Name",
        "topk_preds": [
            "select visitor.Name",
            "select visitor.Name, visit.visitor_ID",
            "select visitor.Name, museum.Name",
            "select visitor.Name, visit.Museum_ID",
            "select visitor.Name, visitor.ID",
            "select visitor.Name, museum.Open_Year",
            "select visitor.Name, museum.Num_of_Staff",
            "select visitor.Name, visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the visitor who visited a museum with an open date earlier than 2009 and later than 2011?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "museum visitor visit",
        "real_label": "museum visitor visit",
        "topk_preds": [
            "museum visitor visit",
            "",
            "",
            "",
            "",
            "museum visitor",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Calculate the average number of employees working at the museums prior to 2009., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Calculate the average number of employees working at the museums prior to 2009., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t0.c2)",
        "label": "select avg(t0.c2)",
        "score": true,
        "real_pred": "select avg(museum.Num_of_Staff)",
        "real_label": "select avg(museum.Num_of_Staff)",
        "topk_preds": [
            "select avg(museum.Num_of_Staff)",
            "select avg(t0.c4)",
            "select avg(museum.Open_Year)",
            "select an avg(museum.Num_of_Staff)",
            "select avg(t0.c6)",
            "select avg(t0.c5)",
            "select avg(museum.Num_of_Staff).",
            "select avg(t0.c8)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Calculate the average number of employees working at the museums prior to 2009., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the mean size of staff employed in open museums that had their doors open before 2009?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the mean size of staff employed in open museums that had their doors open before 2009?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t0.c2)",
        "label": "select avg(t0.c2)",
        "score": true,
        "real_pred": "select avg(museum.Num_of_Staff)",
        "real_label": "select avg(museum.Num_of_Staff)",
        "topk_preds": [
            "select avg(museum.Num_of_Staff)",
            "select an avg(museum.Num_of_Staff)",
            "select avg(t0.c4)",
            "select avg(museum.Open_Year)",
            "select avg(t0.c6)",
            "select avg(museum.Num_of_Staff).",
            "select avg(t0.c5)",
            "select avg(t0.c 2)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the mean size of staff employed in open museums that had their doors open before 2009?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names and levels of all visitors who have a membership level greater than 4, sort them in ascending order of age, from oldest to youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY(t1.c1)",
            "SELECT-FROM-WHERE-ORDER BY (",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHEREORDER BY",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERE\u2013ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names and levels of all visitors who have a membership level greater than 4, sort them in ascending order of age, from oldest to youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visitor.Name, visitor.Level_of_membership",
        "real_label": "select visitor.Name, visitor.Level_of_membership",
        "topk_preds": [
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name, visitor.Level_of_membership, visitor.Age",
            "select visitor.Name, visitor.Age",
            "select visitor.Name, visitor.Level_of_membership in visitor.Age",
            "select visitor.Name, visitor.Level_of_membership - visitor.Age",
            "select visitor.Name, visitor.Level_of_membership, visitor.Age",
            "select visitor.Name, visitor.Level_of_membership (ordered by",
            "select visitor.Name, t1.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names and levels of all visitors who have a membership level greater than 4, sort them in ascending order of age, from oldest to youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names and membership levels of visitors who has a membership level above 4, and sort them in ascending order by age from oldest to youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WITH-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY(t1.c1)",
            "SELECT-FROM-WHEREORDER BY",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERE-ORDER BY (",
            "SELECT-FROM-WHEREF-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names and membership levels of visitors who has a membership level above 4, and sort them in ascending order by age from oldest to youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visitor.Name, visitor.Level_of_membership",
        "real_label": "select visitor.Name, visitor.Level_of_membership",
        "topk_preds": [
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name, visitor.Level_of_membership, visitor.Age",
            "select visitor.Name, visitor.Level_of_membership sort-by-order by",
            "select visitor.Name, visitor.Level_of_membership sort-by-ORDER BY",
            "select visitor.Name, visitor.Level_of_membership in visitor.Age",
            "select visitor.Name, visitor.Level_of_membership sort visitor.Age",
            "select visitor.Name, visitor.Level_of_membership or visitor.Age",
            "select visitor.Name, visitor.Level_of_membership sort-by-ordnance"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names and membership levels of visitors who has a membership level above 4, and sort them in ascending order by age from oldest to youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name and membership level of the visitors whose membership level is bigger than 4, show in ascending order from the oldest to the youngest and sort them from the oldest to the youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (CLIENT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (CLIENTS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY(t1.c1)",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name and membership level of the visitors whose membership level is bigger than 4, show in ascending order from the oldest to the youngest and sort them from the oldest to the youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visitor.Name, visitor.Level_of_membership",
        "real_label": "select visitor.Name, visitor.Level_of_membership",
        "topk_preds": [
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name, visitor.Level_of_membership, visitor.Age",
            "select visitor.Name, visitor.Level_of_membership sort(visitor.Age)",
            "select visitor.Name, visitor.Level_of_membership sort in visitor.Age",
            "select visitor.Name, visitor.Level_of_membership, sort(visitor.Age)",
            "select visitor.Name, visitor.Level_of_membership sort them in visitor.Age",
            "select visitor.Name, visitor.Level_of_membership in visitor.Age",
            "select visitor.Name, visitor.Level_of_membership - visitor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name and membership level of the visitors whose membership level is bigger than 4, show in ascending order from the oldest to the youngest and sort them from the oldest to the youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the ID and name of the museum that has the largest number of employees?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the ID and name of the museum that has the largest number of employees?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select museum.Museum_ID, museum.Name",
        "real_label": "select museum.Museum_ID, museum.Name",
        "topk_preds": [
            "select museum.Museum_ID, museum.Name",
            "select museum.Name, museum.Museum_ID",
            "select museum.Museum_ID, museum.Name, museum.Num_of_Staff",
            "select museum.Num_of_Staff, museum.Name",
            "select museum.Museum_ID, museum.Name, museum.Open_Year",
            "select museum.Museum_ID1, museum.Name",
            "select museum.Museum_ID, museum.Name (ORDER BY-LIMIT)",
            "select museum.Museum_ID-, museum.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the ID and name of the museum that has the largest number of employees?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the id and name of the most visited museum., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the id and name of the most visited museum., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t2.c0, t0.c1",
        "score": false,
        "real_pred": "select museum.Museum_ID, museum.Name",
        "real_label": "select visit.Museum_ID, museum.Name",
        "topk_preds": [
            "select museum.Museum_ID, museum.Name",
            "select visit.Museum_ID, museum.Name",
            "select museum.Name, museum.Museum_ID",
            "select visitor.ID, museum.Name",
            "select t3.c0, museum.Name",
            "select visit.visitor_ID, museum.Name",
            "select t 0.c0, museum.Name",
            "select t.c0, museum.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the id and name of the most visited museum., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "museum visit",
        "real_label": "museum visit",
        "topk_preds": [
            "museum visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the max and avg ticket sales for all visits., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM (t2.c2), avg(t2.c2)",
            "SELECT-FROM (T2.c2), avg(t2.c2)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (t2.c2), AVG(t2.c2)",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the max and avg ticket sales for all visits., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select max(t2.c2), avg(t2.c2)",
        "label": "select avg(t2.c2), max(t2.c2)",
        "score": false,
        "real_pred": "select max(visit.Num_of_Ticket), avg(visit.Num_of_Ticket)",
        "real_label": "select avg(visit.Num_of_Ticket), max(visit.Num_of_Ticket)",
        "topk_preds": [
            "select max(visit.Num_of_Ticket), avg(visit.Num_of_Ticket)",
            "select max(t2.c6), avg(visit.Num_of_Ticket)",
            "select max(visit.Total_spent), avg(visit.Num_of_Ticket)",
            "select max(t2.c4), avg(visit.Num_of_Ticket)",
            "select max(t2.c8), avg(visit.Num_of_Ticket)",
            "select max(t2.c5), avg(visit.Num_of_Ticket)",
            "select avg(visit.Num_of_Ticket), max(visit.Num_of_Ticket)",
            "select max(visit.Num_of_Ticket), avg (visit.Num_of_Ticket)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the max and avg ticket sales for all visits., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "visit",
        "real_label": "visit",
        "topk_preds": [
            "visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of the visitors whose membership level is greater than 4, and sort them by their level from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY t1.c1",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WITH-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY(t1.c1)",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of the visitors whose membership level is greater than 4, and sort them by their level from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select visitor.Name",
        "real_label": "select visitor.Name",
        "topk_preds": [
            "select visitor.Name",
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name, t1.c4",
            "select visitor.Name&sort(visitor.Level_of_membership)",
            "select visitor.Name, visitor.Age",
            "select visitor.Name-ordered",
            "select visitor.Name-ORDER BY",
            "select visitor.Name descended visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of the visitors whose membership level is greater than 4, and sort them by their level from high to low., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of the visitors whose membership level is larger than four, and list the results in descending order by level., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHERE\u2013ORDER BY",
            "SELECT-FROM-WHEREORDER BY",
            "SELECT-FROM-WHEREF-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (",
            "SELECT-FROM-WHERE- ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of the visitors whose membership level is larger than four, and list the results in descending order by level., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select visitor.Name",
        "real_label": "select visitor.Name",
        "topk_preds": [
            "select visitor.Name",
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name, visitor.Level_of_membership, visitor.Age",
            "select visitor.Name, visitor.Level_of_membership - visitor.Age",
            "select visitor.Name&sort_by-ORDER BY",
            "select visitor.Name-ORDER BY",
            "select visitor.Name, visitor.Level_of_membership (ORDER BY",
            "select visitor.Name descended visitor.Level_of_membership"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of the visitors whose membership level is larger than four, and list the results in descending order by level., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are the visitors whose membership levels do not exceed 4 years?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are the visitors whose membership levels do not exceed 4 years?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select avg(t1.c3)",
        "score": false,
        "real_pred": "select visitor.Age",
        "real_label": "select avg(visitor.Age)",
        "topk_preds": [
            "select visitor.Age",
            "select visitor.Age, visitor.Level_of_membership",
            "select visitor.Age, t1.c4",
            "select visitor.Age,",
            "select visitor.Age, visitor.ID",
            "select visitor.Age, t1.c6",
            "select visitor.Age - visitor.Level_of_membership",
            "select visitor.Age."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are the visitors whose membership levels do not exceed 4 years?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many visitors whose membership level is not larger than 4, how old are they in average?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many visitors whose membership level is not larger than 4, how old are they in average?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select count(*), avg(t1.c3)",
        "label": "select avg(t1.c3)",
        "score": false,
        "real_pred": "select count(*), avg(visitor.Age)",
        "real_label": "select avg(visitor.Age)",
        "topk_preds": [
            "select count(*), avg(visitor.Age)",
            "select avg(visitor.Age), count(*)",
            "select avg(visitor.Age)",
            "select number(*), avg(visitor.Age)",
            "select counts(*), avg(visitor.Age)",
            "select count(*), avg(visitor.Age)",
            "select avg(visitor.Age), count(*)",
            "select AVG(visitor.Age), count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many visitors whose membership level is not larger than 4, how old are they in average?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the average age of the visitors who have a membership level between 1 and 4., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY (INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the average age of the visitors who have a membership level between 1 and 4., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t1.c3)",
        "label": "select avg(t1.c3)",
        "score": true,
        "real_pred": "select avg(visitor.Age)",
        "real_label": "select avg(visitor.Age)",
        "topk_preds": [
            "select avg(visitor.Age)",
            "select an avg(visitor.Age)",
            "select  avg(visitor.Age)",
            "select avg(t1.c)",
            "select avg(t1.c4)",
            "select avg(visitor.Age),",
            "select the avg(visitor.Age)",
            "select avg(visitor.Age)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the average age of the visitors who have a membership level between 1 and 4., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the year with the most matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the year with the most matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c31",
        "label": "select t1.c31",
        "score": true,
        "real_pred": "select matches.year",
        "real_label": "select matches.year",
        "topk_preds": [
            "select matches.year",
            "select matches.year, matches.winner_entry",
            "select matches.year, matches.tourney_date",
            "select matches.year, matches.loser_age",
            "select matches.year, matches.match_num",
            "select matches.year, matches.winner_hand",
            "select matches.year, matches.tourney_name",
            "select matches.year (matches.match_num)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the year with the most matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the year with the highest number of matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the year with the highest number of matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c31",
        "label": "select t1.c31",
        "score": true,
        "real_pred": "select matches.year",
        "real_label": "select matches.year",
        "topk_preds": [
            "select matches.year",
            "select matches.year, matches.winner_entry",
            "select matches.year, matches.tourney_date",
            "select matches.year (matches.match_num)",
            "select matches.year, matches.winner_hand",
            "select matches.year, matches.loser_age",
            "select matches.year, matches.tourney_name",
            "select matches.year, matches.match_num"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the year with the highest number of matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the highest year with most matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the highest year with most matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c31",
        "label": "select t1.c31",
        "score": true,
        "real_pred": "select matches.year",
        "real_label": "select matches.year",
        "topk_preds": [
            "select matches.year",
            "select matches.year, matches.winner_entry",
            "select matches.year, matches.tourney_date",
            "select matches.year, matches.loser_age",
            "select matches.year, matches.winner_hand",
            "select matches.year, matches.match_num",
            "select matches.year, matches.tourney_name",
            "select matches.year, matches.minutes"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the highest year with most matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the year in which there is the largest number of matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the year in which there is the largest number of matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c31",
        "label": "select t1.c31",
        "score": true,
        "real_pred": "select matches.year",
        "real_label": "select matches.year",
        "topk_preds": [
            "select matches.year",
            "select matches.year, matches.winner_entry",
            "select matches.year, matches.tourney_date",
            "select matches.year (matches.match_num)",
            "select matches.year,",
            "select matches.year, matches.winner_hand",
            "select matches.year (matches.loser_age)",
            "select matches.year, matches.loser_age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the year in which there is the largest number of matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the year that has the greatest number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the year that has the greatest number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c31",
        "label": "select t1.c31",
        "score": true,
        "real_pred": "select matches.year",
        "real_label": "select matches.year",
        "topk_preds": [
            "select matches.year",
            "select matches.year, matches.winner_entry",
            "select matches.year, matches.tourney_date",
            "select matches.year, matches.loser_age",
            "select matches.year, matches.winner_hand",
            "select matches.year, matches.match_num",
            "select matches.year, matches.tourney_name",
            "select matches.year (matches.match_num)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the year that has the greatest number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The overall rank points for each player, and show first names., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The overall rank points for each player, and show first names., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t2.c2, sum(t2.c3)",
        "label": "select sum(t2.c3), t0.c1",
        "score": false,
        "real_pred": "select rankings.player_id, sum(rankings.ranking_points)",
        "real_label": "select sum(rankings.ranking_points), players.first_name",
        "topk_preds": [
            "select rankings.player_id, sum(rankings.ranking_points)",
            "select sum(rankings.ranking_points), players.first_name",
            "select rankings.ranking, players.first_name",
            "select rankings.ranking_points, players.first_name",
            "select players.first_name, sum(rankings.ranking_points)",
            "select rankings.ranking_date, sum(rankings.ranking_points)",
            "select rankings.player_id, rankings.ranking_points",
            "select total(rankings.ranking_points), players.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The overall rank points for each player, and show first names., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "players rankings",
        "real_label": "players rankings",
        "topk_preds": [
            "players rankings",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the amount of ranking points for all players and their first names?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the amount of ranking points for all players and their first names?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select sum(t2.c3), t0.c1",
        "label": "select sum(t2.c3), t0.c1",
        "score": true,
        "real_pred": "select sum(rankings.ranking_points), players.first_name",
        "real_label": "select sum(rankings.ranking_points), players.first_name",
        "topk_preds": [
            "select sum(rankings.ranking_points), players.first_name",
            "select rankings.ranking_points, players.first_name",
            "select rankings.player_id, sum(rankings.ranking_points)",
            "select rankings.player_id, players.first_name",
            "select rankings.ranking, players.first_name",
            "select total(rankings.ranking_points), players.first_name",
            "select amount(rankings.ranking_points), players.first_name",
            "select sum(rankings.ranking_points), players.first_name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the amount of ranking points for all players and their first names?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "players rankings",
        "real_label": "players rankings",
        "topk_preds": [
            "players rankings",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the total amount of ranking points and first name of each player., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t0.c0, SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the total amount of ranking points and first name of each player., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select sum(t2.c3), t0.c1",
        "label": "select sum(t2.c3), t0.c1",
        "score": true,
        "real_pred": "select sum(rankings.ranking_points), players.first_name",
        "real_label": "select sum(rankings.ranking_points), players.first_name",
        "topk_preds": [
            "select sum(rankings.ranking_points), players.first_name",
            "select rankings.player_id, sum(rankings.ranking_points)",
            "select rankings.ranking_points, players.first_name",
            "select rankings.ranking, sum(rankings.ranking_points)",
            "select players.player_id, sum(rankings.ranking_points), players.first_name",
            "select players.first_name, sum(rankings.ranking_points)",
            "select rankings.player_id, sum(rankings.ranking_points), players.first_name",
            "select sum(rankings.ranking_points), players.first_name, players.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the total amount of ranking points and first name of each player., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "players rankings",
        "real_label": "players rankings",
        "topk_preds": [
            "players rankings",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the first name and country code of the player who has made the most tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the first name and country code of the player who has made the most tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c5",
        "label": "select t0.c5, t0.c1",
        "score": false,
        "real_pred": "select players.first_name, players.country_code",
        "real_label": "select players.country_code, players.first_name",
        "topk_preds": [
            "select players.first_name, players.country_code",
            "select players.first_name, players.country_code, players.player_id",
            "select players.first_name, players.last_name, players.country_code",
            "select players.first_name, players.country_code, players.last_name",
            "select players.first_name, players.country_code, players.birth_date",
            "select players.first_name, players.country_code, t0.c6",
            "select players.first_name, players.country_code, players.hand",
            "select players.first_name, players.country_code, t0.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the first name and country code of the player who has made the most tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "players rankings",
        "real_label": "players rankings",
        "topk_preds": [
            "players rankings",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the id and country code of the player with the highest number of tours?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t0.c0, t0.c5",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the id and country code of the player with the highest number of tours?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c0, t0.c5",
        "label": "select t0.c5, t0.c1",
        "score": false,
        "real_pred": "select players.player_id, players.country_code",
        "real_label": "select players.country_code, players.first_name",
        "topk_preds": [
            "select players.player_id, players.country_code",
            "select rankings.player_id, players.country_code",
            "select players.first_name, players.country_code",
            "select t3.c2, players.country_code",
            "select matches.loser_age, players.country_code",
            "select t4.c2, players.country_code",
            "select t02.c2, players.country_code",
            "select t5.c2, players.country_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the id and country code of the player with the highest number of tours?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "players rankings",
        "real_label": "players rankings",
        "topk_preds": [
            "players rankings",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first name and country code of the player that has the most tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first name and country code of the player that has the most tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c5",
        "label": "select t0.c5, t0.c1",
        "score": false,
        "real_pred": "select players.first_name, players.country_code",
        "real_label": "select players.country_code, players.first_name",
        "topk_preds": [
            "select players.first_name, players.country_code",
            "select players.player_id, players.first_name, players.country_code",
            "select players.first_name, players.country_code, players.player_id",
            "select players.first_name, players.last_name, players.country_code",
            "select players.first_name, players.country_code, players.last_name",
            "select players.first_name, players.country_code, t0.c6",
            "select players.first_name, players.country_code, players.birth_date",
            "select players.first_name, players.country_code, players.hand"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first name and country code of the player that has the most tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "players rankings",
        "real_label": "players rankings",
        "topk_preds": [
            "players rankings",
            "",
            "",
            "",
            "",
            "",
            "",
            "players matches rankings"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the first name, country code, and number of tours of the player with the greatest number of tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t0.c1, t0.c5, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the first name, country code, and number of tours of the player with the greatest number of tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c5, count(*)",
        "label": "select t0.c5, t0.c1",
        "score": false,
        "real_pred": "select players.first_name, players.country_code, count(*)",
        "real_label": "select players.country_code, players.first_name",
        "topk_preds": [
            "select players.first_name, players.country_code, count(*)",
            "select players.first_name, players.country_code, rankings.tours",
            "select players.first_name, players.country_code, count(rankings.tours)",
            "select players.first_name, players.country_code, sum(rankings.tours)",
            "select players.first_name, players.country_code, max(rankings.tours)",
            "select players.first_name, players.country_code, counts(*)",
            "select players.first_name, players.country_code, count(**)",
            "select players.first_name, players.country_code, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the first name, country code, and number of tours of the player with the greatest number of tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "players rankings",
        "real_label": "players rankings",
        "topk_preds": [
            "players rankings",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out the first name and country code of the player who has done the most tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out the first name and country code of the player who has done the most tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c5",
        "label": "select t0.c5, t0.c1",
        "score": false,
        "real_pred": "select players.first_name, players.country_code",
        "real_label": "select players.country_code, players.first_name",
        "topk_preds": [
            "select players.first_name, players.country_code",
            "select players.first_name, players.country_code, players.player_id",
            "select players.first_name, players.last_name, players.country_code",
            "select players.first_name, players.country_code, players.last_name",
            "select players.first_name, players.country_code, t0.c6",
            "select players.first_name, players.country_code, players.birth_date",
            "select players.first_name, players.country_code, players.hand",
            "select players.first_name, players.country_code, t0.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out the first name and country code of the player who has done the most tours., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "players rankings",
        "real_label": "players rankings",
        "topk_preds": [
            "players rankings",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), matches.match_num",
            "select t1.c count(*)",
            "select count(*), matches.minutes",
            "select count(*), matches.draw_size",
            "select count(*), matches.loser_id",
            "select count(*), matches.best_of",
            "select count(*) (matches.match_num)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "matches rankings",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the first and last name of all players that are left-handed, listed by birth date., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY (CLIENT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-WHERE-ORDER BY (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the first and last name of all players that are left-handed, listed by birth date., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select distinct players.first_name, players.last_name",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name (Date, Last)",
            "select players.first_name, players.last_name (Date, Last), players.birth_date",
            "select players.first_name, players.last_name (Date, Last), players.birth_date",
            "select players.first_name, players.last_name (\"Date, Last\"), players.birth_date",
            "select players.first_name, players.last_name in players.birth_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the first and last name of all players that are left-handed, listed by birth date., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date, Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of the loser and winner who played in the match with the most minutes., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of the loser and winner who played in the match with the most minutes., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c8, t1.c27",
        "label": "select t1.c27, t1.c8",
        "score": false,
        "real_pred": "select matches.loser_name, matches.winner_name",
        "real_label": "select matches.winner_name, matches.loser_name",
        "topk_preds": [
            "select matches.loser_name, matches.winner_name",
            "select t1.c 8, matches.winner_name",
            "select matches.loser_name, t1.c 27",
            "select matches.loser_ioc, matches.loser_name",
            "select t1.c 8, t1.c 27",
            "select matches.loser_ht, matches.loser_ioc",
            "select t2.c8, rankings.player_id7",
            "select matches.loser_name, matches.loser_ioc"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of the loser and winner who played in the match with the most minutes., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of the losers and winners who played in the match that had the longest time., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of the losers and winners who played in the match that had the longest time., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c8, t1.c27",
        "label": "select t1.c27, t1.c8",
        "score": false,
        "real_pred": "select matches.loser_name, matches.winner_name",
        "real_label": "select matches.winner_name, matches.loser_name",
        "topk_preds": [
            "select matches.loser_name, matches.winner_name",
            "select matches.loser_name, t1.c 27",
            "select matches.loser_ioc, matches.loser_name",
            "select t1.c 8, matches.winner_name",
            "select matches.loser_name, matches.loser_ioc",
            "select matches.loser_name, matches.winner_ioc",
            "select matches.loser_ht, matches.loser_ioc",
            "select t2.c8, rankings.player_id7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of the losers and winners who played in the match that had the longest time., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of the losers and winners who played in the match that had the largest duration., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of the losers and winners who played in the match that had the largest duration., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c8, t1.c27",
        "label": "select t1.c27, t1.c8",
        "score": false,
        "real_pred": "select matches.loser_name, matches.winner_name",
        "real_label": "select matches.winner_name, matches.loser_name",
        "topk_preds": [
            "select matches.loser_name, matches.winner_name",
            "select matches.loser_name, t1.c 27",
            "select matches.loser_ioc, matches.loser_name",
            "select matches.loser_name, matches.loser_ioc",
            "select t1.c 8, matches.winner_name",
            "select t2.c8, rankings.player_id7",
            "select matches.loser_ht, matches.loser_ioc",
            "select matches.loser_name, matches.winner_ioc"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of the losers and winners who played in the match that had the largest duration., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the codes of countries with at least 51 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the codes of countries with at least 51 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, count(*)",
            "select players.country_code (wHERE-GROUP BY-HAVING",
            "select players.country_code, t0.c6",
            "select players.country_code, max(players.country_code)",
            "select players.country_code (wHERE-GROUP BY-HAVING)",
            "select players.country_code, max(*)",
            "select players.country_code, max(t0.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the codes of countries with at least 51 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "players matches",
            "players rankings",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the codes of countries with over 50 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the codes of countries with over 50 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, t0.c6",
            "select players.country_code, max(players.player_id)",
            "select players.country_code, players.birth_date",
            "select players.country_code, max(players.country_code)",
            "select players.country_code, t0.c7",
            "select players.country_code, max(t0.c6)",
            "select players.country_code, max(players.birth_date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the codes of countries with over 50 players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "players matches",
            "players rankings",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the code for the country with the largest player base., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the code for the country with the largest player base., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, t0.c6",
            "select players.country_code, players.birth_date",
            "select players.country_code, players.last_name",
            "select players.country_code, players.hand",
            "select players.country_code, players.first_name",
            "select players.country_code, players.first_name6",
            "select players.country_code, t0.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the code for the country with the largest player base., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the code for the country with the highest number of players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the code for the country with the highest number of players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, players.birth_date",
            "select players.country_code, t0.c6",
            "select players.country_code, players.last_name",
            "select players.country_code, players.hand",
            "select players.country_code, players.first_name",
            "select players.country_code, t0.c7",
            "select players.country_code, players.first_name6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the code for the country with the highest number of players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the code of the country with the most players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the code of the country with the most players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, players.birth_date",
            "select players.country_code, t0.c6",
            "select players.country_code, players.last_name",
            "select players.country_code, players.hand",
            "select players.country_code, players.first_name",
            "select players.country_code, t0.c7",
            "select players.country_code, players.first_name6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the code of the country with the most players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the code of the country with the highest number of players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the code of the country with the highest number of players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, players.birth_date",
            "select players.country_code, players.first_name, players.last_name",
            "select players.country_code, t0.c6",
            "select players.country_code, players.last_name",
            "select players.country_code dec1, players.last_name",
            "select players.country_code, players.last_name, players.hand",
            "select players.country_code, players.hand"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the code of the country with the highest number of players., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the code of the country where the largest number of players reside., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the code of the country where the largest number of players reside., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, players.birth_date",
            "select players.country_code, t0.c6",
            "select players.country_code, players.hand",
            "select players.country_code, players.last_name",
            "select players.country_code, players.first_name",
            "select players.country_code, t0.c7",
            "select players.country_code, t0.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the code of the country where the largest number of players reside., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the count of players for each hand type?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDINATE-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY (t0.c3)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the count of players for each hand type?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c3, count(*)",
        "label": "select count(*), t0.c3",
        "score": false,
        "real_pred": "select players.hand, count(*)",
        "real_label": "select count(*), players.hand",
        "topk_preds": [
            "select players.hand, count(*)",
            "select count(*), players.hand",
            "select players.hand, count(*), players.birth_date",
            "select players.hand, count(*), players.player_id",
            "select players.hand, count(*), players.last_name",
            "select players.first_name, players.hand",
            "select players.first_name, players.hand, count(*)",
            "select players.last_name, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the count of players for each hand type?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What\u2019s the player count for each country?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY (t0.c5)",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-GROUP BY (approx. 5000)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What\u2019s the player count for each country?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5, count(*)",
        "label": "select count(*), t0.c5",
        "score": false,
        "real_pred": "select players.country_code, count(*)",
        "real_label": "select count(*), players.country_code",
        "topk_preds": [
            "select players.country_code, count(*)",
            "select count(*), players.country_code",
            "select country_code, count(*)",
            "select players.country_code.c0, count(*)",
            "select players.country_code, count(*)",
            "select country players.country_code, count(*)",
            "select counts(*), players.country_code",
            "select players.country_code, count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What\u2019s the player count for each country?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of left handed winners who participated in the WTA Championships?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE I count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of left handed winners who participated in the WTA Championships?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(distinct t1.c27)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(distinct matches.winner_name)",
        "topk_preds": [
            "select count(*)",
            "select count(*), matches.winner_entry",
            "select count(distinct matches.winner_entry)",
            "select count(distinct matches.loser_age)",
            "select count(distinct matches.winner_hand)",
            "select count(*), matches.tourney_name",
            "select t1.c count(*)",
            "select count(*), matches.winner_hand"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of left handed winners who participated in the WTA Championships?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "players matches",
            "matches rankings",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the count of left-handed winners who have competed in the WTA Championships., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-COUNT(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the count of left-handed winners who have competed in the WTA Championships., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(distinct t1.c27)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(distinct matches.winner_name)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct matches.loser_age)",
            "select count(distinct matches.winner_hand)",
            "select count(distinct matches.winner_entry)",
            "select count(distinct matches.winner_id)",
            "select count(distinct matches.loser_ht)",
            "select count(*), matches.winner_entry",
            "select count(distinct matches.loser_id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the count of left-handed winners who have competed in the WTA Championships., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (WTA Championships), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "players matches",
            "",
            "",
            "matches rankings",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and ranks of the players with the most number of wins., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and ranks of the players with the most number of wins., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2, t2.c1",
        "label": "select t1.c27, t1.c29",
        "score": false,
        "real_pred": "select players.first_name, players.last_name, rankings.ranking",
        "real_label": "select matches.winner_name, matches.winner_rank_points",
        "topk_preds": [
            "select players.first_name, players.last_name, rankings.ranking",
            "select players.first_name, players.last_name, players.first_name, rankings.ranking",
            "select players.first_name, players.last_name, players.first_name, players.last_name, rankings.ranking",
            "select players.first_name, players.last_name, players.first_name",
            "select players.first_name, players.last_name, rankings.ranking, players.hand",
            "select players.first_name, players.last_name, matches.winner_rank",
            "select players.first_name, players.last_name, t2",
            "select rankings.ranking, players.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and ranks of the players with the most number of wins., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "players matches rankings",
        "real_label": "matches",
        "topk_preds": [
            "players matches rankings",
            "players matches",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the country code with over fifty players?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the country code with over fifty players?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select players.country_code",
        "real_label": "select players.country_code",
        "topk_preds": [
            "select players.country_code",
            "select players.country_code, t0.c6",
            "select players.country_code, players.birth_date",
            "select players.country_code, players.last_name",
            "select players.country_code, players.first_name",
            "select players.country_code, players.hand",
            "select players.country_code, t0.c7",
            "select players.country_code, t0.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the country code with over fifty players?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "players matches",
            "players rankings",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The player list shows the first and last name in the birth order., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, t0.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The player list shows the first and last name in the birth order., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select players.first_name, players.last_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name in players.birth_date",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.last_name (in players.birth_date)",
            "select players.first_name, players.last_name (according to players.birth_date)",
            "select players.first_name.c1, players.last_name",
            "select players.first_name, players.last_name (birth_order)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The player list shows the first and last name in the birth order., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Last), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "players",
        "real_label": "players",
        "topk_preds": [
            "players",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all tournaments with 11+ matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all tournaments with 11+ matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name,",
            "select matches.winner_age",
            "select matches.tourney_date",
            "select matches.loser_age",
            "select matches.winner_entry",
            "select matches.winner_seed",
            "select t1.c 20"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all tournaments with 11+ matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of the names of losers?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM t1.c8",
            "SELECT-FROM t1.C8",
            "SELECT-FROM the count(*)",
            "SELECT-FROM (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of the names of losers?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(distinct t1.c8)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(distinct matches.loser_name)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct matches.loser_name)",
            "select count(*), matches.loser_name",
            "select count(matches.loser_name)",
            "select count(*), matches.loser_ioc",
            "select count(*) (matches.loser_name)",
            "select count(*), matches.loser_id",
            "select count(distinct matches.loser_ioc)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of the names of losers?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "players matches",
            "",
            "",
            "",
            "",
            "matches rankings"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: find the first name, country code and birth date of the winner who has the most points in all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: find the first name, country code and birth date of the winner who has the most points in all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c5, t0.c4",
        "label": "select t0.c1, t0.c5, t0.c4",
        "score": true,
        "real_pred": "select players.first_name, players.country_code, players.birth_date",
        "real_label": "select players.first_name, players.country_code, players.birth_date",
        "topk_preds": [
            "select players.first_name, players.country_code, players.birth_date",
            "select players.first_name, players.birth_date, players.country_code",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.country_code, players.birth_date",
            "select players.first_name, players.hand, players.birth_date",
            "select players.first_name, players.country_code), players.birth_date",
            "select players.first_name, players.country_code and players.birth_date",
            "select matches.winner_name, players.country_code, players.birth_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: find the first name, country code and birth date of the winner who has the most points in all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "players matches",
        "real_label": "players matches",
        "topk_preds": [
            "players matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which year had the greatest total number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which year had the greatest total number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c31",
        "label": "select t1.c31",
        "score": true,
        "real_pred": "select matches.year",
        "real_label": "select matches.year",
        "topk_preds": [
            "select matches.year",
            "select matches.year, matches.tourney_date",
            "select matches.year, matches.winner_entry",
            "select matches.year, matches.loser_age",
            "select matches.year, matches.tourney_name",
            "select matches.year, matches.winner_hand",
            "select matches.year, matches.surface",
            "select matches.year, matches.match_num"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which year had the greatest total number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which year has the largest number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which year has the largest number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c31",
        "label": "select t1.c31",
        "score": true,
        "real_pred": "select matches.year",
        "real_label": "select matches.year",
        "topk_preds": [
            "select matches.year",
            "select matches.year, matches.winner_entry",
            "select matches.year, matches.tourney_date",
            "select matches.year, matches.match_num",
            "select matches.year, matches.loser_age",
            "select matches.year (matches.match_num)",
            "select matches.year, matches.winner_hand",
            "select matches.year, matches.tourney_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which year has the largest number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which year had the greatest number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which year had the greatest number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c31",
        "label": "select t1.c31",
        "score": true,
        "real_pred": "select matches.year",
        "real_label": "select matches.year",
        "topk_preds": [
            "select matches.year",
            "select matches.year, matches.tourney_date",
            "select matches.year, matches.winner_entry",
            "select matches.year, matches.loser_age",
            "select matches.year, matches.tourney_name",
            "select matches.year (matches.match_num)",
            "select matches.year, matches.winner_hand",
            "select matches.year, matches.surface"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which year had the greatest number of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name of tournament that has over 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name of tournament that has over 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.tourney_name",
            "select matches.tourney_name, matches.tourney_level"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name of tournament that has over 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of tournament with more than ten results., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of tournament with more than ten results., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name, matches.tourney_name",
            "select matches.tourney_name (matches.tourney_date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of tournament with more than ten results., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "matches rankings",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name of tournament with greater than 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name of tournament with greater than 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c20",
        "label": "select t1.c20",
        "score": true,
        "real_pred": "select matches.tourney_name",
        "real_label": "select matches.tourney_name",
        "topk_preds": [
            "select matches.tourney_name",
            "select matches.tourney_name, matches.winner_hand",
            "select matches.tourney_name, matches.tourney_date",
            "select matches.tourney_name, matches.winner_age",
            "select matches.tourney_name, matches.winner_entry",
            "select matches.tourney_name, matches.tourney_name",
            "select matches.tourney_name, matches.minutes",
            "select matches.tourney_name, matches.tourney_level"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name of tournament with greater than 10 matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the mean age of the losers and winners of all the matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the mean age of the losers and winners of all the matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select avg(t1.c2), avg(t1.c21)",
        "label": "select avg(t1.c2), avg(t1.c21)",
        "score": true,
        "real_pred": "select avg(matches.loser_age), avg(matches.winner_age)",
        "real_label": "select avg(matches.loser_age), avg(matches.winner_age)",
        "topk_preds": [
            "select avg(matches.loser_age), avg(matches.winner_age)",
            "select avg(matches.loser_age), avg(matches.winner_age",
            "select avg(matches.loser_age), avg(matches.loser_age)",
            "select avg(matches.loser_age), avg(matches.loser_entry)",
            "select avg(matches.loser_age)., avg(matches.winner_age)",
            "select avg(matches.loser_age), avg(matches.draw_size)",
            "select avg(matches.loser_age), avg(matches.winner_hand)",
            "select avg(matches.loser_age), matches.winner_age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the mean age of the losers and winners of all the matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which are the top rankings of all players on the losing side?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ON-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ON-GROUP BY-HAVING",
            "SELECT-FROM-ON-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which are the top rankings of all players on the losing side?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t2.c1",
        "label": "select min(t1.c9)",
        "score": false,
        "real_pred": "select rankings.ranking",
        "real_label": "select min(matches.loser_rank)",
        "topk_preds": [
            "select rankings.ranking",
            "select rankings.ranking, matches.loser_id",
            "select max(rankings.ranking)",
            "select rankings.ranking, matches.loser_name",
            "select rankings.ranking, matches.loser_age",
            "select rankings.ranking, matches.loser_ioc",
            "select rankings.ranking, matches.loser_rank",
            "select rankings.ranking, matches.best_of"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which are the top rankings of all players on the losing side?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "matches rankings",
        "real_label": "matches",
        "topk_preds": [
            "matches rankings",
            "players matches rankings",
            "",
            "matches",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), matches.match_num",
            "select t1.c count(*)",
            "select count(*), matches.minutes",
            "select count(*), matches.draw_size",
            "select count(*), matches.loser_id",
            "select count(*), matches.best_of",
            "select count(*) (matches.match_num)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of matches?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "matches rankings",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the ship id and name that had the highest total injury count?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t1.c1, t1.c2",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT - SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the ship id and name that had the highest total injury count?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select ship.id, ship.name",
        "real_label": "select ship.id, ship.name",
        "topk_preds": [
            "select ship.id, ship.name",
            "select ship.id, ship.name, ship.tonnage",
            "select ship.id, ship.name, ship.ship_type",
            "select death.id, ship.name",
            "select t1, ship.id, ship.name",
            "select ship.id, ship.name, ship.lost_in_battle",
            "select ship.lost_in_battle, ship.name",
            "select ship.id, ship.name, ship.location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the ship id and name that had the highest total injury count?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "ship death",
        "real_label": "ship death",
        "topk_preds": [
            "ship death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the ship ID and name that had the highest number of total injuries., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT - SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT - UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the ship ID and name that had the highest number of total injuries., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select ship.id, ship.name",
        "real_label": "select ship.id, ship.name",
        "topk_preds": [
            "select ship.id, ship.name",
            "select ship.id, ship.name, ship.tonnage",
            "select death.id, ship.name",
            "select ship.id, ship.name, ship.ship_type",
            "select ship.lost_in_battle, ship.name",
            "select ship.id.c2, ship.id",
            "select ship.id, ship.name, ship.lost_in_battle",
            "select ship.id, ship.name, ship.location"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the ship ID and name that had the highest number of total injuries., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "ship death",
        "real_label": "ship death",
        "topk_preds": [
            "ship death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest and smallest death toll caused each time?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM",
            "SELECT-FROM for t2.c0, max(t2.c3), min(t2.c3)",
            "SELECT-FROM for t2.c1, max(t2.c3), min(t2.c3)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-VARIATIONS-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest and smallest death toll caused each time?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select max(t2.c3), min(t2.c3), t2.c0",
        "label": "select max(t2.c3), min(t2.c3)",
        "score": false,
        "real_pred": "select max(death.killed), min(death.killed), death.caused_by_ship_id",
        "real_label": "select max(death.killed), min(death.killed)",
        "topk_preds": [
            "select max(death.killed), min(death.killed), death.caused_by_ship_id",
            "select max(death.killed), min(death.killed), battle.name",
            "select death.caused_by_ship_id, max(death.killed), min(death.killed)",
            "select max(death.killed), min(death.killed), death.id",
            "select max(death.killed), min(death.killed), battle.bulgarian_commander",
            "select death.id, max(death.killed), min(death.killed)",
            "select max(death.killed), min(death.killed), battle.latin_commander",
            "select max(death.killed), min(death.killed), death.injured"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest and smallest death toll caused each time?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "death",
        "real_label": "death",
        "topk_preds": [
            "death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the greatest and lowest numbers of deaths each time?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM for t2.c1, max(t2.c3), min(t2.c3)",
            "SELECT-FROM for each t2.c1, max(t2.c3), min(t2.c3)",
            "SELECT-FROM",
            "SELECT-FROM for t2.c0, max(t2.c3), min(t2.c3)",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM for t2.c1, max(t2.c4), min(t2.c3)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the greatest and lowest numbers of deaths each time?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select max(t2.c3), min(t2.c3), t2.c0",
        "label": "select max(t2.c3), min(t2.c3)",
        "score": false,
        "real_pred": "select max(death.killed), min(death.killed), death.caused_by_ship_id",
        "real_label": "select max(death.killed), min(death.killed)",
        "topk_preds": [
            "select max(death.killed), min(death.killed), death.caused_by_ship_id",
            "select max(death.killed), min(death.killed), death.id",
            "select max(death.killed), min(death.killed), death.injured",
            "select death.id, max(death.killed), min(death.killed)",
            "select max(death.killed), min(death.killed), battle.name",
            "select death.caused_by_ship_id, max(death.killed), min(death.killed)",
            "select max(death.killed), min(death.killed), t2.c6",
            "select max(death.killed), min(death.killed), t2.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the greatest and lowest numbers of deaths each time?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "death",
        "real_label": "death",
        "topk_preds": [
            "death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the highest and lowest number of deaths per incident?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM t2.c1, max(t2.c3), min(t2.c3)",
            "SELECT-FROM t2.c0, max(t2.c3), min(t2.c3)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM t2.c1, max(t2.c3), min(t2.c3)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the highest and lowest number of deaths per incident?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select max(t2.c3), min(t2.c3)",
        "label": "select max(t2.c3), min(t2.c3)",
        "score": true,
        "real_pred": "select max(death.killed), min(death.killed)",
        "real_label": "select max(death.killed), min(death.killed)",
        "topk_preds": [
            "select max(death.killed), min(death.killed)",
            "select max(death.injured), min(death.killed)",
            "select max(death.killed), min(death.killed), death.caused_by_ship_id",
            "select max(t2.c6), min(death.killed)",
            "select max(death.killed), min(death.killed) per death.caused_by_ship_id",
            "select max(t2.c5), min(death.killed)",
            "select max(t2.c8), min(death.killed)",
            "select max(t2.c7), min(death.killed)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the highest and lowest number of deaths per incident?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "death",
        "real_label": "death",
        "topk_preds": [
            "death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the most recent transcript released?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the most recent transcript released?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "select t10.c5",
        "label": "select t9.c1",
        "score": false,
        "real_pred": "select t10.c5",
        "real_label": "select Transcripts.transcript_date",
        "topk_preds": [
            "select t10.c5",
            "select t9.c5",
            "select max(t10.c5)",
            "select max(t10.c6)",
            "select t8.c5",
            "select t12.c5",
            "select t11.c3",
            "select max(t9.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the most recent transcript released?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the most recent transcript release date?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the most recent transcript release date?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "select t8.c5",
        "label": "select t9.c1",
        "score": false,
        "real_pred": "select t8.c5",
        "real_label": "select Transcripts.transcript_date",
        "topk_preds": [
            "select t8.c5",
            "select t12.c5",
            "select max(t8.c6)",
            "select t9.c5",
            "select max(t8.c5)",
            "select t14.c5",
            "select t10.c5",
            "select max(t8.c7)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the most recent transcript release date?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "",
            "",
            "",
            "",
            "Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the degree summary name with the most enrolled students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the degree summary name with the most enrolled students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.student_id",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id",
            "select Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id3",
            "select Degree_Programs.degree_summary_name (Student_Enrolment.degree_program_id)",
            "select Degree_Programs.degree_summary_name (or Degree_Programs.degree_summary_description)",
            "select Degree_Programs.degree_summary_name, t7.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the degree summary name with the most enrolled students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Courses Degree_Programs Student_Enrolment",
            "Departments Student_Enrolment",
            "Addresses Degree_Programs Student_Enrolment",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of the degree summary with the largest number of students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of the degree summary with the largest number of students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id",
            "select Degree_Programs.degree_summary_name, Students.current_address_id3",
            "select Degree_Programs.degree_summary_name, Students.other_student_details",
            "select Degree_Programs.degree_summary_name, Students.current_address_id",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id3",
            "select Degree_Programs.degree_summary_name, Students.email_address"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of the degree summary with the largest number of students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "t3 t6",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "Degree_Programs Students Student_Enrolment_Courses",
            "Degree_Programs Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Departments Students Student_Enrolment_Courses",
            "Departments Students",
            "Degree_Programs Semesters Students",
            "Degree_Programs Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the degree summaries with the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the degree summaries with the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.student_id",
            "select Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id3",
            "select Degree_Programs.degree_program_id, Degree_Programs.department_id",
            "select Degree_Programs.degree_summary_name (Student_Enrolment.degree_program_id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the degree summaries with the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Addresses Degree_Programs Student_Enrolment",
            "Departments Student_Enrolment",
            "",
            "Courses Student_Enrolment",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of the degree summary that has the most students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of the degree summary that has the most students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id",
            "select Degree_Programs.degree_summary_name (or Degree_Programs.degree_summary_description)",
            "select Degree_Programs.degree_summary_name (Degree_Programs.degree_summary_description)",
            "select Degree_Programs.degree_summary_name, Students.current_address_id3",
            "select Degree_Programs.degree_summary_name, Students.other_student_details",
            "select Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of the degree summary that has the most students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "t3 t6",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "Degree_Programs Students Student_Enrolment_Courses",
            "Degree_Programs Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Degree_Programs Semesters Students",
            "",
            "Departments Students Student_Enrolment_Courses",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the degree summary name with the greatest number of students enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the degree summary name with the greatest number of students enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.student_id",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id, Student_Enrolment.semester_id",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id, Student_Enrolment.student_id",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id, Students.permanent_address_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the degree summary name with the greatest number of students enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Courses Degree_Programs Student_Enrolment",
            "Departments Student_Enrolment",
            "Addresses Degree_Programs Student_Enrolment",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the most-enrolled-student-degree-summary name?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-VARIATION-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the most-enrolled-student-degree-summary name?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id3",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id",
            "select Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.student_id",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id2",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id1",
            "select Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the most-enrolled-student-degree-summary name?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Courses Degree_Programs Student_Enrolment",
            "Addresses Degree_Programs Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "",
            "Degree_Programs Student_Enrolment Student_Enrolment_Courses",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the address that currently has the most students and show me the address and all the lines., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-VARIATION-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-T0-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the address that currently has the most students and show me the address and all the lines., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment",
        "prediction": "select t0.c0, t0.c1, t0.c2",
        "label": "select t0.c0, t0.c1, t0.c2",
        "score": true,
        "real_pred": "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
        "real_label": "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
        "topk_preds": [
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
            "select Addresses.line_1, Addresses.line_2, Addresses.line_3",
            "select Addresses.line_1, Addresses.line_2",
            "select Addresses.other_address_details, Addresses.line_1, Addresses.line_2",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_3",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2, Addresses.line_3",
            "select Addresses.other_address_details, Addresses.line_1, Addresses.line_3",
            "select Addresses.line_1, Addresses.line_3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the address that currently has the most students and show me the address and all the lines., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "t0 t6",
        "label": "t0 t6",
        "score": true,
        "real_pred": "Addresses Students",
        "real_label": "Addresses Students",
        "topk_preds": [
            "Addresses Students",
            "Addresses Students Student_Enrolment",
            "Addresses Students Student_Enrolment_Courses",
            "Addresses Semesters Students",
            "Addresses Courses Students",
            "Addresses Student_Enrolment",
            "Addresses Sections Students",
            "Addresses Students Transcripts"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which address holds the most students? List the address id and all the lines., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which address holds the most students? List the address id and all the lines., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t0.c0, t0.c1, t0.c2",
        "label": "select t0.c0, t0.c1, t0.c2",
        "score": true,
        "real_pred": "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
        "real_label": "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
        "topk_preds": [
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_3",
            "select Addresses.address_id, Addresses.line_1",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2, t0.3",
            "select Addresses.address_id, Addresses.line_2, Addresses.line_3",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2, Addresses.line_3",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2, Addresses.line_3",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_1"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which address holds the most students? List the address id and all the lines., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t0 t6",
        "label": "t0 t6",
        "score": true,
        "real_pred": "Addresses Students",
        "real_label": "Addresses Students",
        "topk_preds": [
            "Addresses Students",
            "Addresses Students Student_Enrolment_Courses",
            "Addresses Students Student_Enrolment",
            "Addresses Semesters Students",
            "Addresses Courses Students",
            "Addresses Sections Students",
            "Addresses Student_Enrolment",
            "Addresses Students Transcripts"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the address id and all lines for the address with the most students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the address id and all lines for the address with the most students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t0.c0, t0.c1, t0.c2",
        "label": "select t0.c0, t0.c1, t0.c2",
        "score": true,
        "real_pred": "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
        "real_label": "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
        "topk_preds": [
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_3",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2, Addresses.line_3",
            "select Addresses.address_id, Addresses.line_2, Addresses.line_3",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2, t0.3",
            "select Addresses.line_1, Addresses.line_2, Addresses.line_3",
            "select student_Addresses.address_id, Addresses.line_1, Addresses.line_2",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2, Addresses.line_3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the address id and all lines for the address with the most students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t0 t6",
        "label": "t0 t6",
        "score": true,
        "real_pred": "Addresses Students",
        "real_label": "Addresses Students",
        "topk_preds": [
            "Addresses Students",
            "",
            "",
            "",
            "",
            "Addresses Students Student_Enrolment",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the program id and summary of the degree that has the largest number of students enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t3.c2, t3.c3",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the program id and summary of the degree that has the largest number of students enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_",
        "prediction": "select t3.c0, t3.c3",
        "label": "select t3.c0, t3.c2",
        "score": false,
        "real_pred": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_description",
        "real_label": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Sections.section_id, Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Sections.section_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_program_id, Degree_Programs.department_id, Degree_Programs.degree_summary_description",
            "select Semesters.semester_name, Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_program_id, Degree_Programs.other_details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the program id and summary of the degree that has the largest number of students enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "",
            "Courses Degree_Programs Student_Enrolment",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the program ID and its summary for the degree that has the largest number of students enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEO-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the program ID and its summary for the degree that has the largest number of students enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_en",
        "prediction": "select t3.c0, t3.c2",
        "label": "select t3.c0, t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Student_Enrolment.degree_program_id, Degree_Programs.degree_summary_name",
            "select Student_Enrolment.degree_program_id, Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_program_id, Degree_Programs.other_details",
            "select Degree_Programs.department_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.department_id, Degree_Programs.degree_summary_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the program ID and its summary for the degree that has the largest number of students enrolled., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "",
            "Courses Degree_Programs Student_Enrolment",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the program id and summary for the degree that has the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GIG-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the program id and summary for the degree that has the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t3.c0, t3.c2",
        "label": "select t3.c0, t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Student_Enrolment.degree_program_id, Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Student_Enrolment.degree_program_id, Degree_Programs.degree_summary_name",
            "select Student_Enrolment.semester_id, Degree_Programs.degree_summary_description",
            "select Degree_Programs.department_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_program_id, Degree_Programs.other_details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the program id and summary for the degree that has the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "",
            "",
            "",
            "Courses Degree_Programs Student_Enrolment",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What\u2019s the program id and its summary of the degree that has the largest student enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t3.c2, t3.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What\u2019s the program id and its summary of the degree that has the largest student enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_en",
        "prediction": "select t3.c0, t3.c3",
        "label": "select t3.c0, t3.c2",
        "score": false,
        "real_pred": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_description",
        "real_label": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_program_id, Degree_Programs.department_id, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_program_id, Degree_Programs.other_details",
            "select Degree_Programs.degree_program_id, Degree_Programs.department_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.department_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.department_id, Degree_Programs.degree_summary_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What\u2019s the program id and its summary of the degree that has the largest student enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "",
            "Courses Degree_Programs Student_Enrolment",
            "",
            "",
            "Addresses Degree_Programs Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Describe all students in reverse order., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY(t6.c0)",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Describe all students in reverse order., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "select t6.c11",
        "label": "select t6.c11",
        "score": true,
        "real_pred": "select Students.other_student_details",
        "real_label": "select Students.other_student_details",
        "topk_preds": [
            "select Students.other_student_details",
            "select Students.last_name, Students.first_name",
            "select Students.last_name, Students.cell_mobile_number",
            "select Students.current_address_id3, Students.current_address_id4",
            "select Students.current_address_id, Students.last_name",
            "select Students.date_first_registered, Students.date_left",
            "select Students.current_address_id, Students.permanent_address_id",
            "select Students.middle_name, Students.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Describe all students in reverse order., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "Students Student_Enrolment_Courses",
            "Students Student_Enrolment",
            "Semesters Students",
            "",
            "Courses Students",
            "Sections Students",
            "Degree_Programs Students"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find what is the id, line 1, and line 2 for the address with the highest student count?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find what is the id, line 1, and line 2 for the address with the highest student count?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_",
        "prediction": "select t0.c0, t0.c1, t0.c2",
        "label": "select t0.c0, t0.c1, t0.c2",
        "score": true,
        "real_pred": "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
        "real_label": "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
        "topk_preds": [
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
            "select student_Addresses.address_id, Addresses.line_1, Addresses.line_2",
            "select Addresses.other_address_details, Addresses.line_1, Addresses.line_2",
            "select Addresses.line_1, Addresses.line_2, Addresses.line_3",
            "select Departments.department_id, Addresses.line_1, Addresses.line_2",
            "select Courses.course_id, Addresses.line_1, Addresses.line_2",
            "select Students.student_id, Addresses.line_1, Addresses.line_2",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find what is the id, line 1, and line 2 for the address with the highest student count?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "t0 t6",
        "label": "t0 t6",
        "score": true,
        "real_pred": "Addresses Students",
        "real_label": "Addresses Students",
        "topk_preds": [
            "Addresses Students",
            "Addresses Students Student_Enrolment",
            "Addresses Student_Enrolment",
            "Addresses Students Student_Enrolment_Courses",
            "Addresses Courses Departments Students",
            "Addresses Semesters Students",
            "Addresses Courses Departments Student_Enrolment",
            "Addresses Courses Students"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the earliest transcript released? List the data and details., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the earliest transcript released? List the data and details., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "select t8.c1, t8.c2",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id",
            "select Student_Enrolment_Courses.student_course_id, t8.c3",
            "select Student_Enrolment_Courses.student_course_id, Student_Enrolment_Courses.student_enrolment_id",
            "select Student_Enrolment.degree_program_id, Student_Enrolment.semester_id",
            "select Student_Enrolment.student_enrolment_id, Student_Enrolment.semester_id",
            "select t8.c5, t8.c6",
            "select Transcripts.transcript_id, t9.c3",
            "select Student_Enrolment.student_enrolment_id, Student_Enrolment.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the earliest transcript released? List the data and details., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "",
            "",
            "",
            "Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the date of the latest transcript release?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the date of the latest transcript release?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select t8.c5",
        "label": "select t9.c1",
        "score": false,
        "real_pred": "select t8.c5",
        "real_label": "select Transcripts.transcript_date",
        "topk_preds": [
            "select t8.c5",
            "select t9.c5",
            "select t10.c5",
            "select max(t8.c6)",
            "select t12.c5",
            "select max(t10.c6)",
            "select max(t9.c6)",
            "select max(t10.c5)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the date of the latest transcript release?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "",
            "",
            "",
            "Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was the last time a transcript was released?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM -ORDER BY-LIMIT",
            "SELECT-FROM'ORDER BY-LIMIT",
            "SELECT-FROM (ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was the last time a transcript was released?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "select t8.c5",
        "label": "select t9.c1",
        "score": false,
        "real_pred": "select t8.c5",
        "real_label": "select Transcripts.transcript_date",
        "topk_preds": [
            "select t8.c5",
            "select t9.c5",
            "select max(t8.c6)",
            "select max(t9.c6)",
            "select t10.c5",
            "select max(t10.c6)",
            "select max(t9.c4)",
            "select max(t10.c5)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was the last time a transcript was released?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "",
            "",
            "",
            "Transcripts Transcript_Contents",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the latest released transcript?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the latest released transcript?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "select t10.c5",
        "label": "select t9.c1",
        "score": false,
        "real_pred": "select t10.c5",
        "real_label": "select Transcripts.transcript_date",
        "topk_preds": [
            "select t10.c5",
            "select t9.c5",
            "select Transcripts.transcript_id",
            "select t8.c5",
            "select Transcripts.transcript_date",
            "select max(t10.c6)",
            "select t9.c6",
            "select Student_Enrolment_Courses.course_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the latest released transcript?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1:",
        "prediction": "t10",
        "label": "t9",
        "score": false,
        "real_pred": "Transcript_Contents",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcript_Contents",
            "Transcripts",
            "Student_Enrolment_Courses",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names and ids of each course with less than two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING ACT-IV-SECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names and ids of each course with less than two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Departments.department_id",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Courses.course_name, Sections.course_id,",
            "select Sections.course_id, Courses.course_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names and ids of each course with less than two sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "",
            "",
            "Courses Departments Sections",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the id and name of all courses that have less than 2 sections?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the id and name of all courses that have less than 2 sections?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_id, Courses.course_name",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_id, Courses.course_name",
            "select Sections.course_id, Courses.course_name",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_id, Courses.course_name, Sections.section_name",
            "select Courses.course_id, Courses.course_name, Courses.course_description",
            "select Departments.department_name, Courses.course_name",
            "select Courses.course_id, Courses.course_name, Sections.course_id",
            "select Courses.course_id, Courses.course_name, Sections.section_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the id and name of all courses that have less than 2 sections?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and ids of every course with no more than one section., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HAVE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HAVE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and ids of every course with no more than one section., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Departments.department_id",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Courses.course_name, Semesters.semester_name",
            "select Courses.course_name, Semesters.semester_id",
            "select Courses.course_name, Sections.section_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and ids of every course with no more than one section., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "Courses Departments Sections",
            "",
            "",
            "Courses Degree_Programs Sections",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the id and date of the transcripts that has the fewest results?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the id and date of the transcripts that has the fewest results?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment",
        "prediction": "select t8.c0, t8.c3",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select Student_Enrolment_Courses.student_course_id, t8.c3",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select Student_Enrolment_Courses.student_course_id, t8.c3",
            "select Student_Enrolment_Courses.course_id, t8.c3",
            "select Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id",
            "select Student_Enrolment_Courses.student_course_id, Student_Enrolment_Courses.course_id",
            "select Student_Enrolment_Courses.student_course_id, t8.c5",
            "select Student_Enrolment_Courses.student_course_id, Student_Enrolment_Courses.student_enrolment_id",
            "select Transcripts.transcript_id, t9.c3",
            "select Student_Enrolment_Courses.student_course_id, Student_Enrolment_Courses.course_id3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the id and date of the transcripts that has the fewest results?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "t9",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Transcripts",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the date and ID of the transcript with the lowest number of results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the date and ID of the transcript with the lowest number of results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t8.c5, t8.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t8.c5, Student_Enrolment_Courses.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t12.c5, t12.c0",
            "select t8.c5, t8.c6",
            "select t12.c3, t12.c4",
            "select t14.c5, t14.c0",
            "select t14.c3, t14.c4",
            "select t9.c5, Transcripts.transcript_id",
            "select t12.c3, t12.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the date and ID of the transcript with the lowest number of results., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the sections in descending order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY t4.c2",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the sections in descending order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "select t4.c2",
        "label": "select t4.c2",
        "score": true,
        "real_pred": "select Sections.section_name",
        "real_label": "select Sections.section_name",
        "topk_preds": [
            "select Sections.section_name",
            "select Sections.section_name, Sections.section_description",
            "select Sections.section_name, Sections.section_description, Sections.other_details",
            "select Sections.course_id, Sections.section_name",
            "select Sections.section_name (ordered Sections.section_description)",
            "select Sections.section_name, Sections.course_id, Sections.section_description",
            "select Sections.section_name, Sections.course_id, Sections.section_name",
            "select Sections.section_name, Sections.section_description, Sections.section_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the sections in descending order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Sections",
        "real_label": "Sections",
        "topk_preds": [
            "Sections",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the list of the sections sorted by name, ordered by descending sequence of letter?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ASCENDING-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-CHROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-HEADING-ORDER BY",
            "SELECT-FROM-ORDER BY t4.c2",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ASCENDING-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the list of the sections sorted by name, ordered by descending sequence of letter?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrol",
        "prediction": "select t4.c2",
        "label": "select t4.c2",
        "score": true,
        "real_pred": "select Sections.section_name",
        "real_label": "select Sections.section_name",
        "topk_preds": [
            "select Sections.section_name",
            "select Sections.section_name, Sections.course_id",
            "select Sections.section_id, Sections.section_name",
            "select Sections.section_name, Sections.section_description",
            "select Sections.course_id, Sections.section_name",
            "select Sections.section_name, Sections.section_id",
            "select Sections.section_name, t4.c7",
            "select Sections.section_name, Sections.other_details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the list of the sections sorted by name, ordered by descending sequence of letter?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Sections",
        "real_label": "Sections",
        "topk_preds": [
            "Sections",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the date when the transcripts with the smallest number of results were recorded, show their IDs too., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the date when the transcripts with the smallest number of results were recorded, show their IDs too., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student",
        "prediction": "select t12.c5, t12.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t12.c5, t12.c0",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t12.c5, t12.c0",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t8.c5, Student_Enrolment.student_enrolment_id",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t8.c5, t8.c6",
            "select t9.c5, Transcripts.transcript_id",
            "select t8.c5, Transcripts.transcript_id",
            "select t12.c5, t12.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the date when the transcripts with the smallest number of results were recorded, show their IDs too., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "",
            "Transcript_Contents",
            "Semesters Student_Enrolment",
            "Student_Enrolment",
            "",
            "Semesters Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date of the transcript which has the fewest results. List its id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date of the transcript which has the fewest results. List its id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment",
        "prediction": "select t8.c5, t8.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t8.c5, Student_Enrolment_Courses.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t8.c5, t8.c6",
            "select t9.c5, Transcripts.transcript_id",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t8.c5, Transcripts.transcript_id",
            "select t10.c5, t10.c6",
            "select t12.c5, t12.c0",
            "select t14.c5, t14.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date of the transcript which has the fewest results. List its id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "t9",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Transcripts",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "",
            "Semesters Student_Enrolment_Courses",
            "",
            "Semesters Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date of the transcript with the lowest number of results, also list the id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GEORGE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date of the transcript with the lowest number of results, also list the id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrol",
        "prediction": "select t8.c5, t8.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t8.c5, Student_Enrolment_Courses.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t12.c5, t12.c0",
            "select t8.c5, t8.c6",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t14.c5, t14.c0",
            "select t9.c5, Transcripts.transcript_id",
            "select t8.c3, Student_Enrolment_Courses.student_course_id",
            "select t12.c3, t12.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date of the transcript with the lowest number of results, also list the id., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "Transcript_Contents",
            "",
            "",
            "Semesters Student_Enrolment",
            "Semesters Student_Enrolment_Courses",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which semester had the largest number of students registered? Show both the name and the ID., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GEORGE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which semester had the largest number of students registered? Show both the name and the ID., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t5.c1, t7.c0",
        "label": "select t5.c1, t5.c0",
        "score": false,
        "real_pred": "select Semesters.semester_name, Student_Enrolment.student_enrolment_id",
        "real_label": "select Semesters.semester_name, Semesters.semester_id",
        "topk_preds": [
            "select Semesters.semester_name, Student_Enrolment.student_enrolment_id",
            "select Semesters.semester_name, Semesters.semester_id",
            "select Semesters.semester_name, Student_Enrolment.degree_program_id",
            "select Semesters.semester_name, Student_Enrolment.semester_id",
            "select Semesters.semester_name, Student_Enrolment.student_enrolment_id2",
            "select Semesters.semester_name, Students.student_id",
            "select Semesters.semester_name, t07.c0",
            "select Semesters.semester_name, t7.5.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which semester had the largest number of students registered? Show both the name and the ID., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Semesters Student_Enrolment",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Semesters Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "",
            "Departments Semesters Student_Enrolment",
            "Degree_Programs Semesters Student_Enrolment",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first name of the student whose permanent address is not his or her current one?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first name of the student whose permanent address is not his or her current one?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrol",
        "prediction": "select t6.c3",
        "label": "select t6.c3",
        "score": true,
        "real_pred": "select Students.first_name",
        "real_label": "select Students.first_name",
        "topk_preds": [
            "select Students.first_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name",
            "select Students.student_id, Students.first_name",
            "select Students.first_name, Students.last_name",
            "select Students.first_name, Students.last_name, Students.cell_mobile_number",
            "select Students.first_name, Students.last_name, Students.ssn",
            "select Students.first_name, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first name of the student whose permanent address is not his or her current one?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "Addresses Students",
            "Semesters Students",
            "Students Student_Enrolment_Courses",
            "Degree_Programs Students",
            "Sections Students",
            "Departments Students",
            "Courses Students"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the program which has the largest number of students enrolled in it. List both the id and the summary., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_en",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the program which has the largest number of students enrolled in it. List both the id and the summary., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7",
        "prediction": "select t3.c0, t3.c2",
        "label": "select t3.c0, t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.department_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_program_id, Degree_Programs.other_details",
            "select Departments.department_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_program_id, Courses.course_description",
            "select Departments.department_name, Degree_Programs.degree_summary_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the program which has the largest number of students enrolled in it. List both the id and the summary., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrol",
        "prediction": "t1 t3 t7",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Courses Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Courses Degree_Programs Student_Enrolment",
            "Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Courses Departments Degree_Programs Student_Enrolment",
            "Addresses Degree_Programs Student_Enrolment",
            "Semesters Student_Enrolment",
            "Sections Student_Enrolment",
            "Courses Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which program has the greatest number of enrolled students and give their IDs and summaries?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t3.c2",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT AND DISCUSS-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which program has the greatest number of enrolled students and give their IDs and summaries?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrol",
        "prediction": "select t3.c0, t3.c2",
        "label": "select t3.c0, t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
            "select student_Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
            "select student_Student_Enrolment.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Degree_Programs.department_id, Degree_Programs.degree_summary_name",
            "select Student_Enrolment.degree_program_id, Degree_Programs.degree_summary_name",
            "select Student_Enrolment.degree_program_id, Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select student_Student_Enrolment.student_enrolment_id, Degree_Programs.degree_summary_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which program has the greatest number of enrolled students and give their IDs and summaries?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Courses Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "",
            "Addresses Degree_Programs Student_Enrolment",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the program with most enrollment. List both the id and the summary., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the program with most enrollment. List both the id and the summary., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t3.c0, t3.c2",
        "label": "select t3.c0, t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.department_id, Degree_Programs.degree_summary_name",
            "select Student_Enrolment.degree_program_id, Degree_Programs.degree_summary_name",
            "select Degree_Programs.degree_program_id, Degree_Programs.degree_summary_description",
            "select Degree_Programs.degree_program_id, Degree_Programs.other_details",
            "select Degree_Programs.degree_summary_name, Degree_Programs.degree_summary_description",
            "select Departments.department_id, Degree_Programs.degree_summary_name",
            "select Departments.department_id, Departments.department_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the program with most enrollment. List both the id and the summary., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Courses Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Courses Departments Degree_Programs Student_Enrolment",
            "Addresses Degree_Programs Student_Enrolment",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first name, middle name, last name of the first graduate of the school?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first name, middle name, last name of the first graduate of the school?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name., Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name, Students.ssn",
            "select Students.current_address_id, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first name, middle name, last name of the first graduate of the school?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "t6 t8",
        "label": "t6",
        "score": false,
        "real_pred": "Students Student_Enrolment_Courses",
        "real_label": "Students",
        "topk_preds": [
            "Students Student_Enrolment_Courses",
            "",
            "Students Student_Enrolment",
            "",
            "Students",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each semester show me the name and ID of the class which has the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT - SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each semester show me the name and ID of the class which has the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t1.c1, t4.c0",
        "label": "select t5.c1, t5.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.section_id",
        "real_label": "select Semesters.semester_name, Semesters.semester_id",
        "topk_preds": [
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Student_Enrolment.degree_program_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Student_Enrolment.student_enrolment_id",
            "select Courses.course_name, Semesters.semester_id",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Departments.department_id",
            "select Courses.course_name, Students.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each semester show me the name and ID of the class which has the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t1 t7",
        "label": "t5 t7",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Courses Semesters Student_Enrolment",
            "",
            "Addresses Courses Semesters Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Courses Sections Student_Enrolment",
            "Addresses Courses Student_Enrolment",
            "Courses Sections Semesters Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each semester, what is the name and ID of the one with the largest number of students registered?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each semester, what is the name and ID of the one with the largest number of students registered?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_en",
        "prediction": "select t5.c1, t5.c0",
        "label": "select t5.c1, t5.c0",
        "score": true,
        "real_pred": "select Semesters.semester_name, Semesters.semester_id",
        "real_label": "select Semesters.semester_name, Semesters.semester_id",
        "topk_preds": [
            "select Semesters.semester_name, Semesters.semester_id",
            "select Semesters.semester_name, Student_Enrolment.student_enrolment_id",
            "select Semesters.semester_name, Student_Enrolment.degree_program_id",
            "select Semesters.semester_name, Students.student_id",
            "select Semesters.semester_name, Student_Enrolment.semester_id",
            "select Semesters.semester_name, t5c0",
            "select Semesters.semester_name, t5.5.c0",
            "select Semesters.semester_name, t07.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each semester, what is the name and ID of the one with the largest number of students registered?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Semesters Student_Enrolment",
        "real_label": "Semesters Student_Enrolment",
        "topk_preds": [
            "Semesters Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "Degree_Programs Semesters Student_Enrolment",
            "Departments Semesters Student_Enrolment",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the course with the greatest number of enrollments?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GIG-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the course with the greatest number of enrollments?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select Courses.course_name",
        "real_label": "select Courses.course_name",
        "topk_preds": [
            "select Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select Courses.course_name, Student_Enrolment.degree_program_id",
            "select Courses.course_name, Student_Enrolment.student_id",
            "select Courses.course_name (Student_Enrolment.semester_id)",
            "select Courses.course_name (Courses.course_description)",
            "select Courses.course_name, Courses.course_description",
            "select Courses.course_name(Student_Enrolment.semester_id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the course with the greatest number of enrollments?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Courses Sections Student_Enrolment",
            "Addresses Courses Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Addresses Courses Sections Student_Enrolment",
            "Courses Semesters Student_Enrolment",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the course with the most enrollments?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the course with the most enrollments?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select Courses.course_name",
        "real_label": "select Courses.course_name",
        "topk_preds": [
            "select Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select Courses.course_name, Student_Enrolment.degree_program_id",
            "select Courses.course_name, Student_Enrolment.student_id",
            "select Courses.course_name (Courses.course_description)",
            "select Courses.course_name, Courses.course_description",
            "select Courses.course_name, Sections.section_name",
            "select Courses.course_name, Student_Enrolment.degree_program_id2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the course with the most enrollments?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Courses Sections Student_Enrolment",
            "Addresses Courses Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Addresses Courses Sections Student_Enrolment",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the course id and name with the highest enrollments., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C0-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the course id and name with the highest enrollments., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "select t4.c1, t1.c1",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select Sections.course_id, Courses.course_name",
        "real_label": "select Courses.course_name",
        "topk_preds": [
            "select Sections.course_id, Courses.course_name",
            "select Courses.course_id, Courses.course_name",
            "select Student_Enrolment.degree_program_id, Courses.course_name",
            "select Departments.department_name, Courses.course_name",
            "select Semesters.semester_name, Courses.course_name",
            "select Sections.section_id, Courses.course_name",
            "select Courses.course_name, Courses.course_id",
            "select Departments.department_id, Courses.course_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the course id and name with the highest enrollments., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Courses Sections Student_Enrolment",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and IDs of courses whose sections numbers do not exceed 2., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GHOST-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and IDs of courses whose sections numbers do not exceed 2., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Courses.course_id",
            "select Sections.course_id, Sections.section_id",
            "select Courses.course_name, Departments.department_id",
            "select Courses.course_name, Sections.section_name",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Courses.course_name, Sections.other_details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and IDs of courses whose sections numbers do not exceed 2., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "Courses Departments Sections",
            "Courses Degree_Programs Sections",
            "",
            "",
            "Courses Departments Degree_Programs Sections",
            "Courses Departments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names and ids of courses with two or fewer sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names and ids of courses with two or fewer sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Departments.department_id",
            "select Sections.course_id, Sections.section_id",
            "select Courses.course_name, Sections.other_details",
            "select Courses.course_name, Sections.section_name",
            "select Courses.course_name, Degree_Programs.degree_program_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names and ids of courses with two or fewer sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "",
            "Courses Departments Sections",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the names and IDs of courses with no more than 2 sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING ACT-IV-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the names and IDs of courses with no more than 2 sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Departments.department_id",
            "select Sections.course_id, Sections.section_id",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.course_id,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the names and IDs of courses with no more than 2 sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "",
            "",
            "",
            "",
            "",
            "Courses Departments Sections",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and IDs of courses having two sections or less?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and IDs of courses having two sections or less?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t1.c1, t4.c1",
        "label": "select t1.c1, t1.c0",
        "score": false,
        "real_pred": "select Courses.course_name, Sections.course_id",
        "real_label": "select Courses.course_name, Courses.course_id",
        "topk_preds": [
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Courses.course_id",
            "select Courses.course_name, Sections.section_id",
            "select Courses.course_name, Departments.department_id",
            "select Sections.course_id, Sections.section_id",
            "select Courses.course_name, Degree_Programs.degree_program_id",
            "select Courses.course_name, Sections.course_id",
            "select Courses.course_name, Sections.section_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and IDs of courses having two sections or less?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t1 t4",
        "label": "t1 t4",
        "score": true,
        "real_pred": "Courses Sections",
        "real_label": "Courses Sections",
        "topk_preds": [
            "Courses Sections",
            "Courses Departments Sections",
            "",
            "",
            "",
            "",
            "Courses Degree_Programs Sections",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the date and id of the transcripts that has more or equal to two courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the date and id of the transcripts that has more or equal to two courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_",
        "prediction": "select t14.c3, t14.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t14.c3, t14.c0",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t14.c3, t14.c0",
            "select t14.c3, t14.c4",
            "select t12.c5, t12.c0",
            "select t14.c5, t14.c0",
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t12.c3, t12.c0",
            "select t9.c5, Transcripts.transcript_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the date and id of the transcripts that has more or equal to two courses listed?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "t1 t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Courses Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Courses Student_Enrolment_Courses",
            "Courses Transcripts",
            "Courses Student_Enrolment",
            "",
            "Semesters Student_Enrolment_Courses",
            "Courses Sections",
            "Semesters Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date and ID of the transcript with two or more courses., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date and ID of the transcript with two or more courses., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "select t10.c5, t10.c0",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select t10.c5, Transcript_Contents.student_course_id",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select t10.c5, Transcript_Contents.student_course_id",
            "select t8.c5, Student_Enrolment_Courses.student_course_id",
            "select t9.c5, Transcripts.transcript_id",
            "select t10.c5, t10.c6",
            "select t12.c5, t12.c0",
            "select t14.c3, t14.c0",
            "select t8.c5, t8.c6",
            "select t11.c3, t11.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date and ID of the transcript with two or more courses., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "Transcript_Contents",
            "",
            "",
            "",
            "Courses Student_Enrolment_Courses",
            "Transcripts Transcript_Contents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the id and date of the transcript with no less than 2 courses?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the id and date of the transcript with no less than 2 courses?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t8.c0, t8.c3",
        "label": "select t9.c1, t10.c1",
        "score": false,
        "real_pred": "select Student_Enrolment_Courses.student_course_id, t8.c3",
        "real_label": "select Transcripts.transcript_date, Transcript_Contents.transcript_id",
        "topk_preds": [
            "select Student_Enrolment_Courses.student_course_id, t8.c3",
            "select Student_Enrolment_Courses.course_id, t8.c3",
            "select Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id",
            "select Transcripts.transcript_id, t9.c3",
            "select Student_Enrolment_Courses.student_course_id, t8.c5",
            "select Student_Enrolment_Courses.student_course_id, Student_Enrolment_Courses.course_id",
            "select Transcript_Contents.student_course_id, t10.c3",
            "select Student_Enrolment.student_enrolment_id, Student_Enrolment.student_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the id and date of the transcript with no less than 2 courses?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t8",
        "label": "t9 t10",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts Transcript_Contents",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "Transcript_Contents",
            "Courses Student_Enrolment_Courses",
            "",
            "Semesters Student_Enrolment",
            "Semesters Student_Enrolment_Courses",
            "Courses Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the program type with the highest number of students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the program type with the highest number of students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Degree_Programs.department_id",
            "select Degree_Programs.other_details",
            "select Student_Enrolment.degree_program_id",
            "select Student_Enrolment.semester_id",
            "select Student_Enrolment_Courses.course_id",
            "select t3.c5",
            "select Degree_Programs.degree_summary_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the program type with the highest number of students., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "t3 t6",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Degree_Programs Students",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students",
            "Degree_Programs Students Student_Enrolment",
            "Degree_Programs Student_Enrolment",
            "Degree_Programs Students Student_Enrolment_Courses",
            "Departments Degree_Programs Students",
            "Courses Degree_Programs Students",
            "Departments Degree_Programs Students Student_Enrolment",
            "Courses Degree_Programs Students Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What type of program are most students enrolled in?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GEOGRAPHIE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What type of program are most students enrolled in?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Degree_Programs.degree_summary_name",
        "real_label": "select Degree_Programs.degree_summary_name",
        "topk_preds": [
            "select Degree_Programs.degree_summary_name",
            "select Student_Enrolment.semester_id",
            "select Student_Enrolment.degree_program_id",
            "select Degree_Programs.department_id",
            "select Student_Enrolment_Courses.course_id",
            "select Degree_Programs.other_details",
            "select Semesters.semester_description",
            "select Sections.section_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What type of program are most students enrolled in?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Degree_Programs Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Student_Enrolment",
            "Courses Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Semesters Student_Enrolment",
            "Student_Enrolment",
            "Sections Student_Enrolment",
            "Students Student_Enrolment",
            "Courses Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the code of the course with the highest number of students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the code of the course with the highest number of students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "select t4.c1",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select Sections.course_id",
        "real_label": "select Courses.course_name",
        "topk_preds": [
            "select Sections.course_id",
            "select Sections.course_id, Student_Enrolment.semester_id",
            "select Courses.course_name",
            "select Departments.department_name",
            "select Departments.department_name, Student_Enrolment.semester_id",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select Sections.section_name",
            "select Sections.course_id, Student_Enrolment.degree_program_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the code of the course with the highest number of students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "t4 t6 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Sections Students Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Sections Students Student_Enrolment",
            "Sections Student_Enrolment",
            "Courses Sections Student_Enrolment",
            "Courses Sections Students Student_Enrolment",
            "Courses Sections Students",
            "Sections Students",
            "Departments Sections Students Student_Enrolment",
            "Degree_Programs Sections Students Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of the course with the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GEORGE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of the course with the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select Courses.course_name",
        "real_label": "select Courses.course_name",
        "topk_preds": [
            "select Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select Courses.course_name, Student_Enrolment.semester_id, Courses.other_details",
            "select Courses.course_name, Student_Enrolment.degree_program_id",
            "select Courses.course_name, Student_Enrolment.degree_program_id, Courses.course_description",
            "select Courses.course_name, Student_Enrolment.semester_id, Student_Enrolment.student_id",
            "select Courses.course_name, Student_Enrolment.semester_id, Courses.course_name",
            "select Courses.course_name (Courses.course_description)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of the course with the largest enrollment., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Courses Sections Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Courses Semesters Student_Enrolment",
            "Addresses Courses Sections Student_Enrolment",
            "Addresses Courses Student_Enrolment",
            "Courses Departments Student_Enrolment",
            "Courses Departments Sections Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the course with the largest enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the course with the largest enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select Courses.course_name",
        "real_label": "select Courses.course_name",
        "topk_preds": [
            "select Courses.course_name",
            "select Courses.course_name, Student_Enrolment.semester_id",
            "select Courses.course_name, Student_Enrolment.degree_program_id",
            "select Courses.course_name, Student_Enrolment.student_id",
            "select Courses.course_name, Courses.course_description",
            "select Courses.course_name (Courses.course_description)",
            "select Courses.course_name - Student_Enrolment.semester_id",
            "select Courses.course_name, Sections.section_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the course with the largest enrollment?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "t1 t7",
        "label": "t1 t8",
        "score": false,
        "real_pred": "Courses Student_Enrolment",
        "real_label": "Courses Student_Enrolment_Courses",
        "topk_preds": [
            "Courses Student_Enrolment",
            "Courses Sections Student_Enrolment",
            "Addresses Courses Student_Enrolment",
            "Courses Students Student_Enrolment",
            "Addresses Courses Sections Student_Enrolment",
            "Courses Semesters Student_Enrolment",
            "",
            "Courses Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the median date of the transcripts?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM -GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM ACT-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM -GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the median date of the transcripts?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select t8.c5",
        "label": "select avg(t9.c1)",
        "score": false,
        "real_pred": "select t8.c5",
        "real_label": "select avg(Transcripts.transcript_date)",
        "topk_preds": [
            "select t8.c5",
            "select avg(t10.c5)",
            "select avg(t9.c6)",
            "select avg(t9.c5)",
            "select avg(t8.c9)",
            "select avg(t10.c6)",
            "select avg(t9.c8)",
            "select avg(t8.c5)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the median date of the transcripts?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t10",
        "label": "t9",
        "score": false,
        "real_pred": "Transcript_Contents",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcript_Contents",
            "Transcripts",
            "Student_Enrolment_Courses",
            "",
            "",
            "Transcripts Transcript_Contents",
            "",
            "Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the ID of the TV channels in countries with 3 or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the ID of the TV channels in countries with 3 or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Country, max(TV_Channel.Language)",
            "select TV_Channel.id, TV_Channel.Country, max(TV_Channel.Content)",
            "select TV_Channel.id, TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.id - TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the ID of the TV channels in countries with 3 or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all the TV channels in countries where there are three or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all the TV channels in countries where there are three or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c2",
        "label": "select t0.c0",
        "score": false,
        "real_pred": "select TV_Channel.Country",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.series_name",
            "select TV_Channel.id",
            "select TV_Channel.Content",
            "select TV_Channel.Country, TV_Channel.Content",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.series_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all the TV channels in countries where there are three or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the id of tv channels from countries with three or more tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the id of tv channels from countries with three or more tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Country",
            "select t0.c, TV_Channel.Country",
            "select TV_Channel.id - TV_Channel.Country",
            "select TV_Channel.id TV_Channel.Country",
            "select TV_Channel.series_name",
            "select TV_Channel.id (see TV_Channel.Country)",
            "select TV_Channel.id (or TV_Channel.Country)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the id of tv channels from countries with three or more tv channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all id's for the tv channels that has at least 3 channels from each country., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all id's for the tv channels that has at least 3 channels from each country., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.id dependant on TV_Channel.Country",
            "select TV_Channel.ids, TV_Channel.Country",
            "select TV_Channel.id pour TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.id in TV_Channel.Country",
            "select TV_Channel.id de TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all id's for the tv channels that has at least 3 channels from each country., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series Cartoon",
            "",
            "TV_Channel TV_series",
            "",
            "",
            "",
            "TV_Channel TV_series Cartoon"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the languages and their total counts of television channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY TOTAL(*)",
            "SELECT-FROM-GROUP BY CENTER",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GROUP BY CENTURY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the languages and their total counts of television channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c3, count(*)",
        "label": "select t0.c3, count(*)",
        "score": true,
        "real_pred": "select TV_Channel.Language, count(*)",
        "real_label": "select TV_Channel.Language, count(*)",
        "topk_preds": [
            "select TV_Channel.Language, count(*)",
            "select TV_Channel.Language.c3, count(*)",
            "select TV_Channel.series_name, count(*)",
            "select TV_Channel.Country, count(*)",
            "select TV_Channel.Language, count(*), TV_Channel.Country",
            "select TV_Channel.Language, sum(TV_Channel.Content)",
            "select TV_Channel.Language, sum(TV_Channel.Country)",
            "select TV_Channel.Language, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the languages and their total counts of television channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the languages and list the total count of TV channels using each., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM -GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the languages and list the total count of TV channels using each., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c3, count(*)",
        "label": "select t0.c3, count(*)",
        "score": true,
        "real_pred": "select TV_Channel.Language, count(*)",
        "real_label": "select TV_Channel.Language, count(*)",
        "topk_preds": [
            "select TV_Channel.Language, count(*)",
            "select TV_Channel.Language, count(*), TV_Channel.Country",
            "select TV_Channel.Language.c3, count(*)",
            "select TV_Channel.Language, count(*), http://TV_Channel.Country",
            "select TV_Channel.series_name, count(*)",
            "select TV_Channel.Language, count(*), http://www.TV_Channel.Country",
            "select TV_Channel.Language, count(*), TV_Channel.Content",
            "select TV_Channel.Country, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the languages and list the total count of TV channels using each., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each language, list the total count of TV channels that use it., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM for-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each language, list the total count of TV channels that use it., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c3, count(*)",
        "label": "select t0.c3, count(*)",
        "score": true,
        "real_pred": "select TV_Channel.Language, count(*)",
        "real_label": "select TV_Channel.Language, count(*)",
        "topk_preds": [
            "select TV_Channel.Language, count(*)",
            "select TV_Channel.Language, count(*), TV_Channel.Country",
            "select TV_Channel.Language.c3, count(*)",
            "select count(*), TV_Channel.Language",
            "select TV_Channel.Language, count(*)",
            "select TV_Channel.Language, count(*), http://TV_Channel.Country",
            "select TV_Channel.Language, count(*), TV_Channel.Content",
            "select TV_Channel.series_name, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each language, list the total count of TV channels that use it., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of TV Channels using each language?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM by-GROUP BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-1-GROUP BY",
            "SELECT-FROM-3-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of TV Channels using each language?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c3, count(*)",
        "label": "select t0.c3, count(*)",
        "score": true,
        "real_pred": "select TV_Channel.Language, count(*)",
        "real_label": "select TV_Channel.Language, count(*)",
        "topk_preds": [
            "select TV_Channel.Language, count(*)",
            "select count(*), TV_Channel.Language",
            "select sum(TV_Channel.Language), TV_Channel.Language",
            "select TV_Channel.Language, count(*), TV_Channel.Country",
            "select TV_Channel.Language.c3, count(*)",
            "select channel_TV_Channel.Language, count(*)",
            "select TV_channel_TV_Channel.Language, count(*)",
            "select TV_Channel.series_name, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of TV Channels using each language?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total amount of series names, contents in the tv channel list table?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM both t0.c1, t0.c4",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM series_names, SELECT-FROM",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM series_name, SELECT-FROM",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM INCLUDE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total amount of series names, contents in the tv channel list table?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select sum(t0.c1), sum(t0.c4)",
        "label": "select count(distinct t0.c1), count(distinct t0.c4)",
        "score": false,
        "real_pred": "select sum(TV_Channel.series_name), sum(TV_Channel.Content)",
        "real_label": "select count(distinct TV_Channel.series_name), count(distinct TV_Channel.Content)",
        "topk_preds": [
            "select sum(TV_Channel.series_name), sum(TV_Channel.Content)",
            "select sum(TV_Channel.series_name, sum(TV_Channel.Content)",
            "select sum(TV_Channel.Country), sum(TV_Channel.Content)",
            "select sum(TV_Channel.series_name), sum(TV_Channel.Country)",
            "select sum(TV_Channel.series_name)., sum(TV_Channel.Content)",
            "select sum(TV_Channel.series_name).c1, sum(TV_Channel.Content)",
            "select sum(TV_Channel.id, sum(TV_Channel.series_name)",
            "select sum(TV_Channel.series_name), sum(TV_Channel.Content)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total amount of series names, contents in the tv channel list table?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the production code and channel, of the latest animated movie?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, t2.c5, t2.c6",
            "SELECT-FROM-EXCEPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-C5, SELECT-FROM-C6",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the production code and channel, of the latest animated movie?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c5, t2.c6",
        "label": "select t2.c5, t2.c6",
        "score": true,
        "real_pred": "select Cartoon.Production_code, Cartoon.Channel",
        "real_label": "select Cartoon.Production_code, Cartoon.Channel",
        "topk_preds": [
            "select Cartoon.Production_code, Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel, t2.c7",
            "select Cartoon.Production_code, Cartoon.Channel, Cartoon.Title",
            "select Cartoon.Production_code.c6, Cartoon.Production_code",
            "select Cartoon.Production_code, Cartoon.Channel",
            "select Cartoon.Production_code.c5, Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel,",
            "select Cartoon.Production_code, Cartoon.Channel, Cartoon.Title3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the production code and channel, of the latest animated movie?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the code of the latest cartoon and the channel that broadcast it?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the code of the latest cartoon and the channel that broadcast it?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c5, t2.c6",
        "label": "select t2.c5, t2.c6",
        "score": true,
        "real_pred": "select Cartoon.Production_code, Cartoon.Channel",
        "real_label": "select Cartoon.Production_code, Cartoon.Channel",
        "topk_preds": [
            "select Cartoon.Production_code, Cartoon.Channel",
            "select Cartoon.id, Cartoon.Channel",
            "select Cartoon.Title, Cartoon.Channel",
            "select Cartoon.Channel, Cartoon.Production_code",
            "select production_Cartoon.Production_code, Cartoon.Channel",
            "select Cartoon.Original_air_date, Cartoon.Channel",
            "select Cartoon.Production_code), Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the code of the latest cartoon and the channel that broadcast it?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "TV_series Cartoon",
            "TV_Channel Cartoon",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the production code and the channel of the latest cartoon?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the production code and the channel of the latest cartoon?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c5, t2.c6",
        "label": "select t2.c5, t2.c6",
        "score": true,
        "real_pred": "select Cartoon.Production_code, Cartoon.Channel",
        "real_label": "select Cartoon.Production_code, Cartoon.Channel",
        "topk_preds": [
            "select Cartoon.Production_code, Cartoon.Channel",
            "select max(Cartoon.Production_code), max(Cartoon.Channel)",
            "select Cartoon.Production_code.c5, Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel)",
            "select Cartoon.Production_code, Cartoon.Channel,",
            "select t 2.c5, Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the production code and the channel of the latest cartoon?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "TV_series Cartoon",
            "",
            "TV_Channel TV_series Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the smallest and largest share for the TV series?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the smallest and largest share for the TV series?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select min(t1.c4), max(t1.c4)",
        "label": "select max(t1.c4), min(t1.c4)",
        "score": false,
        "real_pred": "select min(TV_series.Share), max(TV_series.Share)",
        "real_label": "select max(TV_series.Share), min(TV_series.Share)",
        "topk_preds": [
            "select min(TV_series.Share), max(TV_series.Share)",
            "select max(TV_series.Share), min(TV_series.Share)",
            "select TV_series.Share, min(TV_series.Share), max(TV_series.Share)",
            "select TV_series.Share, min(TV_series.Rating), max(TV_series.Share)",
            "select min(TV_series.Rating), max(TV_series.Share)",
            "select max(TV_series.Share), min(TV_series.Share), TV_series.Share",
            "select max(TV_series.Viewers_m), min(TV_series.Share)",
            "select max(TV_series.18_49_Rating_Share), min(TV_series.Share)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the smallest and largest share for the TV series?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all shares for the TV series and their minima and maxima., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM each t1.c4, min(t1.c4), max(t1.c4)",
            "SELECT-FROM (t1.c4), min(t1.c4), max(t1.c4)",
            "SELECT-FROM, MINIMUM(t1.c4), MAX(t1.c4)",
            "SELECT-FROM, MINIMUM(t1.c4), MAXIMUM(t1.c4)",
            "SELECT-FROM (t1.c4), minima(t1.c4), max(t1.c4)",
            "SELECT-FROM (t1.c4), minima(t1.c4), maxima(t1.c4)",
            "SELECT-FROM, min(t1.c4), max(t1.c4)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all shares for the TV series and their minima and maxima., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c4, min(t1.c4), max(t1.c4)",
        "label": "select max(t1.c4), min(t1.c4)",
        "score": false,
        "real_pred": "select TV_series.Share, min(TV_series.Share), max(TV_series.Share)",
        "real_label": "select max(TV_series.Share), min(TV_series.Share)",
        "topk_preds": [
            "select TV_series.Share, min(TV_series.Share), max(TV_series.Share)",
            "select TV_series.Share, minima(TV_series.Share), maxima(TV_series.Share)",
            "select TV_series.Share, minima(TV_series.Share), max(TV_series.Share)",
            "select sum(TV_series.Share), min(TV_series.Share), max(TV_series.Share)",
            "select TV_series.Share, min(TV_series.Share), maxim(TV_series.Share)",
            "select TV_series.Share, min(TV_series.Rating), max(TV_series.Share)",
            "select TV_series.Share, min(TV_series.Share),max(TV_series.Share)",
            "select TV_series.Share), min(TV_series.Share), max(TV_series.Share)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all shares for the TV series and their minima and maxima., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and IDs of all TV channels with 3 or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and IDs of all TV channels with 3 or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c1, t0.c0",
        "label": "select t0.c0",
        "score": false,
        "real_pred": "select TV_Channel.series_name, TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.series_name, TV_Channel.id",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.Country, TV_Channel.id",
            "select Cartoon.Title, TV_Channel.id",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.id",
            "select TV_Channel.Content, TV_Channel.id",
            "select t3.c1, TV_Channel.id",
            "select TV_Channel.series_name, TV_Channel.id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and IDs of all TV channels with 3 or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "",
            "",
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the code for each television channel that has a minimum of 3 channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING In-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the code for each television channel that has a minimum of 3 channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c6",
        "label": "select t0.c0",
        "score": false,
        "real_pred": "select TV_Channel.Hight_definition_TV",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.Hight_definition_TV",
            "select TV_Channel.series_name",
            "select TV_Channel.Country",
            "select TV_Channel.Language",
            "select TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.id",
            "select TV_Channel.Content",
            "select TV_Channel.Pay_per_view_PPV"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the code for each television channel that has a minimum of 3 channels?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the ids of all channels that have three or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the ids of all channels that have three or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select TV_Channel.id",
        "real_label": "select TV_Channel.id",
        "topk_preds": [
            "select TV_Channel.id",
            "select TV_Channel.id, TV_Channel.Hight_definition_TV",
            "select TV_Channel.id, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.id, TV_Channel.Package_Option",
            "select TV_Channel.id, TV_Channel.Language",
            "select TV_Channel.id, t0.c9",
            "select TV_Channel.id, TV_Channel.series_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the ids of all channels that have three or more TV channels., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "TV_Channel Cartoon",
            "",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: what are the 3 highest-rated episodes in the TV series table? Explain the ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: what are the 3 highest-rated episodes in the TV series table? Explain the ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": true,
        "real_pred": "select TV_series.Episode, TV_series.Rating",
        "real_label": "select TV_series.Episode, TV_series.Rating",
        "topk_preds": [
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.Rating",
            "select TV_series.Episode, TV_series.Air_Date",
            "select TV_series.Episode",
            "select TV_series.Episode, TV_series.Rating.c4",
            "select TV_series.Rating, TV_series.Share",
            "select TV_series.Episode, TV_series.Rating.c2",
            "select TV_series.Episode, TV_series.Rating,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: what are the 3 highest-rated episodes in the TV series table? Explain the ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "TV_series Cartoon",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the language of the fewest channels and how many channels use it?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-TV"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the language of the fewest channels and how many channels use it?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c3, count(*)",
        "label": "select t0.c3, count(*)",
        "score": true,
        "real_pred": "select TV_Channel.Language, count(*)",
        "real_label": "select TV_Channel.Language, count(*)",
        "topk_preds": [
            "select TV_Channel.Language, count(*)",
            "select TV_Channel.Language, count(*), TV_Channel.Country",
            "select TV_Channel.series_name, count(*)",
            "select TV_Channel.Country, count(*)",
            "select TV_Channel.Language.c3, count(*)",
            "select TV_Channel.Language, count(*), TV_Channel.Content",
            "select TV_Channel.Language, count(TV_Channel.id)",
            "select TV_Channel.Language, count(*), TV_Channel.Hight_definition_TV"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the language of the fewest channels and how many channels use it?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the total count of cartoons directed by each of the listed directors., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the total count of cartoons directed by each of the listed directors., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c2, count(*)",
        "label": "select count(*), t2.c2",
        "score": false,
        "real_pred": "select Cartoon.Directed_by, count(*)",
        "real_label": "select count(*), Cartoon.Directed_by",
        "topk_preds": [
            "select Cartoon.Directed_by, count(*)",
            "select Cartoon.Directed_by, count(*), Cartoon.Written_by",
            "select Cartoon.Directed_by.c2, count(*)",
            "select Cartoon.Directed_by, sum(Cartoon.id)",
            "select count(*), Cartoon.Directed_by",
            "select Cartoon.Directed_by, count(*), Cartoon.Production_code",
            "select Cartoon.Directed_by, count(*), Cartoon.Original_air_date",
            "select Cartoon.Directed_by, count(*), Cartoon.Title"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the total count of cartoons directed by each of the listed directors., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me three of the highest-rated TV series episodes, their Episode name and ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, t1.c1, t1.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me three of the highest-rated TV series episodes, their Episode name and ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": true,
        "real_pred": "select TV_series.Episode, TV_series.Rating",
        "real_label": "select TV_series.Episode, TV_series.Rating",
        "topk_preds": [
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_series.Air_Date, TV_series.Rating",
            "select TV_series.Episode, TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_series.Rating, TV_series.Air_Date",
            "select TV_series.Episode, TV_series.Air_Date, TV_series.Rating",
            "select TV_series.id, TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_series.Rating, TV_series.Air_Date",
            "select TV_series.Episode, TV_series.Air_Date, TV_series.Rating"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me three of the highest-rated TV series episodes, their Episode name and ratings., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the top three TV series, their Episode and rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, t1.c1, t1.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the top three TV series, their Episode and rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1, t1.c3",
        "label": "select t1.c1, t1.c3",
        "score": true,
        "real_pred": "select TV_series.Episode, TV_series.Rating",
        "real_label": "select TV_series.Episode, TV_series.Rating",
        "topk_preds": [
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.id, TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_series.Air_Date, TV_series.Rating",
            "select TV_series.Episode, TV_series.Rating, TV_series.Air_Date",
            "select t1, TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode.c1, TV_series.Rating",
            "select Cartoon.Title, TV_series.Rating"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the top three TV series, their Episode and rating., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the production code and channel of the latest aired cartoon., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-T2.c5, t2.c6"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the production code and channel of the latest aired cartoon., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c5, t2.c6",
        "label": "select t2.c5, t2.c6",
        "score": true,
        "real_pred": "select Cartoon.Production_code, Cartoon.Channel",
        "real_label": "select Cartoon.Production_code, Cartoon.Channel",
        "topk_preds": [
            "select Cartoon.Production_code, Cartoon.Channel",
            "select max(Cartoon.Production_code), max(Cartoon.Channel)",
            "select min(Cartoon.Production_code), min(Cartoon.Channel)",
            "select Cartoon.Production_code.c6, Cartoon.Production_code",
            "select the Cartoon.Production_code, Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel",
            "select latest(Cartoon.Production_code), Cartoon.Channel",
            "select Cartoon.Production_code, Cartoon.Channel)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the production code and channel of the latest aired cartoon., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "TV_series Cartoon",
            "",
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the country with most TV channels, and what is their exact number?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C2, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the country with most TV channels, and what is their exact number?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c2, count(*)",
        "label": "select t0.c2, count(*)",
        "score": true,
        "real_pred": "select TV_Channel.Country, count(*)",
        "real_label": "select TV_Channel.Country, count(*)",
        "topk_preds": [
            "select TV_Channel.Country, count(*)",
            "select TV_Channel.Country, count(*), TV_Channel.Language",
            "select TV_Channel.Country, count(*)",
            "select TV_Channel.Country.c2, count(*)",
            "select TV_Channel.Country, count(TV_Channel.id)",
            "select TV_Channel.Country, count(*), TV_Channel.series_name",
            "select TV_Channel.Country, count(*), TV_Channel.Hight_definition_TV",
            "select TV_Channel.series_name, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the country with most TV channels, and what is their exact number?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the largest and smallest share of TV series., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM -GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the largest and smallest share of TV series., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select max(t1.c4), min(t1.c4)",
        "label": "select max(t1.c4), min(t1.c4)",
        "score": true,
        "real_pred": "select max(TV_series.Share), min(TV_series.Share)",
        "real_label": "select max(TV_series.Share), min(TV_series.Share)",
        "topk_preds": [
            "select max(TV_series.Share), min(TV_series.Share)",
            "select TV_series.Share, max(TV_series.Share), min(TV_series.Share)",
            "select TV_series.Share, max(TV_series.Share)",
            "select max(TV_series.Viewers_m), min(TV_series.Share)",
            "select max(TV_series.Share), min(TV_series.Share), TV_series.id",
            "select max(TV_series.18_49_Rating_Share), min(TV_series.Share)",
            "select maximum(TV_series.Share), min(TV_series.Share)",
            "select max(TV_series.Rating), min(TV_series.Share)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the largest and smallest share of TV series., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the smallest and largest share of TV series., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the smallest and largest share of TV series., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select min(t1.c4), max(t1.c4)",
        "label": "select max(t1.c4), min(t1.c4)",
        "score": false,
        "real_pred": "select min(TV_series.Share), max(TV_series.Share)",
        "real_label": "select max(TV_series.Share), min(TV_series.Share)",
        "topk_preds": [
            "select min(TV_series.Share), max(TV_series.Share)",
            "select TV_series.Share, min(TV_series.Share), max(TV_series.Share)",
            "select max(TV_series.Share), min(TV_series.Share)",
            "select TV_series.Share, min(TV_series.Rating), max(TV_series.Share)",
            "select TV_series.Share, min(TV_series.Share), max(TV_series.Share)",
            "select TV_series.Share, min(TV_series.Share)",
            "select TV_series.Share, min(TV_series.Share) und max(TV_series.Share)",
            "select min(TV_series.Rating), max(TV_series.Share)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the smallest and largest share of TV series., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the order of the player with the highest earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the order of the player with the highest earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c4, t0.c5",
        "label": "select t0.c4",
        "score": false,
        "real_pred": "select poker_player.Money_Rank, poker_player.Earnings",
        "real_label": "select poker_player.Money_Rank",
        "topk_preds": [
            "select poker_player.Money_Rank, poker_player.Earnings",
            "select poker_player.Money_Rank",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Money_Rank, t0.c6",
            "select poker_player.Money_Rank, poker_player.Best_Finish",
            "select poker_player.Money_Rank, poker_player.Earnings.",
            "select poker_player.Money_Rank, poker_player.Earnings,",
            "select poker_player.Best_Finish, poker_player.Money_Rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the order of the player with the highest earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the money rank of the player who has earned the most money., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the money rank of the player who has earned the most money., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select poker_player.Money_Rank",
        "real_label": "select poker_player.Money_Rank",
        "topk_preds": [
            "select poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Money_Rank",
            "select poker_player.People_ID, poker_player.Money_Rank",
            "select poker_player.Money_Rank, poker_player.Earnings",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Money_Rank (poker_poker_player.Money_Rank)",
            "select poker_player.Money_Rank (or whatever poker_player.Money_Rank)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the money rank of the player who has earned the most money., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the rank of the player with the largest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the rank of the player with the largest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select poker_player.Money_Rank",
        "real_label": "select poker_player.Money_Rank",
        "topk_preds": [
            "select poker_player.Money_Rank",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Money_Rank, poker_player.Earnings",
            "select poker_player.Poker_Player_ID, poker_player.Money_Rank",
            "select poker_player.People_ID, poker_player.Money_Rank",
            "select poker_player.Money_Rank, max(poker_player.Earnings)",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Money_Rank (poker_poker_player.Earnings)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the rank of the player with the largest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the rank of the player with the most earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the rank of the player with the most earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select poker_player.Money_Rank",
        "real_label": "select poker_player.Money_Rank",
        "topk_preds": [
            "select poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Money_Rank",
            "select poker_player.Money_Rank, poker_player.Earnings",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.People_ID, poker_player.Money_Rank",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Best_Finish, poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the rank of the player with the most earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the earnings of poker players, sorted starting with the highest., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM\u2013ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM- ORDER BY",
            "SELECT-FROM,-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the earnings of poker players, sorted starting with the highest., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select poker_player.Earnings",
        "real_label": "select poker_player.Earnings",
        "topk_preds": [
            "select poker_player.Earnings",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Earnings, t0.c6",
            "select poker_player.Earnings, poker_player.Poker_Player_ID",
            "select poker_player.Earnings, poker_player.People_ID",
            "select poker_player.Earnings, t0.c8",
            "select poker_player.Earnings, t0.c7",
            "select poker_player.Earnings-ORDER BY"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the earnings of poker players, sorted starting with the highest., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the nationalities shared by no less than one people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSIST-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the nationalities shared by no less than one people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, people.Name",
            "select people.Nationality, people.Name, people.Birth_Date",
            "select people.Nationality, people.People_ID",
            "select people.Nationality, min(people.Nationality)",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, people.Name, max(people.Nationality)",
            "select people.Nationality, people.Name, min(people.Nationality)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the nationalities shared by no less than one people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the nationalities shared by two people or more., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the nationalities shared by two people or more., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, people.Name",
            "select people.Nationality, people.Name, people.Birth_Date",
            "select people.Nationality, people.People_ID",
            "select people.Nationality, count(*)",
            "select people.Nationality, people.Name, max(people.Nationality)",
            "select people.Nationality, pair(people.People_ID)",
            "select people.Nationality, people.Birth_Date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the nationalities shared by two people or more., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the nationalities that are shared by no less than one people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the nationalities that are shared by no less than one people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, people.Name",
            "select people.Nationality, people.People_ID",
            "select people.Nationality, people.Name, people.Birth_Date",
            "select people.Nationality, count(*)",
            "select people.Nationality, min(people.Nationality)",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, freq(people.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the nationalities that are shared by no less than one people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the nationalities that share two or more persons., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the nationalities that share two or more persons., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, people.People_ID",
            "select people.Nationality, people.Name",
            "select people.Nationality, count(people.People_ID)",
            "select people.Nationality, count(*)",
            "select people.Nationality, share(people.People_ID)",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, min(people.Nationality)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the nationalities that share two or more persons., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the nationalities that have more than one person in them?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-ISO-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM'GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the nationalities that have more than one person in them?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, count(*)",
            "select people.Nationality, people.Name",
            "select people.Nationality, count(people.People_ID)",
            "select people.Nationality Avg(people.Name)",
            "select people.Nationality Avg(people.Height)",
            "select people.Nationality, people.People_ID",
            "select people.Nationality, max(people.People_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the nationalities that have more than one person in them?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the poker player earnings, sorted from highest to lowest., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c5",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY (t0.c5)",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY t0",
            "SELECT SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the poker player earnings, sorted from highest to lowest., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select poker_player.Earnings",
        "real_label": "select poker_player.Earnings",
        "topk_preds": [
            "select poker_player.Earnings",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Earnings, t0.c6",
            "select poker_player.Earnings, t0.c8",
            "select poker_player.Earnings, t0.c7",
            "select poker_player.Earnings, poker_player.People_ID",
            "select poker_player.Earnings, poker_player.Final_Table_Made",
            "select poker_player.Earnings-ORDER BY"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the poker player earnings, sorted from highest to lowest., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the nationality of the largest number of people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the nationality of the largest number of people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, people.Name",
            "select people.Nationality, people.Name, people.Birth_Date",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, people.People_ID",
            "select people.Nationality, people.Birth_Date, people.Height",
            "select people.Nationality, people.Name, people.Height",
            "select people.Nationality, people.Height"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the nationality of the largest number of people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the nationality of the most people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the nationality of the most people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, people.Name",
            "select people.Nationality, people.Name, people.Birth_Date",
            "select people.Nationality, people.People_ID",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, people.Birth_Date, people.Height",
            "select people.Nationality, people.Name, people.Height",
            "select people.Nationality, people.Height"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the nationality of the most people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the nationality of the largest percentage of people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the nationality of the largest percentage of people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, people.Name",
            "select people.Nationality, people.Name, people.Birth_Date",
            "select people.Nationality, people.People_ID",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, people.Height",
            "select people.Nationality, people.Birth_Date, people.Height",
            "select people.Nationality, people.Name, people.Height"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the nationality of the largest percentage of people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the avgerage earnings of poker players taller than 200cm., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t0.c5)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE AVG(t0.c5)",
            "SELECT-FROM-WHERE (AVG(t0.c5)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the avgerage earnings of poker players taller than 200cm., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select avg(t0.c5)",
        "label": "select avg(t0.c5)",
        "score": true,
        "real_pred": "select avg(poker_player.Earnings)",
        "real_label": "select avg(poker_player.Earnings)",
        "topk_preds": [
            "select avg(poker_player.Earnings)",
            "select avgerage(poker_player.Earnings)",
            "select avgerge(poker_player.Earnings)",
            "select avge(poker_player.Earnings)",
            "select avgerace(poker_player.Earnings)",
            "select avged(poker_player.Earnings)",
            "select avgerance(poker_player.Earnings)",
            "select avgen(poker_player.Earnings)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the avgerage earnings of poker players taller than 200cm., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the average earnings of poker players with height over 200., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (Avg(t0.c5)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the average earnings of poker players with height over 200., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select avg(t0.c5)",
        "label": "select avg(t0.c5)",
        "score": true,
        "real_pred": "select avg(poker_player.Earnings)",
        "real_label": "select avg(poker_player.Earnings)",
        "topk_preds": [
            "select avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), people.Height",
            "select an avg(poker_player.Earnings)",
            "select  avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), people.People_ID",
            "select the avg(poker_player.Earnings)",
            "select Avg(poker_player.Earnings)",
            "select avg(t0, poker_player.Earnings)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the average earnings of poker players with height over 200., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the highest final tables made by all poker players with a total earnings below 200000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the highest final tables made by all poker players with a total earnings below 200000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c2",
        "label": "select max(t0.c2)",
        "score": false,
        "real_pred": "select poker_player.Final_Table_Made",
        "real_label": "select max(poker_player.Final_Table_Made)",
        "topk_preds": [
            "select poker_player.Final_Table_Made",
            "select max(poker_player.Final_Table_Made)",
            "select poker_player.Final_Table_Made, poker_player.Best_Finish",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select max(poker_player.Final_Table_Made), poker_player.Best_Finish",
            "select max(poker_player.Final_Table_Made), poker_player.Earnings",
            "select poker_player.Poker_Player_ID, max(poker_player.Final_Table_Made)",
            "select max(poker_player.Final_Table_Made), max(poker_player.Best_Finish)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the highest final tables made by all poker players with a total earnings below 200000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            "poker_player people"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the total count of poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM (*)",
            "SELECT-FROM the total count(*)",
            "SELECT-FROM (count(*)",
            "SELECT-FROM.",
            "SELECT-FROM ",
            "SELECT-FROM, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the total count of poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), poker_player.People_ID",
            "select count(*), poker_player.Poker_Player_ID",
            "select count(*), poker_player.Final_Table_Made",
            "select t0.c count(*)",
            "select poker_player.People_ID, count(*)",
            "select count(*), http://poker_player.Poker_Player_ID",
            "select count(*), http://poker_player.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the total count of poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the nationalities with at least two people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the nationalities with at least two people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, count(*)",
            "select people.Nationality, people.Name",
            "select people.Nationality, min(people.Nationality)",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, max(people.Nationality)",
            "select people.Nationality, min(people.Name)",
            "select people.Nationality, people.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the nationalities with at least two people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return all nationalities for which there are multiple people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEO-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return all nationalities for which there are multiple people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, count(*)",
            "select people.Nationality, people.Name",
            "select people.Nationality Avg(people.Height)",
            "select people.Nationality, max(people.People_ID)",
            "select people.Nationality, people.People_ID",
            "select people.Nationality Avg(people.Name)",
            "select people.Nationality, max(people.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return all nationalities for which there are multiple people., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List down the name of poker player, starting from the greatest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c2",
            "SELECT-FROM-ORDER BY t0.c5",
            "SELECT-FROM,-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List down the name of poker player, starting from the greatest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, poker_player.Earnings",
            "select people.Name (or people.Birth_Date)",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name in poker_player.Earnings",
            "select people.Name, t1.c5",
            "select people.Name, poker_player.People_ID",
            "select people.Name (ORDER BY"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List down the name of poker player, starting from the greatest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Write the names of poker players, ordered from largest to smallest based on their earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c0, SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1 - SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1",
            "SELECT-FROM-ORDER BY t0.c2",
            "SELECT SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Write the names of poker players, ordered from largest to smallest based on their earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, poker_player.Earnings",
            "select people.Name (ordered by poker_player.Earnings)",
            "select people.Nationality, poker_player.Earnings",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, t1.c5",
            "select people.Name (ordered poker_player.Earnings)",
            "select people.Name, people.Birth_Date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Write the names of poker players, ordered from largest to smallest based on their earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the average earnings of poker players who are over 200 cm tall?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (Avg(t0.c5)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE -GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the average earnings of poker players who are over 200 cm tall?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select avg(t0.c5)",
        "label": "select avg(t0.c5)",
        "score": true,
        "real_pred": "select avg(poker_player.Earnings)",
        "real_label": "select avg(poker_player.Earnings)",
        "topk_preds": [
            "select avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), people.Height",
            "select an avg(poker_player.Earnings)",
            "select  avg(poker_player.Earnings)",
            "select avg(t0, poker_player.Earnings)",
            "select the avg(poker_player.Earnings)",
            "select Avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), people.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the average earnings of poker players who are over 200 cm tall?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the people from outside Russia?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the people from outside Russia?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Height",
            "select distinct people.Name, people.Birth_Date",
            "select distinct people.Name",
            "select people.Name, people.Nationality",
            "select people.Name, people.Name",
            "select distinct people.Name, people.Height"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the people from outside Russia?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of non-russians., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of non-russians., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Nationality",
            "select people.Name, people.Birth_Date",
            "select distinct people.Name",
            "select people.Name, people.Height",
            "select people.Name, people.Nationality3",
            "select people.Name, t1.c5",
            "select people.Name (or people.Birth_Date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of non-russians., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the birth date of the poker player who earned the least money in his career., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the birth date of the poker player who earned the least money in his career., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select people.Birth_Date",
        "real_label": "select people.Birth_Date",
        "topk_preds": [
            "select people.Birth_Date",
            "select people.People_ID, people.Birth_Date",
            "select people.Birth_Date, people.Height",
            "select people.Birth_Date, people.Name",
            "select people.Birth_Date, poker_player.Money_Rank",
            "select people.Birth_Date, poker_player.People_ID",
            "select people.Birth_Date, poker_player.Earnings",
            "select people.Birth_Date, poker_player.Final_Table_Made"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the birth date of the poker player who earned the least money in his career., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the birth date of the poker player with the smallest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-orDER BY-LIMIT",
            "SELECT-FROM-OrDER BY-LIMIT",
            "SELECT-FROM- ORDER BY-LIMIT",
            "SELECT-FROM-ORSDER BY-LIMIT",
            "SELECT-FROM-ORDER BY -LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the birth date of the poker player with the smallest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select people.Birth_Date",
        "real_label": "select people.Birth_Date",
        "topk_preds": [
            "select people.Birth_Date",
            "select people.Birth_Date, people.Height",
            "select people.People_ID, people.Birth_Date",
            "select people.Birth_Date, people.Name",
            "select people.Birth_Date, poker_player.Money_Rank",
            "select people.Birth_Date, poker_player.People_ID",
            "select people.Birth_Date, poker_player.Earnings",
            "select people.People_ID, people.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the birth date of the poker player with the smallest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out when was the birth date of the poker player who have the fewest earning?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out when was the birth date of the poker player who have the fewest earning?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select people.Birth_Date",
        "real_label": "select people.Birth_Date",
        "topk_preds": [
            "select people.Birth_Date",
            "select people.Birth_Date, people.Height",
            "select people.Birth_Date, people.Name",
            "select people.Nationality, people.Birth_Date",
            "select people.Birth_Date, poker_player.Money_Rank",
            "select people.Birth_Date, poker_player.People_ID",
            "select people.Birth_Date, poker_player.Final_Table_Made",
            "select people.Birth_Date (or people.Height)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out when was the birth date of the poker player who have the fewest earning?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of poker players whose earnings is over $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of poker players whose earnings is over $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, t1.c5",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.Earnings"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of poker players whose earnings is over $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of poker players whose winnings is over $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of poker players whose winnings is over $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, t1.c5",
            "select people.Name, people.People_ID",
            "select people.Name, people.Height"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of poker players whose winnings is over $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of poker players whose earnings is more than 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of poker players whose earnings is more than 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, people.Nationality",
            "select people.Name, t1.c5",
            "select people.Name, people.Height",
            "select people.Name, poker_player.Best_Finish"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of poker players whose earnings is more than 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of poker players whose lifetime winnings exceed 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of poker players whose lifetime winnings exceed 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.People_ID",
            "select people.Name, t1.c5",
            "select people.Name, people.Height",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Nationality, people.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of poker players whose lifetime winnings exceed 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the money rank of the poker player with the most earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the money rank of the poker player with the most earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select poker_player.Money_Rank",
        "real_label": "select poker_player.Money_Rank",
        "topk_preds": [
            "select poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Money_Rank",
            "select poker_player.Money_Rank, poker_player.Earnings",
            "select poker_player.People_ID, poker_player.Money_Rank",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Money_Rank (http://poker_player.Money_Rank)",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select poker_player.People_ID, poker_player.Best_Finish"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the money rank of the poker player with the most earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the money rank of the poker player with the largest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the money rank of the poker player with the largest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select poker_player.Money_Rank",
        "real_label": "select poker_player.Money_Rank",
        "topk_preds": [
            "select poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Money_Rank",
            "select poker_player.People_ID, poker_player.Money_Rank",
            "select poker_player.Money_Rank, poker_player.Earnings",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Money_Rank (or whatever poker_player.Money_Rank)",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the money rank of the poker player with the largest earnings., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the money rank of the poker player with the most money?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the money rank of the poker player with the most money?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select poker_player.Money_Rank",
        "real_label": "select poker_player.Money_Rank",
        "topk_preds": [
            "select poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Money_Rank",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.People_ID, poker_player.Money_Rank",
            "select poker_player.Money_Rank, poker_player.Earnings",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select poker_player.People_ID, poker_player.Best_Finish",
            "select poker_player.Money_Rank (or whatever poker_player.Money_Rank)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the money rank of the poker player with the most money?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the money rank of the poker player who won the most., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the money rank of the poker player who won the most., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select poker_player.Money_Rank",
        "real_label": "select poker_player.Money_Rank",
        "topk_preds": [
            "select poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Money_Rank",
            "select poker_player.People_ID, poker_player.Money_Rank",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Money_Rank, poker_player.Earnings",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made",
            "select poker_player.People_ID, poker_player.Best_Finish"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the money rank of the poker player who won the most., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the largest money rank of the tallest poker player., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY -LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the largest money rank of the tallest poker player., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select max(t0.c4)",
        "label": "select t0.c4",
        "score": false,
        "real_pred": "select max(poker_player.Money_Rank)",
        "real_label": "select poker_player.Money_Rank",
        "topk_preds": [
            "select max(poker_player.Money_Rank)",
            "select poker_player.Money_Rank",
            "select max(poker_player.Money_Rank), people.Height",
            "select min(poker_player.Money_Rank)",
            "select max(poker_player.Money_Rank) (poker_player.Money_Rank)",
            "select max(poker_player.Money_Rank), people.Height",
            "select maximum(poker_player.Money_Rank)",
            "select max(poker_player.Money_Rank), people.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the largest money rank of the tallest poker player., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "people poker_player people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the mean earnings of poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM (GROUP BY",
            "SELECT-FROM -GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the mean earnings of poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select avg(t0.c5)",
        "label": "select avg(t0.c5)",
        "score": true,
        "real_pred": "select avg(poker_player.Earnings)",
        "real_label": "select avg(poker_player.Earnings)",
        "topk_preds": [
            "select avg(poker_player.Earnings)",
            "select an avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), poker_player.Poker_Player_ID",
            "select avg(poker_player.Earnings), t0.c6",
            "select the avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings) (poker_player.Earnings)",
            "select avg(poker_player.Earnings), poker_player.Money_Rank",
            "select avg(t0, poker_player.Earnings)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the mean earnings of poker players., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the birthdate of the poker player with the least earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the birthdate of the poker player with the least earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select people.Birth_Date",
        "real_label": "select people.Birth_Date",
        "topk_preds": [
            "select people.Birth_Date",
            "select people.Birth_Date, people.Height",
            "select people.Birth_Date, poker_player.People_ID",
            "select people.People_ID, people.Birth_Date",
            "select people.Birth_Date, poker_player.Money_Rank",
            "select people.Birth_Date, poker_player.Final_Table_Made",
            "select people.Birth_Date, people.Name",
            "select people.Birth_Date, poker_player.Earnings"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the birthdate of the poker player with the least earnings?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell me the birthday of the poker player who earns less than the rest., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell me the birthday of the poker player who earns less than the rest., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select people.Birth_Date",
        "real_label": "select people.Birth_Date",
        "topk_preds": [
            "select people.Birth_Date",
            "select people.Name, people.Birth_Date",
            "select people.People_ID, people.Birth_Date",
            "select people.Birth_Date, people.Name",
            "select people.Nationality, people.Birth_Date",
            "select people.Birth_Date, people.Height",
            "select people.Birth_Date, poker_player.Earnings",
            "select people.Birth_Date, poker_player.Money_Rank"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell me the birthday of the poker player who earns less than the rest., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of poker players who have earnings larger than $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of poker players who have earnings larger than $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, poker_player.People_ID",
            "select people.Name, t1.c5",
            "select people.Name, people.Nationality",
            "select people.Name, people.People_ID",
            "select people.Name, poker_player.Best_Finish"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of poker players who have earnings larger than $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the names of poker players whose earnings exceed $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the names of poker players whose earnings exceed $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, t1.c5",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.Best_Finish",
            "select people.Name, people.Height"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the names of poker players whose earnings exceed $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the contestants who have a name other than 'Jessie Alloway'?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the contestants who have a name other than 'Jessie Alloway'?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_name",
        "real_label": "select CONTESTANTS.contestant_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_name, t1.c2",
            "select CONTESTANTS.contestant_name, CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_name, t1.c3",
            "select distinct CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_name, t1.c6",
            "select CONTESTANTS.contestant_name, t1.c4",
            "select CONTESTANTS.contestant_name (, t1.c2)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the contestants who have a name other than 'Jessie Alloway'?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name (Jessie Alloway)). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "CONTESTANTS",
        "real_label": "CONTESTANTS",
        "topk_preds": [
            "CONTESTANTS",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the largest and smallest possible area codes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM (UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the largest and smallest possible area codes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select max(t0.c0), min(t0.c0)",
        "label": "select max(t0.c0), min(t0.c0)",
        "score": true,
        "real_pred": "select max(AREA_CODE_STATE.area_code), min(AREA_CODE_STATE.area_code)",
        "real_label": "select max(AREA_CODE_STATE.area_code), min(AREA_CODE_STATE.area_code)",
        "topk_preds": [
            "select max(AREA_CODE_STATE.area_code), min(AREA_CODE_STATE.area_code)",
            "select max(t0.c2), min(t0.c2)",
            "select max(AREA_CODE_STATE.state), min(t0.c2)",
            "select max(t0.c6), min(t0.c6)",
            "select max(t0.c4), min(t0.c4)",
            "select max(t0.c3), min(t0.c3)",
            "select max(AREA_CODE_STATE.area_code), min(t0.c2)",
            "select max(AREA_CODE_STATE.state), min(AREA_CODE_STATE.state)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the largest and smallest possible area codes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "AREA_CODE_STATE",
        "real_label": "AREA_CODE_STATE",
        "topk_preds": [
            "AREA_CODE_STATE",
            "",
            "AREA_CODE_STATE CONTESTANTS",
            "",
            "",
            "AREA_CODE_STATE VOTES",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the code for the area with the highest number of voters., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the code for the area with the highest number of voters., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select AREA_CODE_STATE.area_code",
        "real_label": "select AREA_CODE_STATE.area_code",
        "topk_preds": [
            "select AREA_CODE_STATE.area_code",
            "select AREA_CODE_STATE.area_code, AREA_CODE_STATE.state",
            "select AREA_CODE_STATE.state",
            "select AREA_CODE_STATE.state, t0.c2",
            "select AREA_CODE_STATE.area_code, VOTES.state",
            "select AREA_CODE_STATE.state, AREA_CODE_STATE.area_code",
            "select t0.c2",
            "select AREA_CODE_STATE.area_code, AREA_CODE_STATE.state"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the code for the area with the highest number of voters., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "AREA_CODE_STATE VOTES",
        "real_label": "AREA_CODE_STATE VOTES",
        "topk_preds": [
            "AREA_CODE_STATE VOTES",
            "VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the area code in which the largest number of voters reside., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the area code in which the largest number of voters reside., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select AREA_CODE_STATE.area_code",
        "real_label": "select AREA_CODE_STATE.area_code",
        "topk_preds": [
            "select AREA_CODE_STATE.area_code",
            "select AREA_CODE_STATE.area_code, AREA_CODE_STATE.state",
            "select AREA_CODE_STATE.state",
            "select AREA_CODE_STATE.area_code, VOTES.state",
            "select AREA_CODE_STATE.state, t0.c2",
            "select VOTES.state",
            "select AREA_CODE_STATE.area_code, AREA_CODE_STATE.state",
            "select t0.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the area code in which the largest number of voters reside., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "AREA_CODE_STATE VOTES",
        "real_label": "AREA_CODE_STATE VOTES",
        "topk_preds": [
            "AREA_CODE_STATE VOTES",
            "VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "AREA_CODE_STATE"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me a list of contestants numbers and names with more or equal to 2 votes., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me a list of contestants numbers and names with more or equal to 2 votes., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
        "real_label": "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select VOTES.contestant_number, CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, VOTES.contestant_number",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, max(VOTES.contestant_number)",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, min(VOTES.contestant_number)",
            "select CONTESTANTS.contestant_name, CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, t1.c2",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, t1.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me a list of contestants numbers and names with more or equal to 2 votes., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the vote counts of state NY or CA., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA, NY)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA, NY), c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the vote counts of state NY or CA., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA, NY)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA, NY), c3: contestant_number, c4: created).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select VOTES.vote_id",
            "select count(*), VOTES.state",
            "select sum(VOTES.vote_id)",
            "select count(*), AREA_CODE_STATE.state",
            "select count(0.c0)",
            "select sum(VOTES.vote_id), AREA_CODE_STATE.state",
            "select sum(VOTES.vote_id), VOTES.state"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the vote counts of state NY or CA., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA, NY)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA, NY), c3: contestant_number, c4: created).",
        "prediction": "t0 t2",
        "label": "t2",
        "score": false,
        "real_pred": "AREA_CODE_STATE VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "AREA_CODE_STATE VOTES",
            "VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the latest day in which we collected votes from CA?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the latest day in which we collected votes from CA?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "select max(t2.c4)",
        "label": "select max(t2.c4)",
        "score": true,
        "real_pred": "select max(VOTES.created)",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select max(VOTES.created)",
            "select max(t2.c5)",
            "select max(t2.c6)",
            "select max(VOTES.contestant_number)",
            "select max(t2.c7)",
            "select max(t2.c8)",
            "select max(VOTES.state)",
            "select max(VOTES.phone_number)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the latest day in which we collected votes from CA?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "AREA_CODE_STATE VOTES",
            "",
            "",
            "CONTESTANTS VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the date of votes from the state California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the date of votes from the state California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t2.c4",
        "label": "select max(t2.c4)",
        "score": false,
        "real_pred": "select VOTES.created",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select VOTES.created",
            "select t2.c5",
            "select VOTES.vote_id",
            "select VOTES.vote_id, VOTES.created",
            "select VOTES.contestant_number",
            "select VOTES.vote_id, t2.c5",
            "select VOTES.vote_id, max(VOTES.created)",
            "select VOTES.vote_id, AREA_CODE_STATE.state"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the date of votes from the state California., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t0 t2",
        "label": "t2",
        "score": false,
        "real_pred": "AREA_CODE_STATE VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "AREA_CODE_STATE VOTES",
            "VOTES",
            "CONTESTANTS VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the latest date in which votes were received from the state CA?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the latest date in which votes were received from the state CA?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "select max(t2.c4)",
        "label": "select max(t2.c4)",
        "score": true,
        "real_pred": "select max(VOTES.created)",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select max(VOTES.created)",
            "select max(t2.c5)",
            "select max(VOTES.contestant_number)",
            "select max(t2.c6)",
            "select max(t2.c8)",
            "select max(t2.c7)",
            "select max(VOTES.state)",
            "select max(t2).c4)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the latest date in which votes were received from the state CA?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "AREA_CODE_STATE VOTES",
            "",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "",
            "CONTESTANTS VOTES",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the latest date a vote from California was cast?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (maximum(t2.c4)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the latest date a vote from California was cast?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select max(t2.c4)",
        "label": "select max(t2.c4)",
        "score": true,
        "real_pred": "select max(VOTES.created)",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select max(VOTES.created)",
            "select max(VOTES.created), AREA_CODE_STATE.state",
            "select max(t2.c5)",
            "select max(VOTES.created), VOTES.phone_number",
            "select max(VOTES.contestant_number)",
            "select max(VOTES.created), VOTES.state",
            "select max(t2.c6)",
            "select max(VOTES.created), AREA_CODE_STATE.state"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the latest date a vote from California was cast?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t0 t2",
        "label": "t2",
        "score": false,
        "real_pred": "AREA_CODE_STATE VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "AREA_CODE_STATE VOTES",
            "VOTES",
            "CONTESTANTS VOTES",
            "",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of all the contestants who were voted, what is the contestant number and name of the contestant that received the fewest votes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-C3 - SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-C3, SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of all the contestants who were voted, what is the contestant number and name of the contestant that received the fewest votes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
        "real_label": "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
        "topk_preds": [
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select VOTES.contestant_number, CONTESTANTS.contestant_name",
            "select VOTES.state, CONTESTANTS.contestant_number, CONTESTANTS.contestant_name",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, VOTES.contestant_number",
            "select CONTESTANTS.contestant_name, CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, t1.c2",
            "select VOTES.phone_number, CONTESTANTS.contestant_number",
            "select CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, CONTESTANTS.contestant_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of all the contestants who were voted, what is the contestant number and name of the contestant that received the fewest votes?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "CONTESTANTS VOTES",
        "real_label": "CONTESTANTS VOTES",
        "topk_preds": [
            "CONTESTANTS VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the native tongue of the most speakers in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the native tongue of the most speakers in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.Language, country.Code2",
            "select countrylanguage.Language, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the native tongue of the most speakers in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the language spoken by the most people in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the language spoken by the most people in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Code",
            "select country.Name, countrylanguage.CountryCode",
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.Language, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the language spoken by the most people in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "country countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "city country countrylanguage",
            "countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the languages with the greatest percentage of native speakers living in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the languages with the greatest percentage of native speakers living in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1, t3.c0",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.Language, countrylanguage.CountryCode",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Code2",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Continent",
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the languages with the greatest percentage of native speakers living in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "country countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "countrylanguage",
            "sqlite_sequence countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the language spoken by the maximum number of people in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the language spoken by the maximum number of people in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.Language, country.Code2",
            "select max(country.Population), countrylanguage.Language",
            "select countrylanguage.Language, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the language spoken by the maximum number of people in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "country countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out what is the language which is used by the majority of people in each country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out what is the language which is used by the majority of people in each country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, countrylanguage.Percentage",
            "select country.Name, countrylanguage.CountryCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out what is the language which is used by the majority of people in each country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "country countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "countrylanguage",
            "sqlite_sequence countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the language spoken by the majority of the population in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the language spoken by the majority of the population in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Capital",
            "select country.Name, countrylanguage.CountryCode",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Population",
            "select country.Name, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the language spoken by the majority of the population in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "country countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the language that is spoken by the highest percentage of the people in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-VARIATION-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the language that is spoken by the highest percentage of the people in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, countrylanguage.Percentage",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Capital"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the language that is spoken by the highest percentage of the people in each country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the main language spoken by the majority of the population in each country?, database: Database: world_1. t0: city(c0: id, c1: name (Mainz), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUPT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the main language spoken by the majority of the population in each country?, database: Database: world_1. t0: city(c0: id, c1: name (Mainz), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Code",
            "select country.Name, countrylanguage.CountryCode",
            "select countrylanguage.Language, country.Population",
            "select countrylanguage.Language, countrylanguage.CountryCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the main language spoken by the majority of the population in each country?, database: Database: world_1. t0: city(c0: id, c1: name (Mainz), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "country countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the population, leader and name of the country with the greatest area?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, t2.c12, t2.c1",
            "SELECT-FROM-ORDER BY-LIMIT, t2.c6, t2.c12",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the population, leader and name of the country with the greatest area?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c6, t2.c12, t2.c1",
        "label": "select t2.c1, t2.c6, t2.c12",
        "score": false,
        "real_pred": "select country.Population, country.HeadOfState, country.Name",
        "real_label": "select country.Name, country.Population, country.HeadOfState",
        "topk_preds": [
            "select country.Population, country.HeadOfState, country.Name",
            "select country.Code, country.HeadOfState, country.Name",
            "select country.Code, country.Population, country.HeadOfState",
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Population, country.Capital, country.Name",
            "select country.Population), country.HeadOfState, country.Name",
            "select country.GNP, country.HeadOfState, country.Name",
            "select country.Population, country.HeadOfState, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the population, leader and name of the country with the greatest area?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the sum area of all the countries in the Caribbean region?, database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean, Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the sum area of all the countries in the Caribbean region?, database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean, Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Name",
            "select sum(country.SurfaceArea) descripted in country.SurfaceArea",
            "select sum(country.SurfaceArea) descripted in country.Name",
            "select sum(country.SurfaceArea), country.Code",
            "select sum(country.SurfaceArea) dependant on country.Name",
            "select sum(country.SurfaceArea) delimited by country.Name",
            "select sum(country.SurfaceArea) descripted in country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the sum area of all the countries in the Caribbean region?, database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean, Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "sqlite_sequence country",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How large is the area of countries located in the Caribbean region in total?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE sum(t2.c4)",
            "SELECT-FROM-WHERE ADDIT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE ADDIT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE ADDIT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How large is the area of countries located in the Caribbean region in total?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Name",
            "select sum(country.SurfaceArea) descripted in country.SurfaceArea",
            "select sum(country.SurfaceArea) descripted by country.Name",
            "select sum(country.SurfaceArea) descripted by country.SurfaceArea",
            "select sum(country.SurfaceArea) denoted by country.SurfaceArea",
            "select sum(country.SurfaceArea) descripted in country.Name",
            "select sum(country.SurfaceArea) descripted country.SurfaceArea"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How large is the area of countries located in the Caribbean region in total?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "sqlite_sequence country",
            "city country",
            "",
            "",
            "country countrylanguage"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Sum up all the surface area of the countries in the Caribbean., database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean, Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Sum up all the surface area of the countries in the Caribbean., database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean, Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Name",
            "select sum(country.SurfaceArea), country.Region",
            "select sum(country.SurfaceArea), country.Code",
            "select sum(country.SurfaceArea), country.IndepYear",
            "select sum(country.SurfaceArea), country.LifeExpectancy",
            "select avg(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Sum up all the surface area of the countries in the Caribbean., database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean, Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "sqlite_sequence country",
            "city country"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many live in Asia, and what is the biggest GDP among them?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many live in Asia, and what is the biggest GDP among them?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c6, t2.c8",
        "label": "select sum(t2.c6), max(t2.c8)",
        "score": false,
        "real_pred": "select country.Population, country.GNP",
        "real_label": "select sum(country.Population), max(country.GNP)",
        "topk_preds": [
            "select country.Population, country.GNP",
            "select country.Population, country.LifeExpectancy",
            "select country.Name, country.GNP",
            "select country.Code, country.Population",
            "select country.Population, country.Capital",
            "select country.Population, country.GNPOld",
            "select country.Name, country.LifeExpectancy",
            "select country.Population, country.Name5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many live in Asia, and what is the biggest GDP among them?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List how many people live in Asia, and the GDP of the country that has the highest GNP among them., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDINATE-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List how many people live in Asia, and the GDP of the country that has the highest GNP among them., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c6, t2.c8",
        "label": "select sum(t2.c6), max(t2.c8)",
        "score": false,
        "real_pred": "select country.Population, country.GNP",
        "real_label": "select sum(country.Population), max(country.GNP)",
        "topk_preds": [
            "select country.Population, country.GNP",
            "select country.Code, country.Name, country.Population",
            "select country.Code, country.Population, country.GNP",
            "select country.Name, country.Population",
            "select country.Code, country.Name, max(country.GNP)",
            "select country.Name, country.Population, country.GNP",
            "select sum(country.Population), sum(country.GNP)",
            "select country.IndepYear, country.GNP"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List how many people live in Asia, and the GDP of the country that has the highest GNP among them., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Sum up the numbers for all Asian countries, what is the total population and highest GNP?, database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Sum up the numbers for all Asian countries, what is the total population and highest GNP?, database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c6), max(t2.c8)",
        "label": "select sum(t2.c6), max(t2.c8)",
        "score": true,
        "real_pred": "select sum(country.Population), max(country.GNP)",
        "real_label": "select sum(country.Population), max(country.GNP)",
        "topk_preds": [
            "select sum(country.Population), max(country.GNP)",
            "select sum(country.Population), country.GNP",
            "select country.Population, country.GNP",
            "select sum(country.Population), sum(country.GNP)",
            "select sum(country.Population), maxim(country.GNP)",
            "select sum(country.Population), min(country.GNP)",
            "select sum(country.Population), top(country.GNP)",
            "select max(country.GNP), sum(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Sum up the numbers for all Asian countries, what is the total population and highest GNP?, database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total population of Asia and the highest gross national product (GNP)?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total population of Asia and the highest gross national product (GNP)?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c6), max(t2.c8)",
        "label": "select sum(t2.c6), max(t2.c8)",
        "score": true,
        "real_pred": "select sum(country.Population), max(country.GNP)",
        "real_label": "select sum(country.Population), max(country.GNP)",
        "topk_preds": [
            "select sum(country.Population), max(country.GNP)",
            "select sum(country.Population), country.GNP",
            "select sum(country.Population), sum(country.GNP)",
            "select sum(country.Population), maxim(country.GNP)",
            "select country.Population, country.GNP",
            "select sum(country.Population), top(country.GNP)",
            "select sum(country.Population), maximum(country.GNP)",
            "select sum(country.Population), highest(country.GNP)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total population of Asia and the highest gross national product (GNP)?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of all the countries that became independent later than 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of all the countries that became independent later than 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name, country.LocalName",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Region",
            "select country.Name, country.Code2",
            "select country.Name, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of all the countries that became independent later than 1950., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            "city country"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of all the countries that became independent from 1950 onwards?, database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of all the countries that became independent from 1950 onwards?, database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Capital",
            "select distinct country.Name",
            "select country.Name, country.LocalName",
            "select country.Name, country.Region",
            "select country.Name, country.Code2",
            "select country.Name, country.HeadOfState"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of all the countries that became independent from 1950 onwards?, database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average life expectancy in countries where English is not the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t2.c7)",
            "SELECT-FROM-WHERE/GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average life expectancy in countries where English is not the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.Language",
            "select an avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.CountryCode",
            "select avg(country.LifeExpectancy), countrylanguage.IsOfficial",
            "select  avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.Code",
            "select avg(country.LifeExpectancy"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average life expectancy in countries where English is not the official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "country",
            "sqlite_sequence countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the average life expectancy for countries in which English is not the official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t2.c7)",
            "SELECT-FROM-WHERE/GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the average life expectancy for countries in which English is not the official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.Language",
            "select avg(country.LifeExpectancy), countrylanguage.CountryCode",
            "select an avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy) dependant on countrylanguage.Language",
            "select avg(country.LifeExpectancy) denoted by countrylanguage.Language",
            "select avg(country.LifeExpectancy), countrylanguage.IsOfficial",
            "select  avg(country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the average life expectancy for countries in which English is not the official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "country",
            "city country countrylanguage",
            "",
            "sqlite_sequence countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the average life expectancy of the countries where English is not their official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t2.c7)",
            "SELECT-FROM-WHERE/GROUP BY-HAVING",
            "SELECT-FROM-WHERE (avg(t2.c7)",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the average life expectancy of the countries where English is not their official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.Language",
            "select an avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.CountryCode",
            "select avg(country.LifeExpectancy), countrylanguage.IsOfficial",
            "select avg(country.LifeExpectancy), country.Code",
            "select  avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy) dependant on countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the average life expectancy of the countries where English is not their official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "country",
            "",
            "sqlite_sequence countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the country codes for countries in which the language spoken is other than English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the country codes for countries in which the language spoken is other than English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0",
        "label": "select distinct t3.c0",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode",
        "real_label": "select distinct countrylanguage.CountryCode",
        "topk_preds": [
            "select countrylanguage.CountryCode",
            "select distinct countrylanguage.CountryCode",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.IsOfficial",
            "select countrylanguage.CountryCode (http://countrylanguage.CountryCode.c1)",
            "select countrylanguage.CountryCode, countrylanguage.Language, min(t3.c6)",
            "select countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.Percentage",
            "select countrylanguage.CountryCode, countrylanguage.Language, min(countrylanguage.Percentage)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the country codes for countries in which the language spoken is other than English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "sqlite_sequence countrylanguage"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the country codes for countries in which people speak languages other than English?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the country codes for countries in which people speak languages other than English?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0",
        "label": "select distinct t3.c0",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode",
        "real_label": "select distinct countrylanguage.CountryCode",
        "topk_preds": [
            "select countrylanguage.CountryCode",
            "select distinct countrylanguage.CountryCode",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.IsOfficial",
            "select countrylanguage.CountryCode, countrylanguage.Language-, countrylanguage.IsOfficial",
            "select countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.Percentage",
            "select distinct countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language, min(t3.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the country codes for countries in which people speak languages other than English?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "",
            "sqlite_sequence countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the country codes for countries in which people speak languages other than English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the country codes for countries in which people speak languages other than English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0",
        "label": "select distinct t3.c0",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode",
        "real_label": "select distinct countrylanguage.CountryCode",
        "topk_preds": [
            "select countrylanguage.CountryCode",
            "select distinct countrylanguage.CountryCode",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.IsOfficial",
            "select countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.Percentage",
            "select distinct countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language, min(t3.c6)",
            "select countrylanguage.CountryCode (ref. countrylanguage.Language)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the country codes for countries in which people speak languages other than English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "sqlite_sequence countrylanguage",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the number of official languages spoken in the countries that were established prior to 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE/GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE/GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the number of official languages spoken in the countries that were established prior to 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(distinct countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select count(countrylanguage.IsOfficial)",
            "select count(*)",
            "select count(count(distinct countrylanguage.IsOfficial)",
            "select count((distinct countrylanguage.IsOfficial)",
            "select count(1, countrylanguage.IsOfficial)",
            "select count(count(distinct countrylanguage.Language)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the number of official languages spoken in the countries that were established prior to 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the populations and averages of the countries in North America with a surface area larger than 3000., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the populations and averages of the countries in North America with a surface area larger than 3000., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c6), t2.c6",
        "label": "select sum(t2.c6), avg(t2.c4)",
        "score": false,
        "real_pred": "select avg(country.Population), country.Population",
        "real_label": "select sum(country.Population), avg(country.SurfaceArea)",
        "topk_preds": [
            "select avg(country.Population), country.Population",
            "select country.Population, avg(country.Population)",
            "select avg(country.Population), count(*)",
            "select avg(country.Population), country.LifeExpectancy",
            "select avg(country.Population), max(country.Population)",
            "select avg(country.Population)",
            "select avg(country.Population), sum(country.Population)",
            "select avg(country.Population), min(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the populations and averages of the countries in North America with a surface area larger than 3000., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the country with the most languages in use?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the country with the most languages in use?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name (country.Code)",
            "select country.Name, countrylanguage.IsOfficial",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the country with the most languages in use?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "city country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which country has the largest number of official languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which country has the largest number of official languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Continent",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name, country.Code2",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which country has the largest number of official languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "city country countrylanguage",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of the country that speaks the most languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of the country that speaks the most languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Capital",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Code",
            "select country.Name, countrylanguage.IsOfficial",
            "select country.Name (country.Code)",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of the country that speaks the most languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            "sqlite_sequence countrylanguage"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names of the top three countries in terms of population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY - LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names of the top three countries in terms of population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.LocalName",
            "select country.Name, country.Region",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names of the top three countries in terms of population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name, population, and life expectancy of the biggest country in Asia by land?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, t2.c1, t2.c6, t2.c7",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name, population, and life expectancy of the biggest country in Asia by land?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c7",
        "label": "select t2.c1, t2.c6, t2.c7",
        "score": true,
        "real_pred": "select country.Name, country.Population, country.LifeExpectancy",
        "real_label": "select country.Name, country.Population, country.LifeExpectancy",
        "topk_preds": [
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.IndepYear, country.Population, country.LifeExpectancy",
            "select country.Name, country.Code, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy, country.LifeExpectancy",
            "select country.Name, country.Population), country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy, country.GNP"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name, population, and life expectancy of the biggest country in Asia by land?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The average GDP and overall population in countries whose governments are US territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The average GDP and overall population in countries whose governments are US territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), avg(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": false,
        "real_pred": "select avg(country.GNP), avg(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), avg(country.Population)",
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.SurfaceArea), avg(country.Population)",
            "select avg(country.Population), avg(country.GNP)",
            "select avg(country.IndepYear), avg(country.Population)",
            "select avg(country.LifeExpectancy), avg(country.Population)",
            "select avg(country.GNPOld), avg(country.Population)",
            "select avg(country.GNP, avg(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The average GDP and overall population in countries whose governments are US territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest surface area of all the countries in Europe?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHEREORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest surface area of all the countries in Europe?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c4",
        "label": "select t2.c1",
        "score": false,
        "real_pred": "select country.SurfaceArea",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.SurfaceArea",
            "select max(country.SurfaceArea)",
            "select country.Code, max(country.SurfaceArea)",
            "select maxima(country.SurfaceArea)",
            "select country.Name, max(country.SurfaceArea)",
            "select country.Name, country.SurfaceArea",
            "select country.Code, country.SurfaceArea",
            "select max(country.SurfaceArea), country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest surface area of all the countries in Europe?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the countries with more land area than any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the countries with more land area than any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the countries with more land area than any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the list of countries that have a bigger surface area than any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the list of countries that have a bigger surface area than any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.SurfaceArea",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the list of countries that have a bigger surface area than any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What\u2019s the total count of languages used in the world?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM (count(distinct t3.c1)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (count(*)",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM (count(count(distinct t3.c1)",
            "SELECT-FROM (t3.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What\u2019s the total count of languages used in the world?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct countrylanguage.Language)",
            "select count(count(distinct countrylanguage.Language)",
            "select count(countrylanguage.Language)",
            "select count(1, countrylanguage.Language)",
            "select count(distinct countrylanguage.Language )",
            "select count(distinct countrylanguage.CountryCode)",
            "select count(distinct countrylanguage.IsOfficial)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What\u2019s the total count of languages used in the world?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the overall area covered by all countries in either Asia or Europe., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the overall area covered by all countries in either Asia or Europe., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Continent",
            "select sum(country.SurfaceArea), country.Name",
            "select sum(country.SurfaceArea), country.IndepYear",
            "select sum(country.SurfaceArea) delimited by country.Name",
            "select sum(country.SurfaceArea), country.Population",
            "select sum(country.SurfaceArea), country.Region",
            "select sum(country.SurfaceArea), country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the overall area covered by all countries in either Asia or Europe., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            "sqlite_sequence country"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the population and expected lifespan of the Asian nation with the biggest surface?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-C6, SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the population and expected lifespan of the Asian nation with the biggest surface?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c6, t2.c7",
        "label": "select t2.c1, t2.c6, t2.c7",
        "score": false,
        "real_pred": "select country.Population, country.LifeExpectancy",
        "real_label": "select country.Name, country.Population, country.LifeExpectancy",
        "topk_preds": [
            "select country.Population, country.LifeExpectancy",
            "select country.Code, country.Population, country.LifeExpectancy",
            "select country.Code, country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.IndepYear, country.Population, country.LifeExpectancy",
            "select country.Population, country.LifeExpectancy, country.Capital",
            "select country.Population, country.LifeExpectancy, country.HeadOfState",
            "select country.Population), country.LifeExpectancy"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the population and expected lifespan of the Asian nation with the biggest surface?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the primary language of Aruba?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the primary language of Aruba?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.LocalName",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Capital",
            "select prim countrylanguage.Language",
            "select countrylanguage.Language, country.Name",
            "select primary(countrylanguage.Language)",
            "select prim(countrylanguage.Language)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the primary language of Aruba?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What language is used most on Aruba?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-VARIATION-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What language is used most on Aruba?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.LocalName",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language (country.Name)",
            "select countrylanguage.Language, country.Code2",
            "select countrylanguage.Language, country.Name7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What language is used most on Aruba?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the most spoken language in Aruba?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-ROUTINE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the most spoken language in Aruba?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.LocalName",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Population",
            "select countrylanguage.Language (country.Name)",
            "select countrylanguage.Language, country.GNPOld"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the most spoken language in Aruba?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Aruba), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (Aruba), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the language that is used by the most Asian countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the language that is used by the most Asian countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Code2",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Continent",
            "select countrylanguage.Language (country.Name)",
            "select countrylanguage.Language, country.LocalName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the language that is used by the most Asian countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the language most commonly used by the most countries in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-C1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the language most commonly used by the most countries in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Continent",
            "select countrylanguage.Language, country.Code2",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language (country.Name)",
            "select countrylanguage.Language, country.LocalName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the language most commonly used by the most countries in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "city country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many countries have a majority of their population speaking Spanish?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many countries have a majority of their population speaking Spanish?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*), max(t3.c3)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(*), max(countrylanguage.Percentage)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countrylanguage.CountryCode",
            "select count(*), country.Name",
            "select count(*), country.Name, country.Code",
            "select count(*), country.Name, countrylanguage.CountryCode",
            "select count(*), country.Name, country.Continent",
            "select count(*), countrylanguage.CountryCode, countrylanguage.Language",
            "select count(*), country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many countries have a majority of their population speaking Spanish?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "country countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "city country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the continents and their population and average life expectancy, for those with an average life expectancy below 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the continents and their population and average life expectancy, for those with an average life expectancy below 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c2, t2.c6, avg(t2.c7)",
        "label": "select sum(t2.c6), avg(t2.c7), t2.c2",
        "score": false,
        "real_pred": "select country.Continent, country.Population, avg(country.LifeExpectancy)",
        "real_label": "select sum(country.Population), avg(country.LifeExpectancy), country.Continent",
        "topk_preds": [
            "select country.Continent, country.Population, avg(country.LifeExpectancy)",
            "select country.Continent, avg(country.Population)",
            "select country.Continent, country.IndepYear, avg(country.Population)",
            "select country.Name, country.Continent, avg(country.Population)",
            "select country.Continent, avg(country.Population), country.Population",
            "select country.Continent, country.Code, avg(country.Population)",
            "select country.Continent, country.IndepYear, avg(country.LifeExpectancy)",
            "select country.Continent, country.LifeExpectancy, avg(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the continents and their population and average life expectancy, for those with an average life expectancy below 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are all Asian countries where there are a greater number of people than that found in any African country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are all Asian countries where there are a greater number of people than that found in any African country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select distinct country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Continent",
            "select distinct country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are all Asian countries where there are a greater number of people than that found in any African country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "sqlite_sequence country",
            "",
            "city country",
            "city sqlite_sequence country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the Asian countries whose population is larger than that of any African country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the Asian countries whose population is larger than that of any African country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Continent, max(country.Population)",
            "select country.Name, country.Population",
            "select distinct country.Name",
            "select country.Name, country.Continent, country.Population",
            "select country.Name, country.Continent, min(country.Population)",
            "select country.Name, country.Continent, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the Asian countries whose population is larger than that of any African country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the codes of countries where people speak other than English?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the codes of countries where people speak other than English?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0",
        "label": "select distinct t3.c0",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode",
        "real_label": "select distinct countrylanguage.CountryCode",
        "topk_preds": [
            "select countrylanguage.CountryCode",
            "select distinct countrylanguage.CountryCode",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.Language, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the codes of countries where people speak other than English?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "sqlite_sequence countrylanguage"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries in Asia have the shortest average life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-COMPARISON-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries in Asia have the shortest average life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, avg(country.LifeExpectancy)",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, avg(country.LifeExpectancy), country.Population",
            "select country.Name de, avg(country.LifeExpectancy)",
            "select country.Name, avg(country.LifeExpectancy), country.Population",
            "select country.Name, avg(country.LifeExpectancy), country.Continent",
            "select country.Name, avg(country.LifeExpectancy), country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries in Asia have the shortest average life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the mean life expectancies in countries where the country\u2019s official languages is different from the English language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the mean life expectancies in countries where the country\u2019s official languages is different from the English language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.Language",
            "select avg(country.LifeExpectancy), countrylanguage.IsOfficial",
            "select an avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.CountryCode",
            "select avg(country.LifeExpectancy) dependant on countrylanguage.Language",
            "select avg(country.LifeExpectancy), country.Name",
            "select countryavg(country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the mean life expectancies in countries where the country\u2019s official languages is different from the English language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "country",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the Asian countries that have a larger population than any African country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the Asian countries that have a larger population than any African country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name de country.Continent",
            "select distinct country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.Code",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the Asian countries that have a larger population than any African country?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "sqlite_sequence country",
            "city country",
            "city sqlite_sequence country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the most common language in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the most common language in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Continent",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Region",
            "select countrylanguage.Language, country.Code2",
            "select countrylanguage.Language, country.HeadOfState"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the most common language in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "city country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List which language is most spoken on the Asian continent?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-NORM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-P-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List which language is most spoken on the Asian continent?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Continent",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language (country.Name)",
            "select countrylanguage.Language, country.Code2",
            "select countrylanguage.Language, country.LocalName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List which language is most spoken on the Asian continent?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the most spoken language on the Asian continent?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-NORM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the most spoken language on the Asian continent?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Continent",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language (country.Name)",
            "select countrylanguage.Language, country.Region",
            "select countrylanguage.Language, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the most spoken language on the Asian continent?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "city country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the total number of distinct official languages in the countries founded prior to 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(distinct t3.c2)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(distinct t3.c1)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (Count(distinct t3.c2)",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the total number of distinct official languages in the countries founded prior to 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(distinct countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select count(distinct t3.c6)",
            "select count(distinct countrylanguage.IsOfficial).",
            "select count(distinct t3.c)",
            "select count(distinct t3.c5)",
            "select count(distinct countrylanguage.IsOfficial",
            "select count(distinct t3.c8)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the total number of distinct official languages in the countries founded prior to 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "sqlite_sequence countrylanguage",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many different official languages were used in the countries established prior to 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(distinct t3.c2)",
            "SELECT-FROM-WHERE (count(distinct t3.c1)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-COUNT(distinct t3.c2)",
            "SELECT-FROM-WHERE-COUNT(distinct t3.c1)",
            "SELECT-FROM-WHERE(distinct t3.c2)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many different official languages were used in the countries established prior to 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c1)",
        "label": "select count(distinct t3.c1)",
        "score": true,
        "real_pred": "select count(distinct countrylanguage.Language)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.Language)",
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language, countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language, count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language, %(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language, percentage(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language, countrylanguage.IsOfficial",
            "select count(distinct countrylanguage.Language), country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many different official languages were used in the countries established prior to 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "sqlite_sequence countrylanguage",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the total count of official language in the country's founded earlier than 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE GROSS(t3.c2)",
            "SELECT-FROM-WHERE.GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the total count of official language in the country's founded earlier than 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select sum(countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select sum(countrylanguage.IsOfficial)",
            "select count(*)",
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(countrylanguage.IsOfficial)",
            "select sum(countrylanguage.IsOfficial), country.Name",
            "select sum(countrylanguage.IsOfficial), country.Code",
            "select count(distinct countrylanguage.Language)",
            "select sum(countrylanguage.Percentage)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the total count of official language in the country's founded earlier than 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the cities whose population is in the range of 160000 to 900000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the cities whose population is in the range of 160000 to 900000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select city.Name",
        "real_label": "select city.Name",
        "topk_preds": [
            "select city.Name",
            "select city.ID, city.Name",
            "select city.Name, city.District",
            "select city.Name, city.CountryCode",
            "select city.Name, city.ID",
            "select city.Name, city.Population",
            "select city.Name, t0.c6",
            "select city.Name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the cities whose population is in the range of 160000 to 900000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the cities, where their numbers range from 160000 to 900000?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the cities, where their numbers range from 160000 to 900000?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select city.Name",
        "real_label": "select city.Name",
        "topk_preds": [
            "select city.Name",
            "select city.Name, city.Population",
            "select city.ID, city.Name",
            "select city.Name, city.CountryCode",
            "select city.Name, city.ID",
            "select city.Name, city.District",
            "select city.ID, city.Name, city.Population",
            "select city.Name, city.District, city.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the cities, where their numbers range from 160000 to 900000?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of cities in each district whose population is more than the average city\u2019s population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of cities in each district whose population is more than the average city\u2019s population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*), t0.c3",
        "label": "select count(*), t0.c3",
        "score": true,
        "real_pred": "select count(*), city.District",
        "real_label": "select count(*), city.District",
        "topk_preds": [
            "select count(*), city.District",
            "select city.District, count(*)",
            "select count(*), city.District,",
            "select counts(*), city.District",
            "select count(*), t0.c 3",
            "select count(*), city.District.",
            "select count(*), city.CountryCode",
            "select count(*), city.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of cities in each district whose population is more than the average city\u2019s population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of cities in each district whose population exceeds the average population of cities., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY over-HAVING",
            "SELECT-FROM-WHERE-GROUP BY HAVING",
            "SELECT-FROM in-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY -HAVING",
            "SELECT-FROM-WHERE-GROUP BY\u2013HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of cities in each district whose population exceeds the average population of cities., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*), t0.c3",
        "label": "select count(*), t0.c3",
        "score": true,
        "real_pred": "select count(*), city.District",
        "real_label": "select count(*), city.District",
        "topk_preds": [
            "select count(*), city.District",
            "select city.District, count(*)",
            "select count(*), city.District, city.Population",
            "select count(*), city.District,",
            "select count(*), city.District, max(city.Population)",
            "select counts(*), city.District",
            "select count(*), city.District, min(city.Population)",
            "select count(*), city.District, city.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of cities in each district whose population exceeds the average population of cities., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names and area of the 5 biggest countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY - LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names and area of the 5 biggest countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c4",
        "label": "select t2.c1, t2.c4",
        "score": true,
        "real_pred": "select country.Name, country.SurfaceArea",
        "real_label": "select country.Name, country.SurfaceArea",
        "topk_preds": [
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.SurfaceArea, country.Region",
            "select country.Name, country.SurfaceArea)",
            "select country.Name, country.Region",
            "select country.Name, country.SurfaceArea\"",
            "select country.Name, country.Continent",
            "select country.Name, country.SurfaceArea,",
            "select country.Name, country.SurfaceArea."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names and area of the 5 biggest countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the languages used exclusively in one country with a republic government?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCLUS-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE - EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE/EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the languages used exclusively in one country with a republic government?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select distinct countrylanguage.Language",
            "select exclusive countrylanguage.Language",
            "select countrylanguage.Language, country.LocalName",
            "select countrylanguage.Language, country.Capital",
            "select exclusivity(countrylanguage.Language)",
            "select countrylanguage.Language, country.GovernmentForm",
            "select countrylanguage.Language, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the languages used exclusively in one country with a republic government?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the language that is used by only one country with a republic government?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-SECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the language that is used by only one country with a republic government?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.LocalName",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.GovernmentForm",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.HeadOfState",
            "select countrylanguage.Language, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the language that is used by only one country with a republic government?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the country codes of the different countries? Find the language that the largest percent uses in each., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the country codes of the different countries? Find the language that the largest percent uses in each., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0, t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode, countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.Percentage",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.Percentage",
            "select countrylanguage.CountryCode, countrylanguage.Language-, countrylanguage.Percentage",
            "select countrylanguage.CountryCode, countrylanguage.Language, percent(*)",
            "select countrylanguage.CountryCode, countrylanguage.Language, max(countrylanguage.Percentage)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the country codes of the different countries? Find the language that the largest percent uses in each., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the country codes of the different countries and which are the languages spoken by the majority of people for each?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the country codes of the different countries and which are the languages spoken by the majority of people for each?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0, t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode, countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select country.Code, countrylanguage.Language",
            "select country.Name, countrylanguage.Language",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Continent",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Code, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the country codes of the different countries and which are the languages spoken by the majority of people for each?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "country countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "countrylanguage",
            "sqlite_sequence countrylanguage",
            "city country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the country codes and show me which languages have the largest proportion in each., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the country codes and show me which languages have the largest proportion in each., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0, t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode, countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.Percentage",
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.CountryCode, countrylanguage.Language, max(countrylanguage.Percentage)",
            "select countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.Percentage",
            "select countrylanguage.CountryCode, countrylanguage.Language, max(countrylanguage.Percentage)",
            "select countrylanguage.CountryCode, countrylanguage.Language, min(countrylanguage.Percentage)",
            "select countrylanguage.CountryCode, countrylanguage.Language, percent(countrylanguage.Percentage)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the country codes and show me which languages have the largest proportion in each., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the language which is spoken by the most countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the language which is spoken by the most countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language (countrylanguage.IsOfficial)",
            "select countrylanguage.Language, countrylanguage.Percentage"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the language which is spoken by the most countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the language in which the greatest number of countries speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the language in which the greatest number of countries speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select countrylanguage.Language, countrylanguage.IsOfficial, countrylanguage.Percentage",
            "select countrylanguage.Language, countrylanguage.Percentage",
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.Language (countrylanguage.IsOfficial)",
            "select countrylanguage.Language, country.Name, countrylanguage.Percentage",
            "select countrylanguage.Language, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the language in which the greatest number of countries speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Out of which languages do the most countries speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Out of which languages do the most countries speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, countrylanguage.Percentage",
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language (countrylanguage.IsOfficial)",
            "select countrylanguage.Language, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Out of which languages do the most countries speak?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of nations that use English and Dutch?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of nations that use English and Dutch?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countrylanguage.CountryCode",
            "select count(*), countrylanguage.CountryCode, countrylanguage.Language",
            "select count(*), countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.Language",
            "select count(*), countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.IsOfficial",
            "select count(*), countrylanguage.CountryCode-font-select count(*)",
            "select count(*), countrylanguage.CountryCode - countrylanguage.Language",
            "select count(*), countrylanguage.CountryCode, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of nations that use English and Dutch?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t2 t3",
        "score": false,
        "real_pred": "countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "",
            "",
            "country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the count of countries in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the count of countries in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), country.Code",
            "select count(*), country.Name",
            "select count(*), country.Continent",
            "select count(*), country.Code2",
            "select count(*), country.Capital",
            "select count(*), country.Name6",
            "select count(*), country.LocalName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the count of countries in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the codes of the countries in which Spanish is the primary language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ON-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the codes of the countries in which Spanish is the primary language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0",
        "label": "select t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode",
        "real_label": "select countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.CountryCode",
            "select distinct countrylanguage.CountryCode",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select countrylanguage.Language",
            "select countrylanguage.CountryCode (ref. countrylanguage.Language)",
            "select spanish countrylanguage.CountryCode",
            "select t4.c0",
            "select countrylanguage.CountryCode (or countrylanguage.Language)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the codes of the countries in which Spanish is the primary language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the codes of the countries where Spanish is the most spoken language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-VARIATION-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-CENTRE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the codes of the countries where Spanish is the most spoken language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0",
        "label": "select t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode",
        "real_label": "select countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.CountryCode",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Continent",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select country.Name, country.Code",
            "select country.Name, country.Code2",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, countrylanguage.CountryCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the codes of the countries where Spanish is the most spoken language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the top 3 countries by population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the top 3 countries by population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Code, country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Region",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the top 3 countries by population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of the top 3 countries by population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY - LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of the top 3 countries by population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Region",
            "select country.Name, country.LocalName",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of the top 3 countries by population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of countries with the three highest populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMA-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEDULING-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of countries with the three highest populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name, country.LocalName",
            "select country.Name, country.Population",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Code2",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of countries with the three highest populations., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the city with the most population that uses English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-PROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the city with the most population that uses English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1, t0.c4",
        "score": false,
        "real_pred": "select city.Name",
        "real_label": "select city.Name, city.Population",
        "topk_preds": [
            "select city.Name",
            "select city.Name, countrylanguage.Language",
            "select city.ID, city.Name",
            "select city.Name, countrylanguage.IsOfficial",
            "select city.Name, countrylanguage.CountryCode",
            "select city.Name, countrylanguage.Language",
            "select city.Name (city.Population)",
            "select city.ID, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the city with the most population that uses English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "city countrylanguage",
        "real_label": "city countrylanguage",
        "topk_preds": [
            "city countrylanguage",
            "",
            "",
            "",
            "city country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the city with the most people who speak English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the city with the most people who speak English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1, t0.c4",
        "score": false,
        "real_pred": "select city.Name",
        "real_label": "select city.Name, city.Population",
        "topk_preds": [
            "select city.Name",
            "select city.Name, countrylanguage.IsOfficial",
            "select city.Name, countrylanguage.Language",
            "select city.Name, countrylanguage.CountryCode",
            "select city.Name, countrylanguage.CountryCode, city.District",
            "select city.ID, city.Name",
            "select city.Name, countrylanguage.IsOfficial, city.District",
            "select city.Name, countrylanguage.Percentage, city.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the city with the most people who speak English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0 t3",
        "label": "t0 t3",
        "score": true,
        "real_pred": "city countrylanguage",
        "real_label": "city countrylanguage",
        "topk_preds": [
            "city countrylanguage",
            "",
            "",
            "",
            "city country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name of the country that speaks the most languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name of the country that speaks the most languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Capital",
            "select country.Name, countrylanguage.Language",
            "select country.Name, country.Code",
            "select country.Name, countrylanguage.IsOfficial",
            "select country.Name (country.Code)",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name of the country that speaks the most languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the average lifespan and number of inhabitants in continents, where the average lifespan is lower than 72 years old., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOGRAPHY-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the average lifespan and number of inhabitants in continents, where the average lifespan is lower than 72 years old., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7), avg(t2.c6)",
        "label": "select sum(t2.c6), avg(t2.c7), t2.c2",
        "score": false,
        "real_pred": "select avg(country.LifeExpectancy), avg(country.Population)",
        "real_label": "select sum(country.Population), avg(country.LifeExpectancy), country.Continent",
        "topk_preds": [
            "select avg(country.LifeExpectancy), avg(country.Population)",
            "select avg(country.LifeExpectancy), count(*)",
            "select avg(country.LifeExpectancy), country.Population",
            "select avg(country.LifeExpectancy), sum(country.Population)",
            "select avg(country.Population), country.Population",
            "select avg(country.LifeExpectancy), count(country.Population)",
            "select avg(country.Population), count(*)",
            "select avg(country.Population), avg(country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the average lifespan and number of inhabitants in continents, where the average lifespan is lower than 72 years old., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the averages of the populations, years of life, and life expectancies of each continent where the average lifespan is less than 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY AVERAGE(t2.c6), t2.c5, t2.c7",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY AVERAGE(t2.c6), SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY AVERAGE(t2.c6), t2.c5, t2.c7",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the averages of the populations, years of life, and life expectancies of each continent where the average lifespan is less than 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c6, t2.c5, t2.c7",
        "label": "select sum(t2.c6), avg(t2.c7), t2.c2",
        "score": false,
        "real_pred": "select country.Population, country.IndepYear, country.LifeExpectancy",
        "real_label": "select sum(country.Population), avg(country.LifeExpectancy), country.Continent",
        "topk_preds": [
            "select country.Population, country.IndepYear, country.LifeExpectancy",
            "select avg(country.Population), avg(country.IndepYear), avg(country.LifeExpectancy), country.Continent",
            "select avg(country.Population), avg(country.IndepYear), avg(country.LifeExpectancy)",
            "select avg(country.Population), avg(country.LifeExpectancy), avg(country.LifeExpectancy), country.Continent",
            "select avg(country.Population), avg(country.LifeExpectancy), avg(country.LifeExpectancy)",
            "select country.Name, country.IndepYear, country.LifeExpectancy",
            "select avg(country.IndepYear), avg(country.LifeExpectancy), avg(country.LifeExpectancy), country.Continent",
            "select country.Population, country.IndepYear, country.LifeExpectancy, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the averages of the populations, years of life, and life expectancies of each continent where the average lifespan is less than 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which African countries have a population size less than that of any country in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which African countries have a population size less than that of any country in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select distinct country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.IndepYear",
            "select country.Name, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which African countries have a population size less than that of any country in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the African countries with less people than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the African countries with less people than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Continent",
            "select country.Name (country.Population)",
            "select country.Name de country.Continent",
            "select country.Name, country.Region"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the African countries with less people than any Asian country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me a sum of the population living in the Gelderland district., database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Gelderland, Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (t0.c4)",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me a sum of the population living in the Gelderland district., database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Gelderland, Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t0.c4)",
        "label": "select sum(t0.c4)",
        "score": true,
        "real_pred": "select sum(city.Population)",
        "real_label": "select sum(city.Population)",
        "topk_preds": [
            "select sum(city.Population)",
            "select sum(city.Population), city.District",
            "select sum(city.Population), city.District, city.Population",
            "select sum(city.Population) denoted by city.District",
            "select sum(city.Population) delimited by city.District",
            "select sum(city.Population) dependant on city.District",
            "select sum(t0, city.Population)",
            "select sum(city.Population), city.District, max(city.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me a sum of the population living in the Gelderland district., database: Database: world_1. t0: city(c0: id, c1: name (Sumy), c2: countrycode, c3: district (Gelderland, Sumy), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Sumo), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of residents in Gelderland?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Gelderland), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of residents in Gelderland?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Gelderland), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t0.c4)",
        "label": "select sum(t0.c4)",
        "score": true,
        "real_pred": "select sum(city.Population)",
        "real_label": "select sum(city.Population)",
        "topk_preds": [
            "select sum(city.Population)",
            "select city.Population",
            "select count(*)",
            "select sum(city.Population), city.District",
            "select sum(city.Population), city.District",
            "select sum(t0, city.Population)",
            "select numeric(city.Population)",
            "select total(city.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of residents in Gelderland?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Gelderland), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            "city country"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and areas of countries with the five biggest areas., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and areas of countries with the five biggest areas., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c4",
        "label": "select t2.c1, t2.c4",
        "score": true,
        "real_pred": "select country.Name, country.SurfaceArea",
        "real_label": "select country.Name, country.SurfaceArea",
        "topk_preds": [
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Region",
            "select country.Name, country.SurfaceArea)",
            "select country.Name, country.SurfaceArea,",
            "select country.Name, country.SurfaceArea\"",
            "select country.Name, country.Continent",
            "select country.Name, country.SurfaceArea.",
            "select country.Name, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and areas of countries with the five biggest areas., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names and areas of the top 5 countries by area., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names and areas of the top 5 countries by area., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c4",
        "label": "select t2.c1, t2.c4",
        "score": true,
        "real_pred": "select country.Name, country.SurfaceArea",
        "real_label": "select country.Name, country.SurfaceArea",
        "topk_preds": [
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Region",
            "select country.Name, country.Continent",
            "select country.Name, country.SurfaceArea,",
            "select country.Name, country.SurfaceArea)",
            "select country.Name, country.SurfaceArea\"",
            "select country.Name, country.SurfaceArea.",
            "select country.Name, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names and areas of the top 5 countries by area., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of the countries that speak 3 or more languages and the total number of languages they speak., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDINARY-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of the countries that speak 3 or more languages and the total number of languages they speak., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, sum(t3.c1)",
        "label": "select count(t3.c1), t2.c1",
        "score": false,
        "real_pred": "select country.Name, sum(countrylanguage.Language)",
        "real_label": "select count(countrylanguage.Language), country.Name",
        "topk_preds": [
            "select country.Name, sum(countrylanguage.Language)",
            "select country.Name, count(distinct countrylanguage.Language)",
            "select country.Name, count(*)",
            "select country.Name, count(countrylanguage.Language)",
            "select country.Name, sum(country.Name)",
            "select country.Name, sum(countrylanguage.IsOfficial)",
            "select country.Name, sum(countrylanguage.Language )",
            "select country.Name, count(distinct country.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of the countries that speak 3 or more languages and the total number of languages they speak., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "sqlite_sequence countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of cities in each district with a population that is larger than the average across all cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of cities in each district with a population that is larger than the average across all cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*), t0.c3",
        "label": "select count(*), t0.c3",
        "score": true,
        "real_pred": "select count(*), city.District",
        "real_label": "select count(*), city.District",
        "topk_preds": [
            "select count(*), city.District",
            "select city.District, count(*)",
            "select counts(*), city.District",
            "select count(*), city.District,",
            "select count(*), t0.c 3",
            "select count(*), city.CountryCode",
            "select count(*), city.District.",
            "select count(*), city.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of cities in each district with a population that is larger than the average across all cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cities in each district has a population that is greater than the average population across all cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cities in each district has a population that is greater than the average population across all cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*), t0.c3",
        "label": "select count(*), t0.c3",
        "score": true,
        "real_pred": "select count(*), city.District",
        "real_label": "select count(*), city.District",
        "topk_preds": [
            "select count(*), city.District",
            "select city.District, count(*)",
            "select counts(*), city.District",
            "select count(*), city.District,",
            "select count(*), t0.c 3",
            "select count(*), city.District.",
            "select count(*), city.CountryCode",
            "select count(*), city.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cities in each district has a population that is greater than the average population across all cities?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "city",
        "real_label": "city",
        "topk_preds": [
            "city",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the mean life expectancy in Central Africa?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Central), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region (Central Africa), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the mean life expectancy in Central Africa?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Central), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region (Central Africa), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.Region",
            "select an avg(country.LifeExpectancy)",
            "select m.avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.Population",
            "select  avg(country.LifeExpectancy)",
            "select median(country.LifeExpectancy)",
            "select Avg(country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the mean life expectancy in Central Africa?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district (Central), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region (Central Africa), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "sqlite_sequence country",
            "city country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the 3 countries with the least population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-THREE-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY - LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the 3 countries with the least population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Code, country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Capital",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Region",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the 3 countries with the least population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the three countries with the smallest population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY - LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the three countries with the smallest population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Region",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the three countries with the smallest population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Retrieve the names of the 3 nations with the lowest inhabitants., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT.",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY - LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Retrieve the names of the 3 nations with the lowest inhabitants., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.LocalName",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.Population",
            "select country.Name, country.Code2",
            "select country.Name, country.Code",
            "select country.Name (country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Retrieve the names of the 3 nations with the lowest inhabitants., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the language that is spoken in the maximum number of countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the language that is spoken in the maximum number of countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select countrylanguage.Language, countrylanguage.CountryCode",
            "select countrylanguage.Language, countrylanguage.Percentage",
            "select countrylanguage.Language (countrylanguage.IsOfficial)",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, t3.c6",
            "select countrylanguage.Language, countrylanguage.Language0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the language that is spoken in the maximum number of countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "",
            "country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which continent has the largest number of languages spoken on it?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which continent has the largest number of languages spoken on it?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c2",
        "label": "select t2.c2",
        "score": true,
        "real_pred": "select country.Continent",
        "real_label": "select country.Continent",
        "topk_preds": [
            "select country.Continent",
            "select country.Continent, countrylanguage.Language",
            "select country.Continent, country.Name",
            "select country.Continent, country.Region",
            "select country.Continent, country.Capital",
            "select country.Continent (or country.Name)",
            "select country.Continent (country.Name)",
            "select country.Continent (http://country.Continent)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which continent has the largest number of languages spoken on it?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What continent has the most number of languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GEOGRAPHY-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What continent has the most number of languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c2",
        "label": "select t2.c2",
        "score": true,
        "real_pred": "select country.Continent",
        "real_label": "select country.Continent",
        "topk_preds": [
            "select country.Continent",
            "select country.Continent, countrylanguage.Language",
            "select country.Continent, country.Name",
            "select country.Continent, country.Region",
            "select country.Continent, country.Capital",
            "select country.Continent, countrylanguage.Percentage",
            "select country.Continent, countrylanguage.CountryCode",
            "select country.Continent (or country.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What continent has the most number of languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which continent speaks the most languages in the world?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which continent speaks the most languages in the world?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c2",
        "label": "select t2.c2",
        "score": true,
        "real_pred": "select country.Continent",
        "real_label": "select country.Continent",
        "topk_preds": [
            "select country.Continent",
            "select country.Continent, countrylanguage.Language",
            "select country.Continent, country.Name",
            "select country.Continent, country.Region",
            "select country.Continent, country.Capital",
            "select country.Continent, countrylanguage.Percentage",
            "select country.Continent, countrylanguage.CountryCode",
            "select country.Continent (country.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which continent speaks the most languages in the world?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the country with the lowest life expectancy in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the country with the lowest life expectancy in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, country.LocalName",
            "select country.Name, country.Capital",
            "select country.Name, country.Region",
            "select country.Name, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the country with the lowest life expectancy in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of Asian country with the lowest average life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of Asian country with the lowest average life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Name, country.Population",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.IndepYear",
            "select country.Name (country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of Asian country with the lowest average life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name and total population for each government form whose average life expectancy is more than 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOGRAPHY-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name and total population for each government form whose average life expectancy is more than 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, sum(t2.c6)",
        "label": "select sum(t2.c6), t2.c11",
        "score": false,
        "real_pred": "select country.Name, sum(country.Population)",
        "real_label": "select sum(country.Population), country.GovernmentForm",
        "topk_preds": [
            "select country.Name, sum(country.Population)",
            "select country.GovernmentForm, sum(country.Population)",
            "select country.Capital, sum(country.Population)",
            "select country.IndepYear, sum(country.Population)",
            "select country.LocalName, sum(country.Population)",
            "select country.Code2, sum(country.Population)",
            "select country.Name, sum(country.IndepYear)",
            "select country.Name, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name and total population for each government form whose average life expectancy is more than 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name and population size for the government forms whose life expectancy is > 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name and population size for the government forms whose life expectancy is > 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6",
        "label": "select sum(t2.c6), t2.c11",
        "score": false,
        "real_pred": "select country.Name, country.Population",
        "real_label": "select sum(country.Population), country.GovernmentForm",
        "topk_preds": [
            "select country.Name, country.Population",
            "select country.GovernmentForm, country.Population",
            "select country.LocalName, country.Population",
            "select country.LocalName, country.GovernmentForm",
            "select country.Capital, country.Population",
            "select country.Code, country.GovernmentForm",
            "select country.IndepYear, country.Population",
            "select country.Code2, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name and population size for the government forms whose life expectancy is > 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "city country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me which countries have a larger area than that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me which countries have a larger area than that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Code, country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me which countries have a larger area than that of any European country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which continent has the greatest variety in languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-VARIATION-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which continent has the greatest variety in languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c2",
        "label": "select t2.c2",
        "score": true,
        "real_pred": "select country.Continent",
        "real_label": "select country.Continent",
        "topk_preds": [
            "select country.Continent",
            "select country.Continent, countrylanguage.Language",
            "select country.Code, country.Continent",
            "select country.Continent, country.Name",
            "select country.Continent, country.Region",
            "select country.Continent, country.Capital",
            "select country.Continent, countrylanguage.CountryCode",
            "select country.Continent (or country.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which continent has the greatest variety in languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the African countries with populations smaller than any country in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the African countries with populations smaller than any country in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select distinct country.Name",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select country.Name, country.Continent, country.Population",
            "select country.Name, country.Continent, country.Region",
            "select country.Name, country.Continent, min(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the African countries with populations smaller than any country in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the African countries whose populations are lower than those in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the African countries whose populations are lower than those in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Code, country.Name",
            "select distinct country.Name",
            "select country.Name, country.Region",
            "select country.Name, country.IndepYear",
            "select country.Name, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the African countries whose populations are lower than those in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many people live in non-English speaking countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE (t2.c6)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many people live in non-English speaking countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c6)",
        "label": "select sum(t2.c6)",
        "score": true,
        "real_pred": "select sum(country.Population)",
        "real_label": "select sum(country.Population)",
        "topk_preds": [
            "select sum(country.Population)",
            "select count(*)",
            "select country.Population",
            "select count(country.Population)",
            "select sum(country.IndepYear)",
            "select sum(t3.c6)",
            "select sum(country.GNP)",
            "select sum(country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many people live in non-English speaking countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many persons living in non-English speaking countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (t2.c6)",
            "SELECT-FROM-WHERE (GROUP BY",
            "SELECT-FROM-WHERE(t2.c6)",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many persons living in non-English speaking countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select sum(t2.c6)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select sum(country.Population)",
        "topk_preds": [
            "select count(*)",
            "select sum(country.Population)",
            "select count(*), countrylanguage.Language",
            "select count(*), countrylanguage.CountryCode",
            "select count(*), country.Code",
            "select count(*), country.Name",
            "select sum(country.Population), countrylanguage.Language",
            "select count(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many persons living in non-English speaking countries., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of conductors who founded orchestras later than 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of conductors who founded orchestras later than 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name (select conductor.Conductor_ID)",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Conductor_ID, orchestra.Record_Company",
            "select conductor.Name (replace conductor.Conductor_ID)",
            "select conductor.Name, orchestra.Year_of_Founded",
            "select conductor.Name (or orchestra.Conductor_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of conductors who founded orchestras later than 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the record company that has been shared by the most orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SQL-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-CLIENT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the record company that has been shared by the most orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.Year_of_Founded",
            "select orchestra.Record_Company, orchestra.Conductor_ID",
            "select orchestra.Record_Company, orchestra.Major_Record_Format",
            "select orchestra.Record_Company, t1.c6",
            "select orchestra.Record_Company (http://orchestra.Record_Company)",
            "select orchestra.Record_Company (orchestra.Record_Company)",
            "select orchestra.Record_Company (orchestra.Year_of_Founded)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the record company that has been shared by the most orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the record companies that have been shared by the largest number of orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SQL-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUPT-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the record companies that have been shared by the largest number of orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.Year_of_Founded",
            "select orchestra.Record_Company, orchestra.Conductor_ID",
            "select orchestra.Record_Company, orchestra.Major_Record_Format",
            "select orchestra.Record_Company, t1.c6",
            "select orchestra.Record_Company (orchestra.Year_of_Founded)",
            "select orchestra.Record_Company (orchestra.Record_Company)",
            "select orchestra.Record_Company, t1.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the record companies that have been shared by the largest number of orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the record company with the most orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the record company with the most orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.Year_of_Founded",
            "select orchestra.Record_Company, orchestra.Conductor_ID",
            "select orchestra.Record_Company, orchestra.Major_Record_Format",
            "select orchestra.Record_Company (orchestra.Year_of_Founded)",
            "select orchestra.Record_Company, t1.c6",
            "select orchestra.Record_Company, orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the record company with the most orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Locate the record company with the most orchestras sharing it., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-CLIENT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GAINS-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-SIGN-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Locate the record company with the most orchestras sharing it., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, performance.Share",
            "select orchestra.Record_Company, orchestra.Year_of_Founded",
            "select orchestra.Record_Company (orchestra.Record_Company)",
            "select orchestra.Record_Company, performance.Orchestra_ID",
            "select orchestra.Record_Company (http://orchestra.Record_Company)",
            "select orchestra.Record_Company (performance.Share)",
            "select orchestra.Record_Company, performance.Performance_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Locate the record company with the most orchestras sharing it., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "orchestra performance",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra performance",
            "",
            "orchestra",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the record company for the orchestras with the highest total number., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUPS-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the record company for the orchestras with the highest total number., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.Conductor_ID",
            "select orchestra.Record_Company (orchestrator-id: orchestra.Conductor_ID)",
            "select orchestra.Record_Company, orchestra.Year_of_Founded",
            "select orchestra.Record_Company (orchestrator-id orchestra.Conductor_ID)",
            "select orchestra.Record_Company (orchestrator_id)",
            "select orchestra.Record_Company (orchestrator-id)",
            "select orchestra.Record_Company (orchestrator_id orchestra.Conductor_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the record company for the orchestras with the highest total number., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "orchestra performance",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the nationality counts of conductors., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM, count(distinct t0.c3)",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM (proportionate count(distinct t0.c3)",
            "SELECT-FROM (GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the nationality counts of conductors., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select count(distinct t0.c3)",
        "label": "select count(distinct t0.c3)",
        "score": true,
        "real_pred": "select count(distinct conductor.Nationality)",
        "real_label": "select count(distinct conductor.Nationality)",
        "topk_preds": [
            "select count(distinct conductor.Nationality)",
            "select count(*)",
            "select conductor.Nationality",
            "select count(distinct conductor.Age)",
            "select counts(distinct conductor.Nationality)",
            "select count(distinct conductor.Name)",
            "select conductor.Nationality, count(*)",
            "select count(*), conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the nationality counts of conductors., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of orchestras whose record format is \"CD\" or \"DVD\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of orchestras whose record format is \"CD\" or \"DVD\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), orchestra.Major_Record_Format",
            "select t1.c count(*)",
            "select count(*), orchestra.Orchestra_ID",
            "select count(*),",
            "select count(*) - orchestra.Orchestra_ID",
            "select count(*), orchestra.Orchestra",
            "select count(*), orchestra.Year_of_Founded"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of orchestras whose record format is \"CD\" or \"DVD\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the count of orchestras that use CD/DVD format for their recordings., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the count of orchestras that use CD/DVD format for their recordings., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(distinct orchestra.Orchestra)",
            "select count(distinct orchestra.Orchestra, count(distinct orchestra.Conductor_ID)",
            "select count(distinct orchestra.Orchestra, count(distinct orchestra.Orchestra_ID)",
            "select count(distinct orchestra.Orchestra_ID)",
            "select count(*), orchestra.Major_Record_Format",
            "select count(distinct orchestra.Orchestra, count(distinct orchestra.Major_Record_Format)",
            "select count(distinct orchestra.Orchestra, count(distinct orchestra.Orchestra)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the count of orchestras that use CD/DVD format for their recordings., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the highest and lowest share percentage for all performances that does not contain the \"Live Final\" in their description., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (max(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the highest and lowest share percentage for all performances that does not contain the \"Live Final\" in their description., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select max(t2.c6), min(t2.c6)",
        "label": "select max(t2.c6), min(t2.c6)",
        "score": true,
        "real_pred": "select max(performance.Share), min(performance.Share)",
        "real_label": "select max(performance.Share), min(performance.Share)",
        "topk_preds": [
            "select max(performance.Share), min(performance.Share)",
            "select performance.Share, max(performance.Share), min(performance.Share)",
            "select max(performance.Share), min(performance.Share), performance.Performance_ID",
            "select t2.cmax(performance.Share), min(performance.Share)",
            "select max(t2.c8), min(performance.Share)",
            "select max(t2.c7), min(performance.Share)",
            "select performance.Share, max(performance.Share)",
            "select maximum(performance.Share), min(performance.Share)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the highest and lowest share percentage for all performances that does not contain the \"Live Final\" in their description., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "performance",
        "real_label": "performance",
        "topk_preds": [
            "performance",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the largest and smallest shares for performances that do not have a type of Live final., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the largest and smallest shares for performances that do not have a type of Live final., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select max(t2.c6), min(t2.c6)",
        "label": "select max(t2.c6), min(t2.c6)",
        "score": true,
        "real_pred": "select max(performance.Share), min(performance.Share)",
        "real_label": "select max(performance.Share), min(performance.Share)",
        "topk_preds": [
            "select max(performance.Share), min(performance.Share)",
            "select max(t2.c8), min(performance.Share)",
            "select max(t2.c7), min(performance.Share)",
            "select maximum(performance.Share), min(performance.Share)",
            "select max(performance.Share), performance.Share",
            "select max(performance.Weekly_rank), min(performance.Share)",
            "select max(performance.Official_ratings_in_millions), min(performance.Share)",
            "select max(performance.Date), min(performance.Share)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the largest and smallest shares for performances that do not have a type of Live final., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "performance",
        "real_label": "performance",
        "topk_preds": [
            "performance",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the largest and smallest values for performances that do not have the Live Final type., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (max(t2.c4), min(t2.c4)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (max(t2.c6), min(t2.c6)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the largest and smallest values for performances that do not have the Live Final type., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select max(t2.c4), min(t2.c4)",
        "label": "select max(t2.c6), min(t2.c6)",
        "score": false,
        "real_pred": "select max(performance.Official_ratings_in_millions), min(performance.Official_ratings_in_millions)",
        "real_label": "select max(performance.Share), min(performance.Share)",
        "topk_preds": [
            "select max(performance.Official_ratings_in_millions), min(performance.Official_ratings_in_millions)",
            "select max(performance.Share), min(performance.Share)",
            "select max(performance.Date), min(performance.Date)",
            "select max(performance.Date), min(performance.Official_ratings_in_millions)",
            "select max(t2.c8), min(t2.c8)",
            "select max(performance.Weekly_rank), min(performance.Weekly_rank)",
            "select max(t2.c7), min(t2.c7)",
            "select max(t2.c9), min(t2.c9)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the largest and smallest values for performances that do not have the Live Final type., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "performance",
        "real_label": "performance",
        "topk_preds": [
            "performance",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For performances without the type Live final, show the max and min values., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (MAX(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (MAX(t2.c4), min(t2.c4)",
            "SELECT-FROM-WHERE, MAX(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For performances without the type Live final, show the max and min values., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select max(t2.c6), min(t2.c6)",
        "label": "select max(t2.c6), min(t2.c6)",
        "score": true,
        "real_pred": "select max(performance.Share), min(performance.Share)",
        "real_label": "select max(performance.Share), min(performance.Share)",
        "topk_preds": [
            "select max(performance.Share), min(performance.Share)",
            "select max(performance.Official_ratings_in_millions), min(performance.Official_ratings_in_millions)",
            "select max(t2.c8), min(t2.c8)",
            "select max(performance.Weekly_rank), min(performance.Weekly_rank)",
            "select max(performance.Date), min(performance.Official_ratings_in_millions)",
            "select max(t2.c7), min(t2.c7)",
            "select t2.c max(performance.Share), min(performance.Share)",
            "select max(t2.c8), min(performance.Share)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For performances without the type Live final, show the max and min values., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "performance",
        "real_label": "performance",
        "topk_preds": [
            "performance",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the maximum and minimum values for performances without type \"Live final\"., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (MAX(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE (MAX(t2.c4), min(t2.c4)",
            "SELECT-FROM-WHERE (max(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the maximum and minimum values for performances without type \"Live final\"., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select max(t2.c6), min(t2.c6)",
        "label": "select max(t2.c6), min(t2.c6)",
        "score": true,
        "real_pred": "select max(performance.Share), min(performance.Share)",
        "real_label": "select max(performance.Share), min(performance.Share)",
        "topk_preds": [
            "select max(performance.Share), min(performance.Share)",
            "select max(performance.Official_ratings_in_millions), min(performance.Official_ratings_in_millions)",
            "select max(t2.c8), min(t2.c8)",
            "select max(t2.c7), min(t2.c7)",
            "select max(performance.Weekly_rank), min(performance.Weekly_rank)",
            "select max(performance.Date), min(performance.Official_ratings_in_millions)",
            "select max(t2.c9), min(t2.c9)",
            "select max(t2.c8), min(performance.Share)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the maximum and minimum values for performances without type \"Live final\"., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "performance",
        "real_label": "performance",
        "topk_preds": [
            "performance",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the major record formats of orchestras, listed by the frequency of use?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY",
        "label": "SELECT-FROM-GROUP BY-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY (LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY.LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the major record formats of orchestras, listed by the frequency of use?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c5",
        "label": "select t1.c5",
        "score": true,
        "real_pred": "select orchestra.Major_Record_Format",
        "real_label": "select orchestra.Major_Record_Format",
        "topk_preds": [
            "select orchestra.Major_Record_Format",
            "select orchestra.Major_Record_Format, t1.c6",
            "select orchestra.Major_Record_Format, orchestra.Year_of_Founded",
            "select orchestra.Major_Record_Format, t1.c7",
            "select orchestra.Major_Record_Format, orchestra.Conductor_ID",
            "select orchestra.Major_Record_Format, orchestra.Orchestra",
            "select orchestra.Major_Record_Format, t1.c8",
            "select orchestra.Major_Record_Format, orchestra.Orchestra0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the major record formats of orchestras, listed by the frequency of use?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Sort by frequency the major record formats of orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY",
        "label": "SELECT-FROM-GROUP BY-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY.",
            "SELECT-FROM-GROUP BY-ORDER BY t1.c5",
            "SELECT-FROM-GROUP BY-ORDER BY (LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY(t1.c5)",
            "SELECT-FROM-GROUP BY-ORDER BY (SCALE)",
            "SELECT-FROM-GROUP BY-ORDER BY (SCROLLING)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Sort by frequency the major record formats of orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c5",
        "label": "select t1.c5",
        "score": true,
        "real_pred": "select orchestra.Major_Record_Format",
        "real_label": "select orchestra.Major_Record_Format",
        "topk_preds": [
            "select orchestra.Major_Record_Format",
            "select orchestra.Major_Record_Format, count(*)",
            "select orchestra.Major_Record_Format, t1.c6",
            "select orchestra.Major_Record_Format, orchestra.Year_of_Founded",
            "select orchestra.Major_Record_Format, t1.c7",
            "select orchestra.Major_Record_Format, orchestra.Conductor_ID",
            "select orchestra.Major_Record_Format, t1.c8",
            "select orchestra.Major_Record_Format, orchestra.Record_Company"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Sort by frequency the major record formats of orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the major record formats of orchestras, ordered by their frequency., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY",
        "label": "SELECT-FROM-GROUP BY-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY.",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY (SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY ",
            "SELECT-FROM-GROUP BY-ORDER BY (SELECT-FROM-GROUP BY-LIMIT",
            "SELECTFROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the major record formats of orchestras, ordered by their frequency., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c5",
        "label": "select t1.c5",
        "score": true,
        "real_pred": "select orchestra.Major_Record_Format",
        "real_label": "select orchestra.Major_Record_Format",
        "topk_preds": [
            "select orchestra.Major_Record_Format",
            "select orchestra.Major_Record_Format, t1.c6",
            "select orchestra.Major_Record_Format, orchestra.Year_of_Founded",
            "select orchestra.Major_Record_Format, t1.c7",
            "select orchestra.Major_Record_Format, orchestra.Conductor_ID",
            "select orchestra.Major_Record_Format, orchestra.Orchestra",
            "select orchestra.Major_Record_Format, orchestra.Record_Company",
            "select orchestra.Major_Record_Format, t1.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the major record formats of orchestras, ordered by their frequency., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the common record types in an orchestra, from the least frequent to the most frequent., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY",
        "label": "SELECT-FROM-GROUP BY-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY (CLIENT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY (CLIENT-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY (CLIENT-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY (CLIENT-UNION-SELECT-FROM-GROUP BY-CROSS",
            "SELECT-FROM-GROUP BY-ORDER BY (CLIENT-UNION-SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY.LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the common record types in an orchestra, from the least frequent to the most frequent., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c5",
        "label": "select t1.c5",
        "score": true,
        "real_pred": "select orchestra.Major_Record_Format",
        "real_label": "select orchestra.Major_Record_Format",
        "topk_preds": [
            "select orchestra.Major_Record_Format",
            "select orchestra.Major_Record_Format, t1.c6",
            "select top-ten-record-formats-gr.1, orchestra.Major_Record_Format",
            "select orchestra.Major_Record_Format, performance.Type",
            "select top-ten-record-formats-gr.1-orchestr.c5",
            "select top-ten-record-formats-gr.1-orchestration",
            "select top-ten-record-formats-gr.1-ORDER BY",
            "select top-ten-record-formats-gr.1-orchestrated"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the common record types in an orchestra, from the least frequent to the most frequent., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "orchestra performance",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra performance",
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Describe the names of conductors from youngest to oldest., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-QUEST-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY (CLIENT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Describe the names of conductors from youngest to oldest., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name descended conductor.Age",
            "select conductor.Name in conductor.Age",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (ORDER BY",
            "select conductor.Name-ordinal"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Describe the names of conductors from youngest to oldest., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the record company used by the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the record company used by the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.Year_of_Founded",
            "select orchestra.Record_Company, orchestra.Conductor_ID",
            "select orchestra.Record_Company (http://www.orchestra.Record_Company)",
            "select orchestra.Record_Company, orchestra.Major_Record_Format",
            "select orchestra.Record_Company (orchestra.Year_of_Founded)",
            "select orchestra.Record_Company, t1.c6",
            "select orchestra.Record_Company (http://orchestra.Record_Company)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the record company used by the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the conductors that don't have US as a nationality?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the conductors that don't have US as a nationality?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID",
            "select conductor.Name, conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the conductors that don't have US as a nationality?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of conductors who have nationalities other than US?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of conductors who have nationalities other than US?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name - conductor.Nationality",
            "select conductor.Name (or conductor.Nationality)",
            "select t0, conductor.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of conductors who have nationalities other than US?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the total count of orchestras that use CD or DVD as their recording format., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE.GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the total count of orchestras that use CD or DVD as their recording format., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), orchestra.Major_Record_Format",
            "select t1.c count(*)",
            "select count(*),",
            "select t1.ccount(*)",
            "select count(*) - orchestra.Major_Record_Format",
            "select count(*), orchestra.Orchestra_ID",
            "select count(*), orchestra.Major_Record_Format,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the total count of orchestras that use CD or DVD as their recording format., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name of the conductor who has worked the most years., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name of the conductor who has worked the most years., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, conductor.Nationality, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name of the conductor who has worked the most years., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the conductor with the most working experience?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the conductor with the most working experience?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Age, conductor.Year_of_Work",
            "select conductor.Name (or conductor.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the conductor with the most working experience?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the conductor who has worked the longest?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the conductor who has worked the longest?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the conductor who has worked the longest?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Identify the conductor who have led orchestras founded since 2009., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CONDIT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Identify the conductor who have led orchestras founded since 2009., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Conductor_ID",
            "select orchestra.Conductor_ID",
            "select conductor.Name, conductor.Name",
            "select distinct conductor.Name",
            "select conductor.Name, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Identify the conductor who have led orchestras founded since 2009., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of conductors who have worked in at least two orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of conductors who have worked in at least two orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, orchestra.Orchestra",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name (conductor.Conductor_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of conductors who have worked in at least two orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of conductors who have conducted at two or more orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGEMENT-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of conductors who have conducted at two or more orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select orchestra.Conductor_ID, conductor.Name",
            "select conductor.Name (conductor.Conductor_ID)",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, orchestra.Orchestra",
            "select conductor.Name (or orchestra.Conductor_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of conductors who have conducted at two or more orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of conductors who have conducted at least 2 orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of conductors who have conducted at least 2 orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name (ORDER BY-LIMIT)",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of conductors who have conducted at least 2 orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the names of conductors who have led multiple orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUPGROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-PLURAL-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the names of conductors who have led multiple orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select orchestra.Conductor_ID, conductor.Name",
            "select conductor.Name (c0, orchestra.Conductor_ID)",
            "select conductor.Name (conductor.Conductor_ID)",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name (c0, conductor.Age)",
            "select conductor.Name (or orchestra.Conductor_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the names of conductors who have led multiple orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest and smallest percentage of performances in which the type is not \"live final\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY max(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE-GROUP BY max(t2.c4), min(t2.c4)",
            "SELECT-FROM-WHERE-GROUP BY maximum(t2.c4), min(t2.c4)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest and smallest percentage of performances in which the type is not \"live final\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select max(t2.c6), min(t2.c6)",
        "label": "select max(t2.c6), min(t2.c6)",
        "score": true,
        "real_pred": "select max(performance.Share), min(performance.Share)",
        "real_label": "select max(performance.Share), min(performance.Share)",
        "topk_preds": [
            "select max(performance.Share), min(performance.Share)",
            "select max(performance.Official_ratings_in_millions), min(performance.Official_ratings_in_millions)",
            "select max(performance.Type), min(performance.Official_ratings_in_millions)",
            "select max(performance.Weekly_rank), min(performance.Weekly_rank)",
            "select max(t2.c8), min(t2.c8)",
            "select max(performance.Date), min(performance.Date)",
            "select max(performance.Orchestra_ID), min(performance.Official_ratings_in_millions)",
            "select max(t2.c7), min(t2.c7)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest and smallest percentage of performances in which the type is not \"live final\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "performance",
        "real_label": "performance",
        "topk_preds": [
            "performance",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the highest share and lowest share of performances whose types are not live final?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the highest share and lowest share of performances whose types are not live final?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select max(t2.c6), min(t2.c6)",
        "label": "select max(t2.c6), min(t2.c6)",
        "score": true,
        "real_pred": "select max(performance.Share), min(performance.Share)",
        "real_label": "select max(performance.Share), min(performance.Share)",
        "topk_preds": [
            "select max(performance.Share), min(performance.Share)",
            "select max(t2.c8), min(performance.Share)",
            "select maximum(performance.Share), min(performance.Share)",
            "select performance.Share, t2.c7",
            "select max(t2.c7), min(performance.Share)",
            "select max(performance.Weekly_rank), min(performance.Share)",
            "select max(performance.Official_ratings_in_millions), min(performance.Share)",
            "select performance.Share, t2.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the highest share and lowest share of performances whose types are not live final?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "performance",
        "real_label": "performance",
        "topk_preds": [
            "performance",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the names of conductors with no nationality USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the names of conductors with no nationality USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Age",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the names of conductors with no nationality USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "conductor orchestra",
            "",
            "",
            "conductor orchestra performance",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Sort the names of conductors by the number of years they've been working., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t0.c1",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM\u2013ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Sort the names of conductors by the number of years they've been working., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name sort(conductor.Year_of_Work)",
            "select conductor.Name-ORDER BY"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Sort the names of conductors by the number of years they've been working., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of conductors and their length of time in order., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-QUEST-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY conductor.c1, t0.c4",
            "SELECT-FROM-ORDER BY t0.c1, t0.c4",
            "SELECT-FROM-ORDER BY (CLIENT-QUESTION-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-QUEST-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of conductors and their length of time in order., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1, t0.c4",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Name, conductor.Year_of_Work",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name, conductor.Year_of_Work",
            "select conductor.Name, t0.c6",
            "select conductor.Name, t0.c8",
            "select conductor.Name, t0.c5",
            "select conductor.Conductor_ID, conductor.Name, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of conductors and their length of time in order., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the conductors with two or more orchestral groups they are conducting., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the conductors with two or more orchestral groups they are conducting., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c2",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select orchestra.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select orchestra.Conductor_ID",
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select orchestra.Orchestra, conductor.Name",
            "select orchestra.Conductor_ID, orchestra.Orchestra",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name, conductor.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the conductors with two or more orchestral groups they are conducting., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "orchestra",
            "show orchestra",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the conductors that have conducted at least two orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the conductors that have conducted at least two orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the conductors that have conducted at least two orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the conductor who had the most orchestras under their leadership?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the conductor who had the most orchestras under their leadership?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select orchestra.Conductor_ID, conductor.Name",
            "select conductor.Name (ORDER BY-LIMIT)",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name (conductor.Conductor_ID)",
            "select conductor.Name (or orchestra.Conductor_ID)",
            "select conductor.Name (orchestra.Conductor_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the conductor who had the most orchestras under their leadership?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the conductor who conducts the largest number of orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the conductor who conducts the largest number of orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name (ORDER BY-LIMIT)",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (select conductor.Age)",
            "select conductor.Name (select conductor.Conductor_ID)",
            "select conductor.Name (conductor.Conductor_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the conductor who conducts the largest number of orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out about the musician who conducts the maximum number of orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out about the musician who conducts the maximum number of orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, t0.c6",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name the, conductor.Age",
            "select conductor.Name (or conductor.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out about the musician who conducts the maximum number of orchestras., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which conductors have conducted the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which conductors have conducted the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which conductors have conducted the most orchestras?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the years in which orchestras that have given two or more performances are founded., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the years in which orchestras that have given two or more performances are founded., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c4",
        "label": "select t1.c4",
        "score": true,
        "real_pred": "select orchestra.Year_of_Founded",
        "real_label": "select orchestra.Year_of_Founded",
        "topk_preds": [
            "select orchestra.Year_of_Founded",
            "select orchestra.Year_of_Founded (orchestrator_orchestra.Year_of_Founded)",
            "select orchestra.Year_of_Founded (orchestrator_id)",
            "select orchestra.Year_of_Founded (ORDER BY-LIMIT)",
            "select orchestra.Year_of_Founded (orchestrating_orchestra.Year_of_Founded)",
            "select orchestra.Year_of_Founded (orchestrator_orchestra.Record_Company)",
            "select orchestra.Year_of_Founded (orchestrator_c4)",
            "select orchestra.Year_of_Founded, orchestra.Major_Record_Format"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the years in which orchestras that have given two or more performances are founded., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "orchestra performance",
        "real_label": "orchestra performance",
        "topk_preds": [
            "orchestra performance",
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the years in which orchestras that have performed at least two times are founded., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the years in which orchestras that have performed at least two times are founded., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c4",
        "label": "select t1.c4",
        "score": true,
        "real_pred": "select orchestra.Year_of_Founded",
        "real_label": "select orchestra.Year_of_Founded",
        "topk_preds": [
            "select orchestra.Year_of_Founded",
            "select orchestra.Year_of_Founded (orchestrator_id)",
            "select orchestra.Year_of_Founded (orchestrator_orchestra.Year_of_Founded)",
            "select orchestra.Year_of_Founded, orchestra.Major_Record_Format",
            "select orchestra.Year_of_Founded (orchestration_id)",
            "select orchestra.Year_of_Founded (ORDER BY-LIMIT)",
            "select orchestra.Year_of_Founded (orchestrator_c4)",
            "select orchestra.Year_of_Founded (orchestrating_id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the years in which orchestras that have performed at least two times are founded., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "orchestra performance",
        "real_label": "orchestra performance",
        "topk_preds": [
            "orchestra performance",
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the name of the conductor who has been working the longest time., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the name of the conductor who has been working the longest time., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the name of the conductor who has been working the longest time., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of the conductor with the longest career., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of the conductor with the longest career., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name, conductor.Age, conductor.Nationality"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of the conductor with the longest career., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the longest-serving conductors of all those listed., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the longest-serving conductors of all those listed., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Conductor_ID",
            "select conductor.Conductor_ID, conductor.Name, conductor.Year_of_Work"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the longest-serving conductors of all those listed., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "conductor orchestra",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of the conductor who has been working for the longest time., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of the conductor who has been working for the longest time., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of the conductor who has been working for the longest time., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of conductors who have worked the longest amount of time., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of conductors who have worked the longest amount of time., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of conductors who have worked the longest amount of time., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total number of spectators per show?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY (ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY -ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY (ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total number of spectators per show?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select sum(t3.c4)",
        "label": "select avg(t3.c4)",
        "score": false,
        "real_pred": "select sum(show.Attendance)",
        "real_label": "select avg(show.Attendance)",
        "topk_preds": [
            "select sum(show.Attendance)",
            "select sum(show.Attendance), show.Show_ID",
            "select sum(show.Attendance), show.Performance_ID",
            "select sum(show.Attendance) par show.Show_ID",
            "select show.Show_ID, sum(show.Attendance)",
            "select avg(show.Attendance)",
            "select sum(show.Attendance), show.If_first_show",
            "select sum(show.Attendance) par show.Performance_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total number of spectators per show?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "show",
        "real_label": "show",
        "topk_preds": [
            "show",
            "",
            "",
            "",
            "",
            "performance show",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the years of founding for orchestras that have had at least two performances., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the years of founding for orchestras that have had at least two performances., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c4",
        "label": "select t1.c4",
        "score": true,
        "real_pred": "select orchestra.Year_of_Founded",
        "real_label": "select orchestra.Year_of_Founded",
        "topk_preds": [
            "select orchestra.Year_of_Founded",
            "select orchestra.Year_of_Founded, performance.Orchestra_ID",
            "select orchestra.Year_of_Founded, orchestra.Orchestra",
            "select orchestra.Year_of_Founded, orchestra.Major_Record_Format",
            "select orchestra.Year_of_Founded, orchestra.Orchestra_ID",
            "select orchestra.Year_of_Founded, performance.Type",
            "select orchestra.Year_of_Founded, performance.Date",
            "select orchestra.Year_of_Founded, t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the years of founding for orchestras that have had at least two performances., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "orchestra performance",
        "real_label": "orchestra performance",
        "topk_preds": [
            "orchestra performance",
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me a list of years of founding for orchestras that have performed more than once., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUPGROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me a list of years of founding for orchestras that have performed more than once., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c4",
        "label": "select t1.c4",
        "score": true,
        "real_pred": "select orchestra.Year_of_Founded",
        "real_label": "select orchestra.Year_of_Founded",
        "topk_preds": [
            "select orchestra.Year_of_Founded",
            "select orchestra.Year_of_Founded, performance.Orchestra_ID",
            "select orchestra.Year_of_Founded, orchestra.Orchestra",
            "select orchestra.Year_of_Founded, orchestra.Orchestra_ID",
            "select orchestra.Year_of_Founded, orchestra.Major_Record_Format",
            "select orchestra.Year_of_Founded, performance.Type",
            "select orchestra.Year_of_Founded, performance.Performance_ID",
            "select orchestra.Year_of_Founded, orchestra.Record_Company"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me a list of years of founding for orchestras that have performed more than once., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "orchestra performance",
        "real_label": "orchestra performance",
        "topk_preds": [
            "orchestra performance",
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the founding years for orchestras that have had multiple performances., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the founding years for orchestras that have had multiple performances., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c4",
        "label": "select t1.c4",
        "score": true,
        "real_pred": "select orchestra.Year_of_Founded",
        "real_label": "select orchestra.Year_of_Founded",
        "topk_preds": [
            "select orchestra.Year_of_Founded",
            "select orchestra.Year_of_Founded, performance.Orchestra_ID",
            "select orchestra.Year_of_Founded, orchestra.Major_Record_Format",
            "select orchestra.Year_of_Founded, performance.Type",
            "select orchestra.Year_of_Founded, orchestra.Orchestra",
            "select orchestra.Year_of_Founded, performance.Date",
            "select orchestra.Year_of_Founded, performance.Performance_ID",
            "select orchestra.Year_of_Founded, orchestra.Orchestra_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the founding years for orchestras that have had multiple performances., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "orchestra performance",
        "real_label": "orchestra performance",
        "topk_preds": [
            "orchestra performance",
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the minimum grade of students that have no friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-HAVE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-BY-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the minimum grade of students that have no friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select min(t0.c2)",
        "label": "select min(t0.c2)",
        "score": true,
        "real_pred": "select min(Highschooler.grade)",
        "real_label": "select min(Highschooler.grade)",
        "topk_preds": [
            "select min(Highschooler.grade)",
            "select min(Highschooler.grade), Highschooler.ID",
            "select min(Highschooler.grade), Highschooler.name",
            "select min(Highschooler.grade), t0.c3",
            "select min(Highschooler.grade), t0.c7",
            "select min(Highschooler.grade), t0.c4",
            "select min(Highschooler.grade), t0.c5",
            "select min(Highschooler.grade), Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the minimum grade of students that have no friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler",
            "",
            "",
            "",
            "",
            "Highschooler Friend Likes",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the least of the grades of students who do not have any friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the least of the grades of students who do not have any friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select min(t0.c2)",
        "label": "select min(t0.c2)",
        "score": true,
        "real_pred": "select min(Highschooler.grade)",
        "real_label": "select min(Highschooler.grade)",
        "topk_preds": [
            "select min(Highschooler.grade)",
            "select min(Highschooler.grade), Highschooler.ID",
            "select min(Highschooler.grade), Highschooler.name",
            "select min(Highschooler.grade), t0.c3",
            "select min(Highschooler.grade), t0.c7",
            "select min(Highschooler.grade), t0.c4",
            "select min(Highschooler.grade), t0.c5",
            "select min(Highschooler.grade), Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the least of the grades of students who do not have any friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Highschooler",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler",
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the smallest grade level that has zero friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ZERO-GROUP BY-HAVING",
            "SELECT-FROM-GEO-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the smallest grade level that has zero friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select min(t0.c2)",
        "label": "select min(t0.c2)",
        "score": true,
        "real_pred": "select min(Highschooler.grade)",
        "real_label": "select min(Highschooler.grade)",
        "topk_preds": [
            "select min(Highschooler.grade)",
            "select min(Highschooler.grade), Friend.friend_id",
            "select min(Highschooler.grade), t0.c3",
            "select min(Highschooler.grade), Highschooler.name",
            "select max(Highschooler.grade)",
            "select min(Highschooler.grade), Friend.student_id",
            "select Highschooler.grade",
            "select min(Highschooler.grade), t1.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the smallest grade level that has zero friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the high schooler who has the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the high schooler who has the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name (Highschooler.grade)",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, Likes.liked_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the high schooler who has the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "Highschooler Friend Likes",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the name of the high schooler who has the most friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the name of the high schooler who has the most friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name (Highschooler.grade)",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, Likes.liked_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the name of the high schooler who has the most friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "Highschooler Friend Likes",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the high schooler with the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the high schooler with the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name (Highschooler.grade)",
            "select Highschooler.name, t1.c3",
            "select Highschooler.name, Likes.liked_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the high schooler with the most friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of high schoolers who have more than 3 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of high schoolers who have more than 3 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (or Highschooler.grade)",
            "select Highschooler.name (Highschooler.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of high schoolers who have more than 3 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names and ids of high schoolers with 3 or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups of t0.c1, t0.c0",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names and ids of high schoolers with 3 or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1, t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Highschooler.name, Highschooler.ID",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.ID, Highschooler.name",
            "select distinct Highschooler.name, Highschooler.ID",
            "select Highschooler.name.c0, Highschooler.name",
            "select Highschooler.name, t0.c, Highschooler.ID",
            "select Highschooler.name, t0.c, Friend.student_id",
            "select Friend.friend_id, Highschooler.ID",
            "select Highschooler.name, t0-.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names and ids of high schoolers with 3 or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of high schoolers who has more or equal to 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of high schoolers who has more or equal to 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, t1.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of high schoolers who has more or equal to 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of high schoolers who have more or equal to 3 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of high schoolers who have more or equal to 3 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name Highschooler.grade"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of high schoolers who have more or equal to 3 friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all high school students that have no less than 2 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all high school students that have no less than 2 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Highschooler.ID",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.ID",
            "select Highschooler.name",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all high school students that have no less than 2 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of students that have grades above 5 and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUPS BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM groups of three"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of students that have grades above 5 and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name (Highschooler.grade)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of students that have grades above 5 and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of students who have at least 2 friends and have a grade greater than 5?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of students who have at least 2 friends and have a grade greater than 5?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select distinct Highschooler.name",
            "select Highschooler.name, t0.c5",
            "select count(Highschooler.name), Highschooler.grade",
            "select distinct Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of students who have at least 2 friends and have a grade greater than 5?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "Highschooler Likes",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of students who have a grade higher than 5, and have more or equal to 2 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CONDITION-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of students who have a grade higher than 5, and have more or equal to 2 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of students who have a grade higher than 5, and have more or equal to 2 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all students that have a grade above 5, and find out if they also have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-COL-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CONSISTENT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-COMBINED-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all students that have a grade above 5, and find out if they also have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Highschooler.name, Highschooler.grade",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, t0.c6",
            "select distinct Highschooler.name, Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all students that have a grade above 5, and find out if they also have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of students with grades higher than 5 and have two or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAGLE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of students with grades higher than 5 and have two or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (Highschooler.grade)",
            "select Highschooler.name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of students with grades higher than 5 and have two or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of likes for each student id?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM per-GROUP BY",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM-1-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of likes for each student id?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t2.c0, count(*)",
        "label": "select t2.c0, count(*)",
        "score": true,
        "real_pred": "select Likes.student_id, count(*)",
        "real_label": "select Likes.student_id, count(*)",
        "topk_preds": [
            "select Likes.student_id, count(*)",
            "select Likes.student_id, sum(t2.c3)",
            "select Likes.student_id, sum(t2.c5)",
            "select Likes.student_id, sum(t2.c8)",
            "select Likes.student_id, sum(t2.c4)",
            "select Likes.student_id, sum(t2.c2)",
            "select Likes.student_id, sum(Likes.liked_id)",
            "select Likes.student_id, sum(t2.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of likes for each student id?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Likes",
        "real_label": "Likes",
        "topk_preds": [
            "Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of the students who have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups by-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of the students who have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Likes.student_id, Highschooler.name",
            "select distinct Highschooler.name",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of the students who have two or more likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the student names that have more or equal to two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the student names that have more or equal to two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, t0.c3",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the student names that have more or equal to two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the grade with the largest number of high school students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the grade with the largest number of high school students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade, Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.grade, t0.c5",
            "select Highschooler.grade, Highschooler.ID",
            "select Highschooler.grade, t0.c7",
            "select Highschooler.grade, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the grade with the largest number of high school students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which grade has the largest amount of high schoolers?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which grade has the largest amount of high schoolers?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade, Highschooler.name",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.grade, t0.c5",
            "select Highschooler.grade, count(*)",
            "select Highschooler.grade, network_1.c1"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which grade has the largest amount of high schoolers?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "Highschooler Likes",
            "",
            "",
            "Highschooler Friend"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the count of students for each grade in high school?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM each t0.c2, count(*)",
            "SELECT-FROM for each t0.c2, count(*)",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM for each t0.c2",
            "SELECT-FROM each-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the count of students for each grade in high school?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select count(*), t0.c2",
        "label": "select t0.c2, count(*)",
        "score": false,
        "real_pred": "select count(*), Highschooler.grade",
        "real_label": "select Highschooler.grade, count(*)",
        "topk_preds": [
            "select count(*), Highschooler.grade",
            "select Highschooler.grade, count(*)",
            "select counts(*), Highschooler.grade",
            "select highschooler_Highschooler.grade, count(*)",
            "select distinct Highschooler.grade, count(*)",
            "select sum(Highschooler.grade), Highschooler.name",
            "select highschooler Highschooler.grade, count(*)",
            "select grade Highschooler.grade, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the count of students for each grade in high school?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the count of high school students for each grade?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM by-GROUP BY",
            "SELECT-FROM in-GROUP BY",
            "SELECT-FROM per-GROUP BY",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM par-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the count of high school students for each grade?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select count(*), t0.c2",
        "label": "select t0.c2, count(*)",
        "score": false,
        "real_pred": "select count(*), Highschooler.grade",
        "real_label": "select Highschooler.grade, count(*)",
        "topk_preds": [
            "select count(*), Highschooler.grade",
            "select Highschooler.grade, count(*)",
            "select highschooler Highschooler.grade, count(*)",
            "select counts(*), Highschooler.grade",
            "select sum(Highschooler.grade), Highschooler.name",
            "select Highschooler.grade, count(*), Highschooler.ID",
            "select distinct Highschooler.grade, count(*)",
            "select count(*), t0.c 2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the count of high school students for each grade?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the high schooler with the most likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-T0-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the high schooler with the most likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Likes.liked_id",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, t2.c2",
            "select Highschooler.name(Highschooler.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the high schooler with the most likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the id of a high schooler who has the highest number of likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the id of a high schooler who has the highest number of likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select Highschooler.ID",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.ID",
            "select Highschooler.ID, Highschooler.name, Highschooler.grade",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.ID, Highschooler.name, Highschooler.grade",
            "select Highschooler.ID, Highschooler.name, Highschooler.ID",
            "select t0.c, Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.ID, Highschooler.name, Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the id of a high schooler who has the highest number of likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out the name of the student with the largest number of likes in high school., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out the name of the student with the largest number of likes in high school., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade, t0.c3",
            "select Highschooler.name, Highschooler.grade, t0.c3",
            "select Highschooler.name, Highschooler.ID, Highschooler.grade",
            "select Highschooler.name, Highschooler.grade, Highschooler.ID",
            "select Highschooler.name (Highschooler.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out the name of the student with the largest number of likes in high school., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            "Highschooler Friend Likes"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all grades that have more or equal to 4 students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ISO-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-IN-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all grades that have more or equal to 4 students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade, count(*)",
            "select Highschooler.grade, max(Highschooler.ID)",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade, max(Highschooler.grade)",
            "select Highschooler.grade, max(t0.c4)",
            "select Highschooler.grade, max(t0.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all grades that have more or equal to 4 students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "Highschooler Likes",
            "Highschooler Friend",
            "",
            "",
            "Highschooler Friend Likes"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the grades that have four or more students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ISO-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the grades that have four or more students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade, count(*)",
            "select Highschooler.grade, count(*), t0.c3",
            "select Highschooler.grade, max(Highschooler.ID)",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade (or t0.c3)",
            "select Highschooler.grade del.icio.us",
            "select Highschooler.grade, count(*), Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the grades that have four or more students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "Highschooler Friend",
            "Highschooler Likes",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the grades that have 4+ students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM groups BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUPS BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY+HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the grades that have 4+ students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select distinct Highschooler.grade",
            "select distinct Highschooler.grade, t0.c3",
            "select Highschooler.grade, count(*)",
            "select Highschooler.grade, max(Highschooler.ID)",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade, max(t0.c4)",
            "select Highschooler.grade, max(Highschooler.grade)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the grades that have 4+ students., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the name of the high school student with the largest number of friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the name of the high school student with the largest number of friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name (Friend.friend_id)",
            "select Highschooler.name, Likes.liked_id",
            "select Highschooler.name (Friend.student_id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the name of the high school student with the largest number of friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the mean grade of all students who have some friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the mean grade of all students who have some friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select avg(t0.c2)",
        "label": "select avg(t0.c2)",
        "score": true,
        "real_pred": "select avg(Highschooler.grade)",
        "real_label": "select avg(Highschooler.grade)",
        "topk_preds": [
            "select avg(Highschooler.grade)",
            "select an avg(Highschooler.grade)",
            "select the avg(Highschooler.grade)",
            "select avg(t0-Highschooler.grade)",
            "select m.avg(Highschooler.grade)",
            "select mean(Highschooler.grade)",
            "select avg(Highschooler.grade),",
            "select avg(Highschooler.name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the mean grade of all students who have some friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of students that have more or equal to 2 likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of students that have more or equal to 2 likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, t0.c3",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of students that have more or equal to 2 likes?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of students who have at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of students who have at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.grade",
            "select Likes.student_id, Highschooler.name",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of students who have at least two likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of Kyle's friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of Kyle's friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Highschooler.name",
            "select count(Friend.friend_id)",
            "select count(distinct Friend.friend_id)",
            "select count(*), Highschooler.name, Friend.student_id",
            "select count(*), Highschooler.ID",
            "select count(*), Highschooler.name, Friend.student_id",
            "select count(*), Highschooler.name, t1.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of Kyle's friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name (Kyle), c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "Highschooler Friend Likes",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the grade with the most high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the grade with the most high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade, Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.grade, t0.c5",
            "select Highschooler.grade, Highschooler.ID",
            "select Highschooler.grade, count(*)",
            "select Highschooler.grade, t0.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the grade with the most high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the grade with the largest number of high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the grade with the largest number of high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select Highschooler.grade",
        "real_label": "select Highschooler.grade",
        "topk_preds": [
            "select Highschooler.grade",
            "select Highschooler.grade, t0.c3",
            "select Highschooler.grade, Highschooler.name",
            "select Highschooler.grade, t0.c5",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.grade, t0.c7",
            "select Highschooler.grade, t0.c4",
            "select Highschooler.grade, Highschooler.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the grade with the largest number of high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of high schoolers who have a grade of over 5 and have at least 2 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-CONSCIOUS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C2-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of high schoolers who have a grade of over 5 and have at least 2 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name (or Highschooler.grade)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of high schoolers who have a grade of over 5 and have at least 2 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of high schoolers who have grades higher than five and who have two or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM groups of two",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM groups of three",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUPS BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of high schoolers who have grades higher than five and who have two or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t0.c5",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, t0.c3",
            "select Highschooler.name (Highschooler.grade)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of high schoolers who have grades higher than five and who have two or more friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of high school students who have a grade of 6 or higher and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM groups of three"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of high school students who have a grade of 6 or higher and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, t0.c6",
            "select Highschooler.name, Highschooler.name",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name (or Highschooler.grade)",
            "select distinct Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of high school students who have a grade of 6 or higher and have two or more friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the total count of students in grade 9 or 10., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE_GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the total count of students in grade 9 or 10., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Highschooler.grade",
            "select count(*), Highschooler.ID",
            "select count(*), t0.c9, Highschooler.name0",
            "select count(*), t0.c9 or Highschooler.name0",
            "select count(*), Highschooler.name",
            "select count(*), Highschooler.grade, Highschooler.ID",
            "select count(*), database: network_1.c0"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the total count of students in grade 9 or 10., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of high schoolers who have at least 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of high schoolers who have at least 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (or Highschooler.grade)",
            "select Highschooler.name (Highschooler.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of high schoolers who have at least 3 friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of high schoolers that have 3+ friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of high schoolers that have 3+ friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Friend.student_id",
            "select Highschooler.name, Friend.friend_id",
            "select Highschooler.name, t1.c2",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Highschooler.ID",
            "select distinct Highschooler.name",
            "select Highschooler.name (Highschooler.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of high schoolers that have 3+ friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "",
            "",
            "Highschooler Friend Likes",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the most liked student?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the most liked student?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Likes.student_id",
            "select Likes.student_id, Highschooler.name",
            "select Highschooler.ID, Highschooler.name",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Likes.liked_id",
            "select Highschooler.name (Likes.student_id)",
            "select Highschooler.name (Highschooler.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the most liked student?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of students who have a greater number of likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-RICH-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of students who have a greater number of likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name, Highschooler.grade",
            "select Highschooler.name, Likes.liked_id",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, t0.c3",
            "select Likes.student_id, Highschooler.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of students who have a greater number of likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell me the name of the student with the largest number of likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell me the name of the student with the largest number of likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Highschooler.name",
        "real_label": "select Highschooler.name",
        "topk_preds": [
            "select Highschooler.name",
            "select Highschooler.name, Likes.student_id",
            "select Highschooler.name, Highschooler.ID",
            "select Highschooler.name (Highschooler.ID)",
            "select Highschooler.name, Likes.liked_id",
            "select Highschooler.name, Highschooler.grade",
            "select Likes.student_id, Highschooler.name",
            "select Highschooler.name(Highschooler.ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell me the name of the student with the largest number of likes., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "Highschooler Likes",
        "real_label": "Highschooler Likes",
        "topk_preds": [
            "Highschooler Likes",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the count of high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the count of high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Highschooler.ID",
            "select Highschooler.ID, count(*)",
            "select count(*), Highschooler.name",
            "select count(*), http://Highschooler.ID",
            "select t0.c count(*)",
            "select count(*), Highschooler.grade",
            "select t0.count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the count of high schoolers., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Highschooler",
        "real_label": "Highschooler",
        "topk_preds": [
            "Highschooler",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the lowest grade of students who have no friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the lowest grade of students who have no friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select min(t0.c2)",
        "label": "select min(t0.c2)",
        "score": true,
        "real_pred": "select min(Highschooler.grade)",
        "real_label": "select min(Highschooler.grade)",
        "topk_preds": [
            "select min(Highschooler.grade)",
            "select min(Highschooler.grade), Highschooler.ID",
            "select min(Highschooler.grade), Highschooler.name",
            "select min(Highschooler.grade), t0.c3",
            "select Highschooler.grade",
            "select min(Highschooler.grade), t0.c7",
            "select min(Highschooler.grade), t0.c4",
            "select min(Highschooler.grade), t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the lowest grade of students who have no friends., database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "Highschooler",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the smallest grade of students that have no friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HAVE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the smallest grade of students that have no friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "select min(t0.c2)",
        "label": "select min(t0.c2)",
        "score": true,
        "real_pred": "select min(Highschooler.grade)",
        "real_label": "select min(Highschooler.grade)",
        "topk_preds": [
            "select min(Highschooler.grade)",
            "select min(Highschooler.grade), Highschooler.ID",
            "select min(Highschooler.grade), Highschooler.name",
            "select min(Highschooler.grade), t0.c3",
            "select min(Highschooler.grade), t0.c7",
            "select min(distinct Highschooler.grade)",
            "select min(Highschooler.grade), t0.c4",
            "select min(Highschooler.grade), t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the smallest grade of students that have no friends?, database: Database: network_1. t0: highschooler(c0: id, c1: name, c2: grade). t1: friend(c0: student_id, c1: friend_id). t2: likes(c0: student_id, c1: liked_id).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Highschooler Friend",
        "real_label": "Highschooler Friend",
        "topk_preds": [
            "Highschooler Friend",
            "",
            "Highschooler Friend Likes",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who owns the largest number of dogs? List the owner ID, first name and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t4.c0, t4.c1, t4.c2",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who owns the largest number of dogs? List the owner ID, first name and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c0, t4.c1, t4.c2",
        "label": "select t5.c1, t4.c1, t4.c2",
        "score": false,
        "real_pred": "select Owners.owner_id, Owners.first_name, Owners.last_name",
        "real_label": "select Dogs.owner_id, Owners.first_name, Owners.last_name",
        "topk_preds": [
            "select Owners.owner_id, Owners.first_name, Owners.last_name",
            "select Dogs.owner_id, Owners.first_name, Owners.last_name",
            "select Sizes.size_code, Owners.first_name, Owners.last_name",
            "select Owners.owner_id-, Owners.first_name, Owners.last_name",
            "select Charges.charge_id, Owners.first_name, Owners.last_name",
            "select Sizes.size_description, Owners.first_name, Owners.last_name",
            "select Treatment_Types.treatment_type_code, Owners.first_name, Owners.last_name",
            "select Owners.owner_id, Owners.first_name, and Owners.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who owns the largest number of dogs? List the owner ID, first name and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "Owners Dogs",
        "real_label": "Owners Dogs",
        "topk_preds": [
            "Owners Dogs",
            "Sizes Owners Dogs",
            "Treatment_Types Owners Dogs",
            "Charges Owners Dogs",
            "Breeds Owners Dogs",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the owner id, first name and last name of the owner who owns the largest number of dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the owner id, first name and last name of the owner who owns the largest number of dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c0, t4.c1, t4.c2",
        "label": "select t5.c1, t4.c1, t4.c2",
        "score": false,
        "real_pred": "select Owners.owner_id, Owners.first_name, Owners.last_name",
        "real_label": "select Dogs.owner_id, Owners.first_name, Owners.last_name",
        "topk_preds": [
            "select Owners.owner_id, Owners.first_name, Owners.last_name",
            "select Dogs.owner_id, Owners.first_name, Owners.last_name",
            "select Sizes.size_code, Owners.first_name, Owners.last_name",
            "select Sizes.size_description, Owners.first_name, Owners.last_name",
            "select t8.c1, Owners.first_name, Owners.last_name",
            "select Charges.charge_id, Owners.first_name, Owners.last_name",
            "select Owners.owner_id, Owners.first_name, Owners.last_name, Owners.street",
            "select Treatment_Types.treatment_type_code, Owners.first_name, Owners.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the owner id, first name and last name of the owner who owns the largest number of dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "Owners Dogs",
        "real_label": "Owners Dogs",
        "topk_preds": [
            "Owners Dogs",
            "",
            "",
            "Sizes Owners Dogs",
            "Treatment_Types Owners Dogs",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name, email, and phone of the professional operators of more or equal to two treatment types., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING UNIVERSAL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNIVERSE-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name, email, and phone of the professional operators of more or equal to two treatment types., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c8, t6.c9",
        "label": "select t6.c0, t6.c10",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.email_address, Professionals.home_phone",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.first_name, Professionals.email_address, Professionals.home_phone",
            "select Professionals.first_name, Professionals.last_name, Professionals.home_phone",
            "select Professionals.role_code, Professionals.email_address, Professionals.home_phone",
            "select Professionals.first_name, Professionals.email_address, Professionals.home_phone",
            "select Professionals.first_name, Professionals.last_name, Professionals.email_address",
            "select Professionals.last_name, Professionals.email_address, Professionals.home_phone",
            "select Charges.charge_amount, Professionals.email_address, Professionals.home_phone",
            "select t 6.c2, Professionals.email_address, Professionals.home_phone"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name, email, and phone of the professional operators of more or equal to two treatment types., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Owners Professionals Treatments",
            "Charges Professionals Treatments",
            "Sizes Professionals Treatments",
            "Breeds Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the id and phone of professionals who operate more or equal to two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING INPUT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNIVERSAL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the id and phone of professionals who operate more or equal to two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c9",
        "label": "select t6.c0, t6.c10",
        "score": false,
        "real_pred": "select Professionals.professional_id, Professionals.home_phone",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.home_phone",
            "select Professionals.first_name, Professionals.home_phone",
            "select Professionals.role_code, Professionals.home_phone",
            "select Treatments.professional_id, Professionals.home_phone",
            "select t8.c1, Professionals.home_phone",
            "select t2.c2, Professionals.home_phone",
            "select Professionals.professional_id, Professionals.cell_number",
            "select Charges.charge_id, Professionals.home_phone"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the id and phone of professionals who operate more or equal to two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name and mobile of the professionals who run no less than two types of treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name and mobile of the professionals who run no less than two types of treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c10",
        "label": "select t6.c0, t6.c10",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.first_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.cell_number",
            "select t6).c2, Professionals.cell_number",
            "select Charges.charge_amount, Professionals.cell_number",
            "select t.c2, Professionals.cell_number",
            "select t2.c2, Professionals.cell_number",
            "select Dogs.abandoned_yn, Professionals.cell_number",
            "select t 6.c2, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name and mobile of the professionals who run no less than two types of treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Owners Professionals Treatments",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name and cell phone of all of the people who operate at least two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name and cell phone of all of the people who operate at least two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c1, t4.c2, t4.c9",
        "label": "select t6.c0, t6.c10",
        "score": false,
        "real_pred": "select Owners.first_name, Owners.last_name, Owners.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Owners.first_name, Owners.last_name, Owners.cell_number",
            "select Owners.first_name, Owners.last_name, Owners.home_phone, Owners.cell_number",
            "select Owners.first_name, Owners.last_name, Owners.cell_number, Treatments.professional_id",
            "select Owners.first_name, Owners.last_name, Owners.cell_number, Owners.home_phone",
            "select Owners.first_name, Owners.last_name",
            "select Owners.first_name, Owners.last_name, Owners.cell_number.c9",
            "select Owners.first_name, Owners.last_name, Owners.cell_number, min(Treatments.cost_of_treatment)",
            "select Owners.first_name, Owners.last_name, Owners.cell_number, Treatments.dog_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name and cell phone of all of the people who operate at least two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t7",
        "label": "t6 t7",
        "score": false,
        "real_pred": "Owners Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Owners Treatments",
            "Owners Professionals Treatments",
            "Sizes Owners Treatments",
            "Owners Dogs Professionals Treatments",
            "Treatment_Types Owners Treatments",
            "Sizes Owners Professionals Treatments",
            "",
            "Owners Dogs Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Count the number of dogs who have a lower age than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Count the number of dogs who have a lower age than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.age",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.date_of_birth",
            "select count(*), Dogs.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Count the number of dogs who have a lower age than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of dogs that have an age less than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of dogs that have an age less than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.age",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.date_of_birth",
            "select count(*), Dogs.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of dogs that have an age less than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show how many dogs are younger than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show how many dogs are younger than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.age",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.date_of_birth",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.abandoned_yn"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show how many dogs are younger than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many dogs have a smaller age than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many dogs have a smaller age than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.age",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.date_of_birth",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many dogs have a smaller age than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many dogs have a lower than the average age?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many dogs have a lower than the average age?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.age",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.date_of_birth",
            "select count(*), Dogs.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many dogs have a lower than the average age?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many dogs have a age smaller than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many dogs have a age smaller than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.age",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.name",
            "select count(*), Dogs.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many dogs have a age smaller than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many dogs are under the average age?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORSDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many dogs are under the average age?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.age",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.date_of_birth",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.abandoned_yn"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many dogs are under the average age?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much is the last treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much is the last treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c5",
        "label": "select t7.c5",
        "score": true,
        "real_pred": "select Treatments.cost_of_treatment",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Treatments.cost_of_treatment",
            "select max(Treatments.cost_of_treatment)",
            "select Treatments.cost_of_treatment, Treatments.treatment_type_code",
            "select Treatments.cost_of_treatment, Treatments.date_of_treatment",
            "select Treatments.cost_of_treatment, Treatments.dog_id",
            "select Treatments.cost_of_treatment, t7.c6",
            "select Treatments.cost_of_treatment, Treatments.professional_id",
            "select sum(Treatments.cost_of_treatment)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much is the last treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t7",
        "score": true,
        "real_pred": "Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Treatments",
            "",
            "Dogs Treatments",
            "",
            "Charges Treatments",
            "Dogs Professionals Treatments",
            "Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the costs of the last treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the costs of the last treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c5",
        "label": "select t7.c5",
        "score": true,
        "real_pred": "select Treatments.cost_of_treatment",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Treatments.cost_of_treatment",
            "select Treatments.cost_of_treatment, Treatments.date_of_treatment",
            "select Treatments.cost_of_treatment, Treatments.treatment_type_code",
            "select Treatments.cost_of_treatment, Treatments.dog_id",
            "select Treatments.cost_of_treatment, t7.c6",
            "select Treatments.cost_of_treatment - Treatments.date_of_treatment",
            "select Treatments.cost_of_treatment, Treatments.professional_id",
            "select max(Treatments.cost_of_treatment)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the costs of the last treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t7",
        "score": true,
        "real_pred": "Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Treatments",
            "Dogs Treatments",
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Breeds Treatments",
            "Charges Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much does the latest treatment cost?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much does the latest treatment cost?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c5",
        "label": "select t7.c5",
        "score": true,
        "real_pred": "select Treatments.cost_of_treatment",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Treatments.cost_of_treatment",
            "select max(Treatments.cost_of_treatment)",
            "select min(Treatments.cost_of_treatment)",
            "select max(Treatments.cost_of_treatment), Treatments.treatment_type_code",
            "select Treatments.cost_of_treatment, Treatments.date_of_treatment",
            "select Treatments.cost_of_treatment, Treatments.treatment_type_code",
            "select max(Treatments.cost_of_treatment), Treatments.dog_id",
            "select Treatments.cost_of_treatment, Treatments.dog_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much does the latest treatment cost?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t7",
        "score": true,
        "real_pred": "Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Treatments",
            "",
            "Dogs Treatments",
            "",
            "",
            "",
            "",
            "Dogs Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the cost of the latest treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ATTACH-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the cost of the latest treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c5",
        "label": "select t7.c5",
        "score": true,
        "real_pred": "select Treatments.cost_of_treatment",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Treatments.cost_of_treatment",
            "select max(Treatments.cost_of_treatment)",
            "select Treatments.cost_of_treatment, Treatments.date_of_treatment",
            "select Treatments.cost_of_treatment, Treatments.treatment_type_code",
            "select Treatments.cost_of_treatment, Treatments.dog_id",
            "select Treatments.cost_of_treatment, Treatments.professional_id",
            "select Treatments.cost_of_treatment - Treatments.date_of_treatment",
            "select Treatments.cost_of_treatment, t7.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the cost of the latest treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t7",
        "score": true,
        "real_pred": "Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Treatments",
            "Dogs Treatments",
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Breeds Treatments",
            "Charges Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total cost of the last performed treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total cost of the last performed treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select sum(t7.c5)",
        "label": "select t7.c5",
        "score": false,
        "real_pred": "select sum(Treatments.cost_of_treatment)",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select sum(Treatments.cost_of_treatment)",
            "select sum(Treatments.cost_of_treatment), Treatments.date_of_treatment",
            "select sum(Treatments.cost_of_treatment), Treatments.treatment_type_code",
            "select sum(Treatments.cost_of_treatment), Treatments.dog_id",
            "select sum(Treatments.cost_of_treatment), Treatments.professional_id",
            "select sum(Treatments.cost_of_treatment), t7.c6",
            "select sum(Treatments.cost_of_treatment), Treatments.treatment_id",
            "select sum(Treatments.cost_of_treatment), Treatments.date_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total cost of the last performed treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t7",
        "score": true,
        "real_pred": "Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Treatments",
            "Dogs Treatments",
            "Breeds Treatments",
            "Professionals Treatments",
            "Charges Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the cost of the last treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the cost of the last treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c5",
        "label": "select t7.c5",
        "score": true,
        "real_pred": "select Treatments.cost_of_treatment",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Treatments.cost_of_treatment",
            "select Treatments.cost_of_treatment, Treatments.date_of_treatment",
            "select Treatments.cost_of_treatment, Treatments.treatment_type_code",
            "select Treatments.cost_of_treatment, Treatments.dog_id",
            "select max(Treatments.cost_of_treatment)",
            "select Treatments.cost_of_treatment, t7.c6",
            "select Treatments.cost_of_treatment, Treatments.professional_id",
            "select Treatments.cost_of_treatment - Treatments.date_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the cost of the last treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t7",
        "score": true,
        "real_pred": "Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Treatments",
            "Dogs Treatments",
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Breeds Treatments",
            "Charges Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the IDs, last names and cell phones of the professionals who live in Indiana and have performed at least three treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUPE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the IDs, last names and cell phones of the professionals who live in Indiana and have performed at least three treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_",
        "prediction": "select t6.c0, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Sizes.size_code, Professionals.last_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select Dogs.dog_id, Professionals.last_name, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the IDs, last names and cell phones of the professionals who live in Indiana and have performed at least three treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest age of the dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest age of the dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select max(t5.c6)",
        "label": "select max(t5.c6)",
        "score": true,
        "real_pred": "select max(Dogs.age)",
        "real_label": "select max(Dogs.age)",
        "topk_preds": [
            "select max(Dogs.age)",
            "select max(Dogs.age), Dogs.date_of_birth",
            "select max(Dogs.age), Dogs.breed_code",
            "select max(Dogs.age), Dogs.dog_id",
            "select max(Dogs.age), Dogs.owner_id",
            "select max(Dogs.age), Dogs.weight",
            "select max(Dogs.age), Dogs.date_of_birth",
            "select max(Dogs.age), Dogs.size_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest age of the dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals have had two or more treatment types? List their ID and cellphone number., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGMENT-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGMENT-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGEMENT-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GAGEMENT-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals have had two or more treatment types? List their ID and cellphone number., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c2, t6.c10",
        "label": "select t6.c0, t6.c10",
        "score": false,
        "real_pred": "select Treatments.professional_id, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Treatments.professional_id, Professionals.cell_number",
            "select Professionals.professional_id, Professionals.cell_number",
            "select Professionals.first_name, Professionals.cell_number",
            "select Treatments.dog_id, Professionals.cell_number",
            "select t8.c2, Professionals.cell_number",
            "select t-7.c2, Professionals.cell_number",
            "select t2.c2, Professionals.cell_number",
            "select t 7.c2, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals have had two or more treatment types? List their ID and cellphone number., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the mean age of all the dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the mean age of all the dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select avg(Dogs.age).",
            "select the avg(Dogs.age)",
            "select avg(Dogs.age)",
            "select avg(Dogs.age),",
            "select Avg(Dogs.age)",
            "select avg(Dogs.date_of_birth)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the mean age of all the dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give a list of dog names, which cost $1000 or less in veterinary bills., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-Budget-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-Budget-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give a list of dog names, which cost $1000 or less in veterinary bills., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.cost_of_treatment",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Charges.charge_amount",
            "select Dogs.name, max(Treatments.cost_of_treatment)",
            "select Dogs.name, min(Treatments.cost_of_treatment)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give a list of dog names, which cost $1000 or less in veterinary bills., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t1 t5 t7",
        "label": "t5 t7",
        "score": false,
        "real_pred": "Charges Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Charges Dogs Treatments",
            "Breeds Charges Dogs Treatments",
            "Charges Sizes Dogs Treatments",
            "",
            "",
            "Dogs Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the dogs who have not cost their owners over $1000 for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the dogs who have not cost their owners over $1000 for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Dogs.age",
            "select Dogs.dog_id, Dogs.name",
            "select Dogs.name, Dogs.breed_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the dogs who have not cost their owners over $1000 for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Owners Dogs Treatments",
            "Breeds Dogs Treatments",
            "Sizes Dogs Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Describe the treatment type, whose overall costs is the lowest., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Describe the treatment type, whose overall costs is the lowest., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Treatment_Types.treatment_type_description",
        "real_label": "select Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description, t7",
            "select Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Treatment_Types.treatment_type_description, Treatments.dog_id",
            "select Treatment_Types.treatment_type_code, Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description_Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description-Treatments.treatment_type_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Describe the treatment type, whose overall costs is the lowest., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Treatment_Types Treatments",
        "real_label": "Treatment_Types Treatments",
        "topk_preds": [
            "Treatment_Types Treatments",
            "Sizes Treatment_Types Treatments",
            "Sizes Treatments",
            "Charges Treatments",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the desciption of the treatment type that has the lowest cost., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the desciption of the treatment type that has the lowest cost., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Treatment_Types.treatment_type_description",
        "real_label": "select Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Treatment_Types.treatment_type_description, t7",
            "select Treatment_Types.treatment_type_code, Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.dog_id",
            "select Treatment_Types.treatment_type_description_Treatment_Types.treatment_type_code",
            "select Treatment_Types.treatment_type_code_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the desciption of the treatment type that has the lowest cost., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Treatment_Types Treatments",
        "real_label": "Treatment_Types Treatments",
        "topk_preds": [
            "Treatment_Types Treatments",
            "Sizes Treatment_Types Treatments",
            "Breeds Treatment_Types Treatments",
            "",
            "Charges Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the desciption of the treatment for which the lowest total price was assigned?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the desciption of the treatment for which the lowest total price was assigned?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Treatment_Types.treatment_type_description",
        "real_label": "select Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description, Treatments.dog_id",
            "select Treatment_Types.treatment_type_description, t7",
            "select Treatment_Types.treatment_type_description (Treatment_Types.treatment_type_code_description)",
            "select Treatment_Types.treatment_type_description (Treatment_Types.treatment_type_code)",
            "select Treatment_Types.treatment_type_code_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the desciption of the treatment for which the lowest total price was assigned?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Treatment_Types Treatments",
        "real_label": "Treatment_Types Treatments",
        "topk_preds": [
            "Treatment_Types Treatments",
            "Sizes Treatment_Types Treatments",
            "Charges Treatment_Types Treatments",
            "Breeds Treatment_Types Treatments",
            "",
            "",
            "",
            "Owners Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the mean age of all the dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the mean age of all the dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select avg(Dogs.age).",
            "select avg(Dogs.age)",
            "select the avg(Dogs.age)",
            "select avg(Dogs.age),",
            "select avg(Dogs.age) ",
            "select avg(Dogs.date_of_birth)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the mean age of all the dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Count the number of dogs under the average age., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Count the number of dogs under the average age., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.age",
            "select count(*), avg(Dogs.age)",
            "select count(*), Dogs.dog_id",
            "select count(*) under avg(Dogs.age)",
            "select count(*), Dogs.age - Dogs.date_of_birth",
            "select count(*), Dogs.age, Dogs.date_of_birth",
            "select count(*), Dogs.age-Dogs.date_of_birth"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Count the number of dogs under the average age., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "Dogs Professionals",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many dogs are there that are younger than what would be considered the average dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-CUMULAT-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many dogs are there that are younger than what would be considered the average dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.age",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.date_of_birth",
            "select count(*), Dogs.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many dogs are there that are younger than what would be considered the average dog?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of dogs of an age smaller than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of dogs of an age smaller than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.age",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.date_of_birth",
            "select count(*), Dogs.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of dogs of an age smaller than the average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of dogs that are younger than the average age?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of dogs that are younger than the average age?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.age",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.date_of_birth",
            "select count(*), Dogs.abandoned_yn"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of dogs that are younger than the average age?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which owner has spent the most in total on their dog? Explain which is the owner\u2019s id and zip code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-C0 - SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GIG-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which owner has spent the most in total on their dog? Explain which is the owner\u2019s id and zip code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c0, t4.c6",
        "label": "select t4.c0, t4.c6",
        "score": true,
        "real_pred": "select Owners.owner_id, Owners.zip_code",
        "real_label": "select Owners.owner_id, Owners.zip_code",
        "topk_preds": [
            "select Owners.owner_id, Owners.zip_code",
            "select Treatments.dog_id, Owners.zip_code",
            "select t8.c1, Owners.zip_code",
            "select Dogs.owner_id, Owners.zip_code",
            "select Sizes.size_code, Owners.zip_code",
            "select Owners.owner_id-, Owners.zip_code",
            "select Owners.owner_id, t4c6",
            "select Charges.charge_type, Owners.zip_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which owner has spent the most in total on their dog? Explain which is the owner\u2019s id and zip code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t5 t7",
        "label": "t4 t5 t7",
        "score": true,
        "real_pred": "Owners Dogs Treatments",
        "real_label": "Owners Dogs Treatments",
        "topk_preds": [
            "Owners Dogs Treatments",
            "Sizes Owners Dogs Treatments",
            "Owners Dogs",
            "Charges Owners Dogs Treatments",
            "Treatment_Types Owners Dogs Treatments",
            "Sizes Owners Dogs",
            "Treatment_Types Owners Dogs",
            "Sizes Dogs Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which owner has paid the most total amount of money for their dogs? Show owner-id and zip-code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which owner has paid the most total amount of money for their dogs? Show owner-id and zip-code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c0, t4.c6",
        "label": "select t4.c0, t4.c6",
        "score": true,
        "real_pred": "select Owners.owner_id, Owners.zip_code",
        "real_label": "select Owners.owner_id, Owners.zip_code",
        "topk_preds": [
            "select Owners.owner_id, Owners.zip_code",
            "select Owners.first_name, Owners.last_name, Owners.zip_code",
            "select Owners.owner_id-, Owners.zip_code",
            "select Owners.owner_id, Owners.zip_code, Owners.email_address",
            "select Sizes.size_code, Owners.zip_code",
            "select Dogs.owner_id, Owners.zip_code",
            "select Owners.owner_id, t4c6",
            "select Charges.charge_id, Owners.zip_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which owner has paid the most total amount of money for their dogs? Show owner-id and zip-code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t1 t4 t5",
        "label": "t4 t5 t7",
        "score": false,
        "real_pred": "Charges Owners Dogs",
        "real_label": "Owners Dogs Treatments",
        "topk_preds": [
            "Charges Owners Dogs",
            "Owners Dogs",
            "Charges Sizes Owners Dogs",
            "Breeds Charges Owners Dogs",
            "Sizes Owners Dogs",
            "Breeds Charges Sizes Owners Dogs",
            "Treatment_Types Owners Dogs",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which owner has spent the largest sum on their dogs? Show the owner ID and ZIP code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which owner has spent the largest sum on their dogs? Show the owner ID and ZIP code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c0, t4.c6",
        "label": "select t4.c0, t4.c6",
        "score": true,
        "real_pred": "select Owners.owner_id, Owners.zip_code",
        "real_label": "select Owners.owner_id, Owners.zip_code",
        "topk_preds": [
            "select Owners.owner_id, Owners.zip_code",
            "select Dogs.owner_id, Owners.zip_code",
            "select Sizes.size_code, Owners.zip_code",
            "select Owners.owner_id-, Owners.zip_code",
            "select Owners.owner_id, t4c6",
            "select Charges.charge_id, Owners.zip_code",
            "select Owners.owner_id, t44.c6",
            "select Sizes.size_description, Owners.zip_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which owner has spent the largest sum on their dogs? Show the owner ID and ZIP code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t1 t4 t5",
        "label": "t4 t5 t7",
        "score": false,
        "real_pred": "Charges Owners Dogs",
        "real_label": "Owners Dogs Treatments",
        "topk_preds": [
            "Charges Owners Dogs",
            "Owners Dogs",
            "Breeds Charges Owners Dogs",
            "Charges Sizes Owners Dogs",
            "",
            "Charges Owners Dogs Treatments",
            "Owners Dogs Treatments",
            "Sizes Owners Dogs"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the total count of professionals who have not treated any dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE - COUNT(*)",
            "SELECT-FROM-WITH-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the total count of professionals who have not treated any dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Professionals.role_code, Professionals.last_name",
            "select count(*), Professionals.street, Professionals.last_name",
            "select count(*), Professionals.role_code, Professionals.first_name",
            "select count(*), Professionals.first_name, Professionals.last_name",
            "select count(*), Professionals.professional_id",
            "select count(*), Professionals.street",
            "select count(*), Professionals.street, Professionals.city"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the total count of professionals who have not treated any dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            "Professionals",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the count of professionals who have not treated a single dog., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WITH-WHERE",
            "SELECT-FROM-WHERE-COUNT(*)",
            "SELECT-FROM-WHERE(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the count of professionals who have not treated a single dog., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Professionals.role_code, Professionals.last_name",
            "select count(*), Professionals.street, Professionals.last_name",
            "select count(*), Professionals.first_name, Professionals.last_name",
            "select count(*), Professionals.professional_id",
            "select count(*), Professionals.role_code, Professionals.first_name",
            "select count(*), Professionals.role_code, Professionals.street",
            "select count(*), Professionals.street, Professionals.city"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the count of professionals who have not treated a single dog., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names and treatment dates of the rarest breed of dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names and treatment dates of the rarest breed of dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5, t7.c4",
        "label": "select t5.c5, t7.c4",
        "score": true,
        "real_pred": "select Dogs.name, Treatments.date_of_treatment",
        "real_label": "select Dogs.name, Treatments.date_of_treatment",
        "topk_preds": [
            "select Dogs.name, Treatments.date_of_treatment",
            "select Breeds.breed_name, Treatments.date_of_treatment",
            "select Treatment_Types.treatment_type_description, Treatments.date_of_treatment",
            "select Dogs.name, Dogs.size_code",
            "select Dogs.owner_id, Treatments.date_of_treatment",
            "select Dogs.owner_id, Treatments.date_of_treatment",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Owners.state, Treatments.date_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names and treatment dates of the rarest breed of dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t0 t5 t7",
        "label": "t5 t7",
        "score": false,
        "real_pred": "Breeds Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Breeds Dogs Treatments",
            "Breeds Charges Dogs Treatments",
            "Breeds Sizes Dogs Treatments",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the dogs with the lowest occurrence breed on the planet? Explain in detail their names and treatment dates., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT -"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the dogs with the lowest occurrence breed on the planet? Explain in detail their names and treatment dates., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5, t7.c4",
        "label": "select t5.c5, t7.c4",
        "score": true,
        "real_pred": "select Dogs.name, Treatments.date_of_treatment",
        "real_label": "select Dogs.name, Treatments.date_of_treatment",
        "topk_preds": [
            "select Dogs.name, Treatments.date_of_treatment",
            "select Dogs.name, Treatments.treatment_type_code, Treatments.date_of_treatment",
            "select Dogs.name, Dogs.size_code",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, t07.c4",
            "select Dogs.name, t7.5.c4",
            "select Dogs.name, t 7.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the dogs with the lowest occurrence breed on the planet? Explain in detail their names and treatment dates., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t0 t5 t7",
        "label": "t5 t7",
        "score": false,
        "real_pred": "Breeds Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Breeds Dogs Treatments",
            "Dogs Treatments",
            "Breeds Charges Dogs Treatments",
            "Charges Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Sizes Dogs Treatments",
            "Breeds Charges Sizes Dogs Treatments",
            "Owners Dogs Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the professional's id, roles, and first names, which are involved in treating at least two cases., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the professional's id, roles, and first names, which are involved in treating at least two cases., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c2, t6.c1, t6.c2",
        "label": "select t6.c0, t6.c1, t6.c2",
        "score": false,
        "real_pred": "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
        "real_label": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "topk_preds": [
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select t8.c2, Professionals.role_code, Professionals.first_name",
            "select Treatments.professional_id, Treatments.dog_id, Professionals.first_name",
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
            "select Charges.charge_id, Professionals.role_code, Professionals.first_name",
            "select Sizes.size_code, Professionals.role_code, Professionals.first_name",
            "select Dogs.dog_id, Professionals.role_code, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the professional's id, roles, and first names, which are involved in treating at least two cases., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the IDs, roles, and first names of the professionals who have performed at least two treatments?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the IDs, roles, and first names of the professionals who have performed at least two treatments?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c2, t6.c1, t6.c2",
        "label": "select t6.c0, t6.c1, t6.c2",
        "score": false,
        "real_pred": "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
        "real_label": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "topk_preds": [
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select t8.c2, Professionals.role_code, Professionals.first_name",
            "select Treatments.dog_id, Professionals.role_code, Professionals.first_name",
            "select Sizes.size_code, Professionals.role_code, Professionals.first_name",
            "select Dogs.dog_id, Professionals.role_code, Professionals.first_name",
            "select Charges.charge_id, Professionals.role_code, Professionals.first_name",
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the IDs, roles, and first names of the professionals who have performed at least two treatments?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "Treatment_Types Professionals Treatments",
            "Owners Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids, roles, and first names of the professionals who have performed more than one treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSIST-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids, roles, and first names of the professionals who have performed more than one treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c2, t6.c1, t6.c2",
        "label": "select t6.c0, t6.c1, t6.c2",
        "score": false,
        "real_pred": "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
        "real_label": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "topk_preds": [
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select t8.c2, Professionals.role_code, Professionals.first_name",
            "select Treatments.dog_id, Professionals.role_code, Professionals.first_name",
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
            "select t2.c2, Professionals.role_code, Professionals.first_name",
            "select Sizes.size_code, Professionals.role_code, Professionals.first_name",
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids, roles, and first names of the professionals who have performed more than one treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the description of the treatment type that costs the least amount in total., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the description of the treatment type that costs the least amount in total., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Treatment_Types.treatment_type_description",
        "real_label": "select Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Treatment_Types.treatment_type_description, t7",
            "select Treatment_Types.treatment_type_description, Treatments.dog_id",
            "select Treatment_Types.treatment_type_description(Treatments.cost_of_treatment)",
            "select Treatment_Types.treatment_type_description (Treatment_Types.treatment_type_code)",
            "select Treatment_Types.treatment_type_description (Treatments.treatment_type_code)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the description of the treatment type that costs the least amount in total., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Treatment_Types Treatments",
        "real_label": "Treatment_Types Treatments",
        "topk_preds": [
            "Treatment_Types Treatments",
            "Sizes Treatment_Types Treatments",
            "Breeds Treatment_Types Treatments",
            "",
            "",
            "Charges Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the description of treatment type that has the lowest cost in terms of price?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the description of treatment type that has the lowest cost in terms of price?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Treatment_Types.treatment_type_description",
        "real_label": "select Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Treatment_Types.treatment_type_description, t7",
            "select Treatment_Types.treatment_type_code, Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.dog_id",
            "select Treatment_Types.treatment_type_description (Treatment_Types.treatment_type_code)",
            "select Treatment_Types.treatment_type_description(Treatments.cost_of_treatment)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the description of treatment type that has the lowest cost in terms of price?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Treatment_Types Treatments",
        "real_label": "Treatment_Types Treatments",
        "topk_preds": [
            "Treatment_Types Treatments",
            "Sizes Treatment_Types Treatments",
            "Breeds Treatment_Types Treatments",
            "",
            "",
            "",
            "Charges Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the description of overall cheapest treatment option?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-OPERATION-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the description of overall cheapest treatment option?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Treatment_Types.treatment_type_description",
        "real_label": "select Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description, Treatments.dog_id",
            "select Treatment_Types.treatment_type_description, Treatments.cost_of_treatment",
            "select Treatment_Types.treatment_type_code_description",
            "select Treatment_Types.treatment_type_description, t7",
            "select Treatment_Types.treatment_type_description (Treatment_Types.treatment_type_code)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the description of overall cheapest treatment option?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Treatment_Types Treatments",
        "real_label": "Treatment_Types Treatments",
        "topk_preds": [
            "Treatment_Types Treatments",
            "Sizes Treatment_Types Treatments",
            "Breeds Treatment_Types Treatments",
            "Charges Treatment_Types Treatments",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is thedescription of the treatment type that costs less money than others?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is thedescription of the treatment type that costs less money than others?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Treatment_Types.treatment_type_description",
        "real_label": "select Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, t7",
            "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Treatment_Types.treatment_type_code, Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.dog_id",
            "select Treatment_Types.treatment_type_code_description",
            "select Treatment_Types.treatment_type_description_Treatment_Types.treatment_type_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is thedescription of the treatment type that costs less money than others?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Treatment_Types Treatments",
        "real_label": "Treatment_Types Treatments",
        "topk_preds": [
            "Treatment_Types Treatments",
            "Sizes Treatment_Types Treatments",
            "Breeds Treatment_Types Treatments",
            "",
            "Charges Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the mean age of the dogs who were treated?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM the avg(t5.c6)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM ACT-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM t7",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the mean age of the dogs who were treated?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select avg(t5.c6)",
        "label": "select avg(t5.c6)",
        "score": true,
        "real_pred": "select avg(Dogs.age)",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select avg(Dogs.age)",
            "select Treatments.date_of_treatment, avg(Dogs.age)",
            "select an avg(Dogs.age)",
            "select avg(Dogs.age), t7",
            "select avg(Dogs.age), Treatments.dog_id",
            "select avg(Dogs.age), Treatments.date_of_treatment",
            "select the avg(Dogs.age)",
            "select avg(Dogs.age), Treatments.professional_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the mean age of the dogs who were treated?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals has operated a treatment that costs under the average? Give me their first and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals has operated a treatment that costs under the average? Give me their first and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select the Professionals.first_name, Professionals.last_name",
            "select t.c2, Professionals.last_name",
            "select Dogs.abandoned_yn, Professionals.last_name",
            "select t6).c2, Professionals.last_name",
            "select t 6.c2, Professionals.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals has operated a treatment that costs under the average? Give me their first and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Sizes Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name all the professionals who ran a treatment that was cheaper than the average, give their first and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name all the professionals who ran a treatment that was cheaper than the average, give their first and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select t 6.c2, Professionals.last_name",
            "select Charges.charge_amount, Professionals.last_name",
            "select t.c2, Professionals.last_name",
            "select Dogs.abandoned_yn, Professionals.last_name",
            "select Professionals.first_name, t 6.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name all the professionals who ran a treatment that was cheaper than the average, give their first and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Charges Professionals Treatments",
            "Sizes Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the maximum charge type cost?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY max(t1.c2)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY max(t1.c2)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the maximum charge type cost?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select max(t1.c2)",
        "label": "select max(t1.c2)",
        "score": true,
        "real_pred": "select max(Charges.charge_amount)",
        "real_label": "select max(Charges.charge_amount)",
        "topk_preds": [
            "select max(Charges.charge_amount)",
            "select max(Charges.charge_amount), Charges.charge_type",
            "select max(Charges.charge_amount) dependant on Charges.charge_type",
            "select Charges.charge_type, max(Charges.charge_amount)",
            "select max(Charges.charge_amount), Charges.charge_type.",
            "select maximum(Charges.charge_amount), Charges.charge_type",
            "select Max(Charges.charge_amount), Charges.charge_type",
            "select max(Charges.charge_amount), Charges.charge_type,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the maximum charge type cost?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Charges",
        "real_label": "Charges",
        "topk_preds": [
            "Charges",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How old are the dogs who have been treated?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM ACT-GROUP BY-HAVING",
            "SELECT-FROM t7"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How old are the dogs who have been treated?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c6",
        "label": "select avg(t5.c6)",
        "score": false,
        "real_pred": "select Dogs.age",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select Dogs.age",
            "select distinct Dogs.age",
            "select Dogs.dog_id, Dogs.age",
            "select sum(Dogs.age)",
            "select Dogs.age, Treatments.date_of_treatment",
            "select the Dogs.age",
            "select Dogs.age, Treatments.dog_id",
            "select age(Dogs.age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How old are the dogs who have been treated?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the dogs' ages who have gone through at least one treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ATTACH-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ATTACHMENT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the dogs' ages who have gone through at least one treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c6",
        "label": "select avg(t5.c6)",
        "score": false,
        "real_pred": "select Dogs.age",
        "real_label": "select avg(Dogs.age)",
        "topk_preds": [
            "select Dogs.age",
            "select distinct Dogs.age",
            "select Dogs.dog_id, Dogs.age",
            "select at least Dogs.age",
            "select Dogs.age, Treatments.dog_id",
            "select Dogs.age, Treatments.professional_id",
            "select Dogs.age, Treatments.date_of_treatment",
            "select distinct Dogs.age, Treatments.dog_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the dogs' ages who have gone through at least one treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The latest procedure costs how much?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The latest procedure costs how much?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c5",
        "label": "select t7.c5",
        "score": true,
        "real_pred": "select Treatments.cost_of_treatment",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Treatments.cost_of_treatment",
            "select max(Treatments.cost_of_treatment)",
            "select Treatments.cost_of_treatment, Treatments.treatment_type_code",
            "select Treatments.cost_of_treatment, Treatments.dog_id",
            "select Treatments.cost_of_treatment, Treatments.professional_id",
            "select Treatments.cost_of_treatment, t7.c6",
            "select Treatments.cost_of_treatment, Treatments.date_of_treatment",
            "select min(Treatments.cost_of_treatment)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The latest procedure costs how much?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t7",
        "score": true,
        "real_pred": "Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Treatments",
            "Charges Treatments",
            "Breeds Charges Treatments",
            "Dogs Treatments",
            "Breeds Treatments",
            "Dogs Professionals Treatments",
            "Treatment_Types Treatments",
            "Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much does the last procedure cost?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much does the last procedure cost?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c5",
        "label": "select t7.c5",
        "score": true,
        "real_pred": "select Treatments.cost_of_treatment",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Treatments.cost_of_treatment",
            "select Treatments.cost_of_treatment, Treatments.dog_id",
            "select Treatments.cost_of_treatment, Treatments.treatment_type_code",
            "select Treatments.cost_of_treatment, Treatments.professional_id",
            "select max(Treatments.cost_of_treatment)",
            "select Treatments.cost_of_treatment, t7.c6",
            "select Treatments.cost_of_treatment, Treatments.date_of_treatment",
            "select Treatments.cost_of_treatment.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much does the last procedure cost?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t7",
        "score": true,
        "real_pred": "Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Treatments",
            "Charges Treatments",
            "Breeds Charges Treatments",
            "Dogs Treatments",
            "Treatment_Types Treatments",
            "Professionals Treatments",
            "Breeds Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of dogs that the owner did not spend over $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-NO-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-MISSION-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of dogs that the owner did not spend over $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.name, Dogs.age",
            "select Dogs.name, Dogs.breed_code",
            "select Dogs.name, Dogs.dog_id",
            "select Dogs.name, Dogs.date_of_birth",
            "select Dogs.name, Treatments.professional_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of dogs that the owner did not spend over $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Owners Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Sizes Dogs Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of the dogs whose owners have spent equal or less than 1000 USD for their treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of the dogs whose owners have spent equal or less than 1000 USD for their treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Dogs.age",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Dogs.date_of_birth",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.name, Dogs.breed_code",
            "select Dogs.name, Dogs.abandoned_yn",
            "select Dogs.name, Dogs.dog_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of the dogs whose owners have spent equal or less than 1000 USD for their treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Owners Dogs Treatments",
            "Sizes Dogs Treatments",
            "Breeds Dogs Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the dogs with at most 1000 spent for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING - SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the dogs with at most 1000 spent for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Dogs.breed_code",
            "select Dogs.name, Dogs.age",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.treatment_type_code",
            "select Dogs.name, Treatments.treatment_id",
            "select max(Treatments.cost_of_treatment)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the dogs with at most 1000 spent for treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the breed with the largest number of dogs?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the breed with the largest number of dogs?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Breeds.breed_name",
        "real_label": "select Breeds.breed_name",
        "topk_preds": [
            "select Breeds.breed_name",
            "select Breeds.breed_name, Dogs.breed_code",
            "select Breeds.breed_name, Dogs.breed_code, Dogs.size_code",
            "select Breeds.breed_code, Breeds.breed_name",
            "select Breeds.breed_name (synonymous Dogs.breed_code)",
            "select Breeds.breed_name (synonymous with Dogs.breed_code)",
            "select Breeds.breed_name (Dogs.breed_code)",
            "select Breeds.breed_name, Dogs.breed_code - Dogs.size_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the breed with the largest number of dogs?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t0 t5",
        "label": "t0 t5",
        "score": true,
        "real_pred": "Breeds Dogs",
        "real_label": "Breeds Dogs",
        "topk_preds": [
            "Breeds Dogs",
            "Breeds Charges Dogs",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total count of the dogs that has not received any treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total count of the dogs that has not received any treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Dogs.breed_code",
            "select count(*), Dogs.dog_id",
            "select count(*), Dogs.abandoned_yn",
            "select t5.c count(*)",
            "select count(*), Dogs.owner_id",
            "select count(*), Dogs.size_code",
            "select count(*), Dogs.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total count of the dogs that has not received any treatment?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs",
            "",
            "",
            "",
            "",
            "Dogs Professionals",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the sum of dogs without a treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WITH-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the sum of dogs without a treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select sum(t5.c0)",
        "label": "select count(*)",
        "score": false,
        "real_pred": "select sum(Dogs.dog_id)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select sum(Dogs.dog_id)",
            "select sum(Dogs.name)",
            "select count(*)",
            "select sum(Dogs.age)",
            "select sum(Dogs.gender)",
            "select sum(Dogs.size_code)",
            "select sum(Dogs.date_of_birth)",
            "select sum(Dogs.owner_id)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the sum of dogs without a treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who have performed two (or more) treatments? List each professional\u2019s id, role, first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INSTANCE-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who have performed two (or more) treatments? List each professional\u2019s id, role, first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c1, t6.c2",
        "label": "select t6.c0, t6.c1, t6.c2",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "real_label": "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.first_name, Professionals.last_name",
            "select Treatments.professional_id, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.role_code, Professionals.first_name",
            "select Professionals.professional_id, Professionals.first_name, Professionals.role_code",
            "select t8.c2, Professionals.role_code, Professionals.first_name",
            "select Dogs.dog_id, Professionals.role_code, Professionals.first_name",
            "select Charges.charge_id, Professionals.role_code, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who have performed two (or more) treatments? List each professional\u2019s id, role, first name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "",
            "",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out the first and last names of the professionals who have done treatments with cost less than average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out the first and last names of the professionals who have done treatments with cost less than average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select Professionals.professional_id, Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select Professionals.first_name, Professionals.last_name, Professionals.professional_id",
            "select t6).c2, Professionals.last_name",
            "select Dogs.abandoned_yn, Professionals.last_name",
            "select t 6.c2, Professionals.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out the first and last names of the professionals who have done treatments with cost less than average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Sizes Professionals Treatments",
            "Breeds Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the first and last names of the professionals who did treatment with a cost smaller than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the first and last names of the professionals who did treatment with a cost smaller than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select Professionals.professional_id, Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select Professionals.first_name, Professionals.last_name, Treatments.professional_id",
            "select Professionals.first_name, Professionals.last_name, Professionals.professional_id",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select t6).c2, Professionals.last_name",
            "select Dogs.abandoned_yn, Professionals.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the first and last names of the professionals who did treatment with a cost smaller than the average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Sizes Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the first and last name of professional that had treatment at a lower cost than average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the first and last name of professional that had treatment at a lower cost than average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select Professionals.professional_id, Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select Professionals.first_name, Professionals.last_name, Professionals.professional_id",
            "select t6).c2, Professionals.last_name",
            "select t 6.c2, Professionals.last_name",
            "select Dogs.abandoned_yn, Professionals.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the first and last name of professional that had treatment at a lower cost than average?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Sizes Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the first and last name of the professionals who has done an operation of a certain kind, under an average cost., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the first and last name of the professionals who has done an operation of a certain kind, under an average cost., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select Professionals.professional_id, Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select Professionals.first_name, Professionals.last_name, avg(Treatments.cost_of_treatment)",
            "select Professionals.first_name, Professionals.last_name, min(Treatments.cost_of_treatment)",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select Professionals.first_name, Professionals.last_name, Professionals.professional_id",
            "select t.c2, Professionals.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the first and last name of the professionals who has done an operation of a certain kind, under an average cost., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Charges Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Owners Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Sizes Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the owner ID and zip code of the owner who spent the largest amount of money on his or her dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-C0 - SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the owner ID and zip code of the owner who spent the largest amount of money on his or her dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c0, t4.c6",
        "label": "select t4.c0, t4.c6",
        "score": true,
        "real_pred": "select Owners.owner_id, Owners.zip_code",
        "real_label": "select Owners.owner_id, Owners.zip_code",
        "topk_preds": [
            "select Owners.owner_id, Owners.zip_code",
            "select Sizes.size_code, Owners.zip_code",
            "select Owners.owner_id-, Owners.zip_code",
            "select Dogs.owner_id, Owners.zip_code",
            "select Charges.charge_id, Owners.zip_code",
            "select Owners.owner_id, t4c6",
            "select Owners.first_name, Owners.zip_code",
            "select Sizes.size_description, Owners.zip_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the owner ID and zip code of the owner who spent the largest amount of money on his or her dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t1 t4 t5",
        "label": "t4 t5 t7",
        "score": false,
        "real_pred": "Charges Owners Dogs",
        "real_label": "Owners Dogs Treatments",
        "topk_preds": [
            "Charges Owners Dogs",
            "Owners Dogs",
            "Breeds Charges Owners Dogs",
            "Charges Sizes Owners Dogs",
            "",
            "Sizes Owners Dogs",
            "",
            "Charges Owners Dogs Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What owner have paid the most amount of money on his or her dog treatments? List the owners ID and full name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C0, t4.c1, t4.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What owner have paid the most amount of money on his or her dog treatments? List the owners ID and full name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c0, t4.c1, t4.c2",
        "label": "select t4.c0, t4.c2",
        "score": false,
        "real_pred": "select Owners.owner_id, Owners.first_name, Owners.last_name",
        "real_label": "select Owners.owner_id, Owners.last_name",
        "topk_preds": [
            "select Owners.owner_id, Owners.first_name, Owners.last_name",
            "select Treatments.professional_id, Owners.first_name, Owners.last_name",
            "select Treatments.dog_id, Owners.first_name, Owners.last_name",
            "select Charges.charge_id, Owners.first_name, Owners.last_name",
            "select t8.c1, Owners.first_name, Owners.last_name",
            "select Sizes.size_code, Owners.first_name, Owners.last_name",
            "select Dogs.owner_id, Owners.first_name, Owners.last_name",
            "select t9.c0, Owners.first_name, Owners.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What owner have paid the most amount of money on his or her dog treatments? List the owners ID and full name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t1 t4 t7",
        "label": "t4 t5 t7",
        "score": false,
        "real_pred": "Charges Owners Treatments",
        "real_label": "Owners Dogs Treatments",
        "topk_preds": [
            "Charges Owners Treatments",
            "",
            "Charges Owners Dogs Treatments",
            "Charges Sizes Treatments",
            "",
            "Breeds Charges Owners Treatments",
            "Owners Treatments",
            "Sizes Owners Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the singer that has the highest revenue?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the singer that has the highest revenue?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, song.Sales",
            "select singer.Name, song.Title",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, song.Song_ID",
            "select singer.Name (song.Sales)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the singer that has the highest revenue?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0",
        "score": false,
        "real_pred": "singer song",
        "real_label": "singer",
        "topk_preds": [
            "singer song",
            "singer",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the singer who has the most amount of earnings?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the singer who has the most amount of earnings?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name (ORDER BY-LIMIT)",
            "select singer.Name (or singer.Birth_Year)",
            "select singer.Name (ORDER BY-LIMIT",
            "select singer.Name (singer.Net_Worth_Millions)",
            "select singer.Name (or singer.Net_Worth_Millions)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the singer who has the most amount of earnings?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the richest singer?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the richest singer?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name (singer.Net_Worth_Millions)",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name - singer.Net_Worth_Millions",
            "select singer.Name (or singer.Birth_Year)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the richest singer?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the singer that has the largest net worth?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the singer that has the largest net worth?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name de, singer.Net_Worth_Millions",
            "select singer.Name (singer.Singer_ID)",
            "select singer.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the singer that has the largest net worth?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the singer who has the highest net worth?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the singer who has the highest net worth?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name (or singer.Birth_Year)",
            "select singer.Name (singer.Net_Worth_Millions)",
            "select singer.Name (single-value)",
            "select singer.Name (or singer.Net_Worth_Millions)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the singer who has the highest net worth?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "singer song",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all the citizenships that have been held by singers born not between 1945 and 1955., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all the citizenships that have been held by singers born not between 1945 and 1955., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c4",
        "label": "select t0.c4",
        "score": false,
        "real_pred": "select distinct singer.Citizenship",
        "real_label": "select singer.Citizenship",
        "topk_preds": [
            "select distinct singer.Citizenship",
            "select singer.Citizenship",
            "select count(*)",
            "select all singer.Citizenship",
            "select different singer.Citizenship",
            "select unique singer.Citizenship",
            "select the singer.Citizenship",
            "select sum(singer.Citizenship)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all the citizenships that have been held by singers born not between 1945 and 1955., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the number of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM QUESTION-GROUP BY",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM QUESTION-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the number of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), singer.Singer_ID",
            "select count(*), singer.Singer_ID, singer.Name",
            "select count(*), singer.Name, singer.Birth_Year",
            "select count(*), singer.Birth_Year, singer.Net_Worth_Millions",
            "select count(*), singer.Name",
            "select count(*), singer.Name, singer.Net_Worth_Millions",
            "select count(*), http://www.singer.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the number of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "singer song",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the number of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM (*)",
            "SELECT-FROM SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the number of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), singer.Singer_ID",
            "select count(*), singer.Singer_ID, singer.Name",
            "select count(*), singer.Name, singer.Birth_Year",
            "select count(*), singer.Birth_Year, singer.Net_Worth_Millions",
            "select count(*), singer.Name",
            "select count(*), singer.Name, singer.Net_Worth_Millions",
            "select count(*), http://www.singer.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the number of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "singer song",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of non-French singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of non-French singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Citizenship",
            "select distinct singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select non-French singer.Name",
            "select non-singer.Name",
            "select distinct singer.Name, singer.Citizenship"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of non-French singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the non-French singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the non-French singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name",
            "select singer.Name, t0.c5",
            "select non-singer.Name",
            "select singer.Name (or singer.Birth_Year)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the non-French singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of singers from other countries than France., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of singers from other countries than France., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name (replace singer.Birth_Year)",
            "select singer.Name (or singer.Birth_Year)",
            "select singer.Name - singer.Citizenship",
            "select singer.Name, t0.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of singers from other countries than France., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the names of the non-French singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the names of the non-French singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name",
            "select singer.Name, t0.c5",
            "select singer.Name - singer.Citizenship",
            "select singer.Name (or singer.Birth_Year)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the names of the non-French singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the singer nationality that has the largest number?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-THREE-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the singer nationality that has the largest number?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select singer.Citizenship",
        "real_label": "select singer.Citizenship",
        "topk_preds": [
            "select singer.Citizenship",
            "select singer.Citizenship the SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "select singer.Citizenship, count(*)",
            "select singer.Citizenship (GROUP BY-ORDER BY-LIMIT)",
            "select singer.Citizenship (GROUP BY-ORDER BY-LIMIT",
            "select singer.Citizenship, t0.c5",
            "select singer.Citizenship, singer.Net_Worth_Millions",
            "select singer.Citizenship the SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the singer nationality that has the largest number?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What singer citizenship is the most popular?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What singer citizenship is the most popular?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select singer.Citizenship",
        "real_label": "select singer.Citizenship",
        "topk_preds": [
            "select singer.Citizenship",
            "select singer.Citizenship, singer.Name",
            "select singer.Citizenship, t0.c5",
            "select singer.Citizenship, singer.Net_Worth_Millions",
            "select singer.Citizenship, singer.Birth_Year",
            "select singer.Citizenship, singer.Singer_ID",
            "select singer.Citizenship, t0.c6",
            "select singer.Citizenship, t0.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What singer citizenship is the most popular?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the country with the most singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the country with the most singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select singer.Citizenship",
        "real_label": "select singer.Citizenship",
        "topk_preds": [
            "select singer.Citizenship",
            "select singer.Citizenship, count(*)",
            "select singer.Citizenship, singer.Net_Worth_Millions",
            "select singer.Citizenship, t0.c5",
            "select singer.Citizenship, singer.Name",
            "select singer.Citizenship, singer.Birth_Year",
            "select singer.Citizenship, singer.Citizenship",
            "select singer.Citizenship, make singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the country with the most singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the country of origin for the most singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the country of origin for the most singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select singer.Citizenship",
        "real_label": "select singer.Citizenship",
        "topk_preds": [
            "select singer.Citizenship",
            "select singer.Citizenship, singer.Birth_Year",
            "select singer.Citizenship, t0.c5",
            "select singer.Citizenship, singer.Net_Worth_Millions",
            "select singer.Citizenship, singer.Name",
            "select singer.Citizenship, singer.Citizenship",
            "select singer.Citizenship, t0.c6",
            "select singer.Citizenship, t0.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the country of origin for the most singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which of the singer citizenship is most popular?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which of the singer citizenship is most popular?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select singer.Citizenship",
        "real_label": "select singer.Citizenship",
        "topk_preds": [
            "select singer.Citizenship",
            "select singer.Citizenship, t0.c5",
            "select singer.Citizenship, singer.Net_Worth_Millions",
            "select singer.Citizenship, singer.Name",
            "select singer.Citizenship, singer.Birth_Year",
            "select singer.Citizenship, t0.c6",
            "select singer.Citizenship (or singer.Net_Worth_Millions)",
            "select singer.Citizenship (or t0.c5)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which of the singer citizenship is most popular?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the names of singers that have recorded songs with sales over 300,000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the names of singers that have recorded songs with sales over 300,000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select song.Singer_ID",
            "select singer.Name, song.Singer_ID",
            "select distinct singer.Name",
            "select song.Singer_ID, singer.Name",
            "select singer.Name (singer.Singer_ID)",
            "select singer.Name, singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the names of singers that have recorded songs with sales over 300,000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the citizenship of singers and list the count of singers of each citizenship., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY, count(*)",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM by-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the citizenship of singers and list the count of singers of each citizenship., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4, count(*)",
        "label": "select t0.c4, count(*)",
        "score": true,
        "real_pred": "select singer.Citizenship, count(*)",
        "real_label": "select singer.Citizenship, count(*)",
        "topk_preds": [
            "select singer.Citizenship, count(*)",
            "select singer.Citizenship, count(*), singer.Net_Worth_Millions",
            "select singer.Citizenship, count(*), t0.c5",
            "select singer.Citizenship, count(*), singer.Citizenship",
            "select singer.Citizenship, count(*), singer.Name",
            "select singer.Citizenship.c4, count(*)",
            "select singer.Citizenship, count(*), singer.Singer_ID",
            "select singer.Citizenship., count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the citizenship of singers and list the count of singers of each citizenship., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all the names of singers with increasing net worth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (CLIENT-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (CLIENT-QUEST-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (CLIENT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY (t0.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all the names of singers with increasing net worth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name (or singer.Birth_Year)",
            "select singer.Name in singer.Net_Worth_Millions",
            "select singer.Name (or singer.Net_Worth_Millions)",
            "select singer.Name, order(singer.Net_Worth_Millions)",
            "select t0, singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all the names of singers with increasing net worth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of singers who have two or more songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of singers who have two or more songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select song.Singer_ID, singer.Name",
            "select singer.Name, song.Title",
            "select singer.Name (singer.Singer_ID)",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, song.Singer_ID",
            "select singer.Name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of singers who have two or more songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of singers who have at least two songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of singers who have at least two songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, song.Title",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name (singer.Singer_ID)",
            "select singer.Name, max(song.Singer_ID)",
            "select singer.Name, song.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of singers who have at least two songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of singers with multiple songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of singers with multiple songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, song.Title",
            "select song.Title, singer.Name",
            "select multi-single-singer.Name",
            "select singer.Name (singer.Singer_ID)",
            "select multi-song singer.Name",
            "select singer.Name, song.Sales"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of singers with multiple songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Order all singers in increasing net worth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY ",
            "SELECTFROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Order all singers in increasing net worth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID",
            "select singer.Singer_ID, singer.Name",
            "select singer.Singer_ID, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions,",
            "select singer.Name, singer.Singer_ID3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Order all singers in increasing net worth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the singers who aren't from France?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the singers who aren't from France?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select distinct singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Birth_Year",
            "select distinct singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the singers who aren't from France?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the nationality of the majority of singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the nationality of the majority of singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select singer.Citizenship",
        "real_label": "select singer.Citizenship",
        "topk_preds": [
            "select singer.Citizenship",
            "select singer.Citizenship, t0.c5",
            "select singer.Citizenship, singer.Net_Worth_Millions",
            "select singer.Citizenship, singer.Name",
            "select singer.Citizenship, singer.Birth_Year",
            "select singer.Citizenship, t0.c6",
            "select singer.Citizenship, t0.c7",
            "select singer.Citizenship, singer.Citizenship"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the nationality of the majority of singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of the singers and the total amount of their songs sales., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUPS-GROUP BY",
            "SELECT-FROM-GAGGER-GROUP BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of the singers and the total amount of their songs sales., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, sum(t1.c3)",
        "label": "select t0.c1, sum(t1.c3)",
        "score": true,
        "real_pred": "select singer.Name, sum(song.Sales)",
        "real_label": "select singer.Name, sum(song.Sales)",
        "topk_preds": [
            "select singer.Name, sum(song.Sales)",
            "select song.Singer_ID, sum(song.Sales)",
            "select t2.c2, sum(song.Sales)",
            "select t3.c2, sum(song.Sales)",
            "select sum(song.Sales), singer.Name",
            "select singer.Name, sum(song.Sales)",
            "select t4.c1, sum(song.Sales)",
            "select t5.c2, sum(song.Sales)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of the singers and the total amount of their songs sales., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the singers with sales exceeding 300,000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the singers with sales exceeding 300,000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select song.Singer_ID, singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, song.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the singers with sales exceeding 300,000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the singers who had sales above $300,000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the singers who had sales above $300,000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, song.Sales",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, song.Singer_ID",
            "select singer.Name (singer.Singer_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the singers who had sales above $300,000?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "singer",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the names of the singers with sales over 30000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the names of the singers with sales over 30000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select song.Singer_ID, singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name song.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the names of the singers with sales over 30000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of the singers with two or more songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of the singers with two or more songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select song.Singer_ID, singer.Name",
            "select singer.Name, song.Title",
            "select singer.Name (singer.Singer_ID)",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of the singers with two or more songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the singers that have at least 2 songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the singers that have at least 2 songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select song.Title, singer.Name",
            "select singer.Name, song.Title",
            "select singer.Name, max(song.Singer_ID)",
            "select singer.Name, song.Sales",
            "select singer.Name, t2.c2",
            "select singer.Name, song.Highest_Position"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the singers that have at least 2 songs., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each singer's name, what is the total number of sales for their songs?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GIG-GROUP BY",
            "SELECT-FROM-FROM-GROUP BY",
            "SELECT-FROM-PER-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each singer's name, what is the total number of sales for their songs?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, sum(t1.c3)",
        "label": "select t0.c1, sum(t1.c3)",
        "score": true,
        "real_pred": "select singer.Name, sum(song.Sales)",
        "real_label": "select singer.Name, sum(song.Sales)",
        "topk_preds": [
            "select singer.Name, sum(song.Sales)",
            "select sum(song.Sales), singer.Name",
            "select singer.Name, sum(song.Sales)",
            "select song.Singer_ID, sum(song.Sales)",
            "select singer.Name., sum(song.Sales)",
            "select t2.c2, sum(song.Sales)",
            "select t3.c2, sum(song.Sales)",
            "select count(*), singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each singer's name, what is the total number of sales for their songs?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name of the singer that is worth the most money?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name of the singer that is worth the most money?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name (or singer.Birth_Year)",
            "select singer.Name (single-value)",
            "select singer.Name (singer.Net_Worth_Millions)",
            "select singer.Name (or singer.Net_Worth_Millions)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name of the singer that is worth the most money?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the singer with the most net worth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the singer with the most net worth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name (ORDER BY-LIMIT)",
            "select singer.Name, singer.Net_Worth_Millions, singer.Citizenship",
            "select singer.Singer_ID, singer.Name - singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name, max(singer.Net_Worth_Millions)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the singer with the most net worth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Locate the names of properties that are either houses or apartments with two or more rooms., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SQL-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Locate the names of properties that are either houses or apartments with two or more rooms., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t3.c4",
        "label": "select t3.c4",
        "score": true,
        "real_pred": "select Properties.property_name",
        "real_label": "select Properties.property_name",
        "topk_preds": [
            "select Properties.property_name",
            "select Properties.property_name, Properties.room_count",
            "select Properties.property_name, Properties.property_address",
            "select Properties.property_name - Properties.room_count",
            "select Properties.property_name, Properties.vendor_requested_price",
            "select Properties.property_name (or Properties.property_address)",
            "select Properties.property_name, Properties.buyer_offered_price",
            "select Properties.property_name (or Properties.room_count)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Locate the names of properties that are either houses or apartments with two or more rooms., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Properties",
        "real_label": "Properties",
        "topk_preds": [
            "Properties",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of houses or apartments that have multiple rooms., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of houses or apartments that have multiple rooms., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t3.c4",
        "label": "select t3.c4",
        "score": true,
        "real_pred": "select Properties.property_name",
        "real_label": "select Properties.property_name",
        "topk_preds": [
            "select Properties.property_name",
            "select Properties.property_name, Properties.property_address",
            "select Properties.property_name, Properties.property_address, Properties.room_count",
            "select Properties.property_name, Properties.room_count",
            "select Properties.property_name (or Properties.property_address)",
            "select Properties.property_name, Properties.property_address.c5",
            "select Properties.property_name, Properties.property_address-dept_name",
            "select distinct Properties.property_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of houses or apartments that have multiple rooms., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Properties",
        "real_label": "Properties",
        "topk_preds": [
            "Properties",
            "",
            "",
            "",
            "",
            "",
            "Other_Available_Features Properties",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of properties that are either houses or apartments with two or more rooms., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SQL-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of properties that are either houses or apartments with two or more rooms., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t3.c4",
        "label": "select t3.c4",
        "score": true,
        "real_pred": "select Properties.property_name",
        "real_label": "select Properties.property_name",
        "topk_preds": [
            "select Properties.property_name",
            "select Properties.property_name, Properties.room_count",
            "select Properties.property_name, Properties.property_address",
            "select Properties.property_name, Properties.vendor_requested_price",
            "select Properties.property_name - Properties.room_count",
            "select Properties.property_name (or Properties.property_address)",
            "select Properties.property_name, Properties.buyer_offered_price",
            "select Properties.property_name (or Properties.room_count)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of properties that are either houses or apartments with two or more rooms., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code (Apartment, House), c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code (Apartment, House), c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Properties",
        "real_label": "Properties",
        "topk_preds": [
            "Properties",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    }
]