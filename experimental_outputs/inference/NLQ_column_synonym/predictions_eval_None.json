[
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the name and size of the stadium that recorded the highest average attendance?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the name and size of the stadium that recorded the highest average attendance?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select stadium.Name, stadium.Capacity",
        "real_label": "select stadium.Name, stadium.Capacity",
        "topk_preds": [
            "select stadium.Name, stadium.Capacity",
            "select stadium.Name, stadium.Capacity, avg(stadium.Average)",
            "select stadium.Location, stadium.Capacity",
            "select stadium.Stadium_ID, stadium.Name, stadium.Capacity",
            "select stadium.Name, stadium.Capacity, stadium.Average",
            "select stadium.Capacity, stadium.Name",
            "select stadium.Name., stadium.Capacity",
            "select stadium.Name, stadium.Capacity (or avg(stadium.Average)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the name and size of the stadium that recorded the highest average attendance?, database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "stadium",
        "real_label": "stadium",
        "topk_preds": [
            "stadium",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name of the singer and his or her nationality who sung the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name (Sun), c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name of the singer and his or her nationality who sung the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name (Sun), c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.Name, singer.Country",
        "real_label": "select singer.Name, singer.Country",
        "topk_preds": [
            "select singer.Name, singer.Country",
            "select singer.Name, singer.Country, singer.Song_Name",
            "select singer.Name, singer.Country, singer.Singer_ID",
            "select singer.Name, singer.Country,",
            "select singer.Name, singer.Country,",
            "select singer.Name, singer.Country, singer.Is_male",
            "select singer.Name, singer.Country, singer.Song_release_year",
            "select singer.Name, singer.Country, max(singer.Is_male)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name of the singer and his or her nationality who sung the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name (Sun), c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the name of the singer and his or her nationality who sang the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the name of the singer and his or her nationality who sang the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.Name, singer.Country",
        "real_label": "select singer.Name, singer.Country",
        "topk_preds": [
            "select singer.Name, singer.Country",
            "select singer.Name, singer.Country, singer.Song_Name",
            "select singer.Name, singer.Country, singer.Singer_ID",
            "select singer.Name, singer.Country, max(singer.Song_Name)",
            "select singer.Name, singer.Country, max(singer.Age)",
            "select singer.Name, singer.Country, singer.Song_release_year",
            "select singer.Name, singer.Country, max(singer.Song_release_year)",
            "select singer.Name, singer.Country - singer.Song_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the name of the singer and his or her nationality who sang the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the name of the singer and her nationality who sang the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the name of the singer and her nationality who sang the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.Name, singer.Country",
        "real_label": "select singer.Name, singer.Country",
        "topk_preds": [
            "select singer.Name, singer.Country",
            "select singer.Name, singer.Country, singer.Singer_ID",
            "select singer.Name, singer.Country, singer.Song_Name",
            "select singer.Name, singer.Country, max(singer.Song_Name)",
            "select singer.Name, singer.Country, max(singer.Age)",
            "select singer.Name, singer.Country, max(singer.Song_release_year)",
            "select singer.Name, singer.Country,",
            "select singer.Name, singer.Country - singer.Song_Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the name of the singer and her nationality who sang the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name of the singer and his or her nationality who sang the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name of the singer and his or her nationality who sang the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select singer.Name, singer.Country",
        "real_label": "select singer.Name, singer.Country",
        "topk_preds": [
            "select singer.Name, singer.Country",
            "select singer.Name, singer.Country, singer.Singer_ID",
            "select singer.Name, singer.Country, singer.Song_Name",
            "select singer.Name, singer.Country, max(singer.Age)",
            "select singer.Name, singer.Country, max(singer.Song_release_year)",
            "select singer.Name, singer.Country, max(singer.Song_Name)",
            "select singer.Name, singer.Country,",
            "select singer.Name, singer.Country, max(singer.Is_male)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name of the singer and his or her nationality who sang the song 'Hey' as part of the name., database: Database: concert_singer. t0: stadium(c0: stadium_id, c1: location, c2: name, c3: capacity, c4: highest, c5: lowest, c6: average). t1: singer(c0: singer_id, c1: name, c2: country, c3: song_name, c4: song_release_year, c5: age, c6: is_male). t2: concert(c0: concert_id, c1: concert_name, c2: theme, c3: stadium_id, c4: year) (c3) refers to t0(c0). t3: singer_in_concert(c0: concert_id, c1: singer_id) (c1) refers to t1(c0), (c0) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The first names and sexes of the students who have more than one pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNITED-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUPGROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The first names and sexes of the students who have more than one pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select Student.Fname, Student.Sex",
        "real_label": "select Student.Fname, Student.Sex",
        "topk_preds": [
            "select Student.Fname, Student.Sex",
            "select distinct Student.Fname, Student.Sex",
            "select Student.LName, Student.Sex",
            "select Student.Fname.c2, Student.Sex",
            "select Student.Sex, Student.Fname",
            "select the Student.Fname, Student.Sex",
            "select Student.Fname), Student.Sex",
            "select Student.Fname, Student.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The first names and sexes of the students who have more than one pet., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "Student Student Has_Pet",
            "",
            "",
            "Student Pets",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the number of pets that weigh more than 10., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the number of pets that weigh more than 10., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*), Pets.weight",
            "select count(*), http://Pets.PetID",
            "select count(*), Pets.PetType",
            "select count(*),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the number of pets that weigh more than 10., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many animals weigh more than 10 kgs?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CUMULAT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many animals weigh more than 10 kgs?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Pets.PetID",
            "select count(*), Pets.PetID",
            "select count(*) the SELECT-FROM-WHERE",
            "select count(*), Pets.PetID, Pets.weight",
            "select count(*), Pets.PetID, Pets.weight",
            "select count(*), Pets.PetType",
            "select count(*), Pets.weight"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many animals weigh more than 10 kgs?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the weight of the youngest dog., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-OF-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-CATEGORY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the weight of the youngest dog., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "select t2.c3",
        "label": "select t2.c3",
        "score": true,
        "real_pred": "select Pets.weight",
        "real_label": "select Pets.weight",
        "topk_preds": [
            "select Pets.weight",
            "select Pets.weight, Pets.pet_age",
            "select max(Pets.weight)",
            "select min(Pets.weight)",
            "select Pets.weight)",
            "select avg(Pets.weight)",
            "select Pets.weight.c3",
            "select Pets.weight (max(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the weight of the youngest dog., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want you to find the maximum weight for each kind of pet. List them., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM PER-GROUP BY",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM-1-GROUP BY",
            "SELECT-FROM-GROUP BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want you to find the maximum weight for each kind of pet. List them., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c1, max(t2.c3)",
        "label": "select max(t2.c3), t2.c1",
        "score": false,
        "real_pred": "select Pets.PetType, max(Pets.weight)",
        "real_label": "select max(Pets.weight), Pets.PetType",
        "topk_preds": [
            "select Pets.PetType, max(Pets.weight)",
            "select max(Pets.weight), Pets.PetType",
            "select maximum(Pets.weight), Pets.PetType",
            "select Pets.PetType.c1, max(Pets.weight)",
            "select min(Pets.weight), Pets.PetType",
            "select the Pets.PetType, max(Pets.weight)",
            "select Pets.PetType, max(Pets.weight)",
            "select pettype, max(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want you to find the maximum weight for each kind of pet. List them., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need to count the number of female dogs being raised by female students (gender F) if such information exists., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE, if such count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need to count the number of female dogs being raised by female students (gender F) if such information exists., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Student.Sex",
            "select count(*), Student.StuID",
            "select count(*), Student.LName",
            "select count(*), Student.Fname",
            "select count(*), Pets.PetType",
            "select count(*), if such count(*)",
            "select count(*), Has_Pet.StuID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need to count the number of female dogs being raised by female students (gender F) if such information exists., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype (dog), c2: pet_age, c3: weight).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "Student Has_Pet Pets",
        "real_label": "Student Has_Pet Pets",
        "topk_preds": [
            "Student Has_Pet Pets",
            "",
            "Student Has_Pet",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each category of pets, what is the average weight?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY, avg(t2.c3)",
            "SELECT-FROM-GROUP BY (Avg(t2.c3)",
            "SELECT-FROM-GROUP BY, AVERAGE(t2.c3)",
            "SELECT-FROM-GROUP BY, AVERAGE",
            "SELECT-FROM-GROUP BY (t2.c1)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each category of pets, what is the average weight?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t2.c1, avg(t2.c3)",
        "label": "select avg(t2.c3), t2.c1",
        "score": false,
        "real_pred": "select Pets.PetType, avg(Pets.weight)",
        "real_label": "select avg(Pets.weight), Pets.PetType",
        "topk_preds": [
            "select Pets.PetType, avg(Pets.weight)",
            "select avg(Pets.weight), Pets.PetType",
            "select Pets.PetType, avg(Pets.weight)",
            "select Pets.PetType.c1, avg(Pets.weight)",
            "select Pets.PetType.c3, avg(Pets.weight)",
            "select for Pets.PetType, avg(Pets.weight)",
            "select Pets.PetType, Avg(Pets.weight)",
            "select pettype, avg(Pets.weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each category of pets, what is the average weight?, database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Pets",
        "real_label": "Pets",
        "topk_preds": [
            "Pets",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter the names and sexes of students who have more than one pet below., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUPGROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter the names and sexes of students who have more than one pet below., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select Student.Fname, Student.Sex",
        "real_label": "select Student.Fname, Student.Sex",
        "topk_preds": [
            "select Student.Fname, Student.Sex",
            "select Student.Fname, Student.LName, Student.Sex",
            "select Student.Fname, Student.Age, Student.Sex",
            "select Student.LName, Student.Fname, Student.Sex",
            "select Student.Fname, Student.Fname, Student.Sex",
            "select Student.Fname, Student.LName, Student.Age, Student.Sex",
            "select Student.Fname, Student.LName, Student.Fname, Student.Sex",
            "select distinct Student.Fname, Student.Sex"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter the names and sexes of students who have more than one pet below., database: Database: pets_1. t0: student(c0: stuid, c1: lname, c2: fname, c3: age, c4: sex, c5: major, c6: advisor, c7: city_code). t1: has_pet(c0: stuid, c1: petid). t2: pets(c0: petid, c1: pettype, c2: pet_age, c3: weight).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Student Has_Pet",
        "real_label": "Student Has_Pet",
        "topk_preds": [
            "Student Has_Pet",
            "Student Has_Pet Pets",
            "",
            "Student Student Has_Pet",
            "",
            "",
            "Student Pets",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me information on the acceleration that the car makes when it has the AMC Hornet Sportabout (S)., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me information on the acceleration that the car makes when it has the AMC Hornet Sportabout (S)., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c6",
        "label": "select t5.c6",
        "score": true,
        "real_pred": "select cars_data.Accelerate",
        "real_label": "select cars_data.Accelerate",
        "topk_preds": [
            "select cars_data.Accelerate",
            "select avg(cars_data.Accelerate)",
            "select max(cars_data.Accelerate)",
            "select accel(cars_data.Accelerate)",
            "select cars_data.Id, cars_data.Accelerate",
            "select cars_data.Id, max(cars_data.Accelerate)",
            "select cars_data.Accelerate, cars_data.Year",
            "select ac6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me information on the acceleration that the car makes when it has the AMC Hornet Sportabout (S)., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "continents car_names cars_data",
            "countries car_names cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the acceleration value of the car that makes AMC Hornet Sportabout (SW)?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (GROUP BY-HAVING)",
            "SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (t5.c6)",
            "SELECT-FROM-WHERE (GROUP BY-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the acceleration value of the car that makes AMC Hornet Sportabout (SW)?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c6)",
        "label": "select t5.c6",
        "score": false,
        "real_pred": "select avg(cars_data.Accelerate)",
        "real_label": "select cars_data.Accelerate",
        "topk_preds": [
            "select avg(cars_data.Accelerate)",
            "select cars_data.Accelerate",
            "select cars_data.Id, avg(cars_data.Accelerate)",
            "select accel(cars_data.Accelerate)",
            "select max(cars_data.Accelerate)",
            "select cars_data.Id, cars_data.Accelerate",
            "select avg(cars_data.Accelerate), car_names.MakeId",
            "select avg(cars_data.Accelerate), car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the acceleration value of the car that makes AMC Hornet Sportabout (SW)?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "continents car_names cars_data",
            "countries car_names cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you tell me the names of the car manufacturers that made cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you tell me the names of the car manufacturers that made cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c1",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.FullName, car_makers.Maker",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select distinct car_makers.FullName, car_makers.Maker",
            "select car_makers.FullName, car_makers.Maker, car_makers.Country",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you tell me the names of the car manufacturers that made cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names",
            "car_makers car_names cars_data",
            "car_makers cars_data",
            "",
            "car_makers model_list car_names",
            "",
            "",
            "continents car_makers car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the names of the car manufacturers who made cars in 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the names of the car manufacturers who made cars in 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c1",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.FullName, car_makers.Maker",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker",
            "select car_makers.Id, car_makers.Maker, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select distinct car_makers.FullName, car_makers.Maker",
            "select car_makers.FullName, car_makers.Maker, car_makers.Country",
            "select car_makers.Id, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the names of the car manufacturers who made cars in 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names",
            "car_makers car_names cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            "",
            "car_makers model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What were the names of the car-manufacturers that produced cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What were the names of the car-manufacturers that produced cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c1",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.FullName, car_makers.Maker",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select distinct car_makers.FullName, car_makers.Maker",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select car_makers.FullName, car_makers.Maker, car_makers.Country",
            "select car_makers.Id, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What were the names of the car-manufacturers that produced cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "car_makers car_names",
            "car_makers cars_data",
            "car_makers car_makers car_names cars_data",
            "",
            "car_makers model_list car_names",
            "car_makers model_list car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which are the car manufacturers that produced a car in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-1970"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which are the car manufacturers that produced a car in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.Maker",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName, car_makers.Maker",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.Maker, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which are the car manufacturers that produced a car in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents car_makers car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names",
            "",
            "countries car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which automobile company made cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which automobile company made cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.FullName",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.FullName",
            "select car_makers.Maker",
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.Id, car_makers.FullName",
            "select distinct car_makers.FullName, car_makers.Maker",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which automobile company made cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "countries car_makers car_names cars_data",
            "continents car_makers car_names cars_data",
            "model_list car_makers car_names cars_data",
            "",
            "",
            "",
            "car_makers car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of car manufacturers that made cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of car manufacturers that made cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c1",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.FullName, car_makers.Maker",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.Id, car_makers.Maker, car_makers.FullName",
            "select car_makers.FullName, car_makers.Maker, car_makers.Country",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.Id, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of car manufacturers that made cars in 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names",
            "car_makers car_names cars_data",
            "car_makers cars_data",
            "",
            "car_makers model_list car_names",
            "",
            "continents car_makers car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: In 1970, what manufacturer did they produce cars?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: In 1970, what manufacturer did they produce cars?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.Maker",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.Maker",
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.Maker",
            "select car_makers.Maker, car_names.Make",
            "select t2.c4, car_makers.Maker",
            "select car_makers.FullName, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: In 1970, what manufacturer did they produce cars?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names",
            "car_makers car_names cars_data",
            "",
            "countries car_makers car_names",
            "continents car_makers car_names cars_data",
            "",
            "countries car_makers car_names cars_data",
            "continents car_makers car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need a list of car manufacturers who made a car in 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need a list of car manufacturers who made a car in 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.Maker",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.Maker, car_makers.FullName, car_makers.Maker",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName, car_makers.Maker",
            "select car_makers.Id, car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need a list of car manufacturers who made a car in 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "car_names cars_data",
            "continents car_makers car_names cars_data",
            "model_list car_names cars_data",
            "countries car_makers car_names cars_data",
            "car_makers car_names",
            "countries car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much power does the car with the fastest acceleration have?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much power does the car with the fastest acceleration have?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c4",
        "label": "select t5.c4",
        "score": true,
        "real_pred": "select cars_data.Horsepower",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate",
            "select sum(cars_data.Horsepower)",
            "select cars_data.Horsepower, t5.diff(cars_data.Accelerate)",
            "select cars_data.Horsepower (rev. cars_data.Accelerate)",
            "select cars_data.Horsepower, cars_data.Accelerate, cars_data.Year",
            "select cars_data.Horsepower, t5.diff, cars_data.Accelerate",
            "select cars_data.Horsepower, t5.diff(cars_data.Edispl)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much power does the car with the fastest acceleration have?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please indicate which car has the highest horsepower among those cars with the highest acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEDULING-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please indicate which car has the highest horsepower among those cars with the highest acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t5.c4",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model-, car_names.Make",
            "select car_names.Model, car_names.MakeId",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Model, t4.c4",
            "select cars_data.MPG",
            "select car_names.Model, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please indicate which car has the highest horsepower among those cars with the highest acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers cars_data",
            "model_list cars_data",
            "countries cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the horsepower of the car that has the most acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the horsepower of the car that has the most acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c4",
        "label": "select t5.c4",
        "score": true,
        "real_pred": "select cars_data.Horsepower",
        "real_label": "select cars_data.Horsepower",
        "topk_preds": [
            "select cars_data.Horsepower",
            "select cars_data.Horsepower, cars_data.Accelerate",
            "select cars_data.Id, cars_data.Horsepower",
            "select cars_data.Id, cars_data.Cylinders",
            "select cars_data.Horsepower (cars_data.Accelerate)",
            "select cars_data.Horsepower(cars_data.Accelerate)",
            "select cars_data.Horsepower (cars_data.Horsepower)",
            "select cars_data.Horsepower(cars_data.Horsepower)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the horsepower of the car that has the most acceleration., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which are all the manufacturers and models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which are all the manufacturers and models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c1, t3.c2",
        "label": "select t3.c1, t3.c2",
        "score": true,
        "real_pred": "select model_list.Maker, model_list.Model",
        "real_label": "select model_list.Maker, model_list.Model",
        "topk_preds": [
            "select model_list.Maker, model_list.Model",
            "select car_makers.Maker, model_list.Model",
            "select car_names.Make, model_list.Model",
            "select car_makers.Maker, car_makers.FullName",
            "select distinct model_list.Maker, model_list.Model",
            "select countries.CountryName, model_list.Model",
            "select car_names.Make, car_names.Model",
            "select car_names.Model, model_list.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which are all the manufacturers and models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t3",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "model_list",
        "topk_preds": [
            "model_list car_names",
            "car_makers model_list car_names",
            "car_makers model_list",
            "countries model_list car_names",
            "continents car_makers model_list car_names",
            "continents car_makers model_list",
            "countries model_list",
            "continents model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you tell me all the brands and models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you tell me all the brands and models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2, t4.c1",
        "label": "select t3.c1, t3.c2",
        "score": false,
        "real_pred": "select car_names.Make, car_names.Model",
        "real_label": "select model_list.Maker, model_list.Model",
        "topk_preds": [
            "select car_names.Make, car_names.Model",
            "select distinct car_names.Make, car_names.Model",
            "select count(distinct car_names.Make), count(distinct car_names.Model)",
            "select car_names.Model, car_names.Make",
            "select model_list.Model, model_list.Maker",
            "select car_names.Make, car_names.Model, car_names.Make",
            "select car_names.Make, car_names.Model, car_names.MakeId",
            "select car_names.Make, car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you tell me all the brands and models?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t3",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "model_list",
        "topk_preds": [
            "model_list car_names",
            "car_makers model_list car_names",
            "countries model_list car_names",
            "continents model_list car_names",
            "countries car_names",
            "",
            "car_makers car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you list all the brands and models here?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you list all the brands and models here?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2, t4.c1",
        "label": "select t3.c1, t3.c2",
        "score": false,
        "real_pred": "select car_names.Make, car_names.Model",
        "real_label": "select model_list.Maker, model_list.Model",
        "topk_preds": [
            "select car_names.Make, car_names.Model",
            "select distinct car_names.Make, car_names.Model",
            "select model_list.Model, model_list.Maker",
            "select car_names.Model, car_names.Make",
            "select car_names.Make, model_list.Model",
            "select car_names.Make, model_list.Maker",
            "select car_makers.FullName, model_list.Model",
            "select cars_data.Cylinders, cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you list all the brands and models here?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t3",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "model_list",
        "topk_preds": [
            "model_list car_names",
            "car_makers model_list car_names",
            "countries model_list car_names",
            "continents model_list car_names",
            "countries car_names",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list all the manufacturers and models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list all the manufacturers and models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c1, t3.c2",
        "label": "select t3.c1, t3.c2",
        "score": true,
        "real_pred": "select model_list.Maker, model_list.Model",
        "real_label": "select model_list.Maker, model_list.Model",
        "topk_preds": [
            "select model_list.Maker, model_list.Model",
            "select car_makers.Maker, model_list.Model",
            "select car_names.Make, model_list.Model",
            "select car_names.Make, car_names.Model",
            "select countries.CountryName, model_list.Model",
            "select car_names.Model, model_list.Model",
            "select car_makers.Maker, car_makers.FullName",
            "select distinct model_list.Maker, model_list.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list all the manufacturers and models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t3",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "model_list",
        "topk_preds": [
            "model_list car_names",
            "car_makers model_list car_names",
            "countries model_list car_names",
            "continents car_makers model_list car_names",
            "car_makers model_list",
            "continents car_makers model_list",
            "countries model_list",
            "model_list car_makers car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all the makes as well as their models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM (T4.c2), SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM (UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all the makes as well as their models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2, t4.c1",
        "label": "select t3.c1, t3.c2",
        "score": false,
        "real_pred": "select car_names.Make, car_names.Model",
        "real_label": "select model_list.Maker, model_list.Model",
        "topk_preds": [
            "select car_names.Make, car_names.Model",
            "select car_names.Model, car_names.Make",
            "select model_list.Maker, model_list.Model",
            "select model_list.Maker, car_names.Model",
            "select distinct car_names.Make, car_names.Model",
            "select car_names.Make, model_list.Model",
            "select car_names.Make, model_list.Maker",
            "select car_makers.Maker, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all the makes as well as their models., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t3",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "model_list",
        "topk_preds": [
            "model_list car_names",
            "car_makers model_list car_names",
            "",
            "",
            "continents model_list car_names",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each model that has three cylinders, list the maximum power output and the make of the car., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C1, max(t5.c4), t4.c2",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY, max(t5.c4), t4.c2",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each model that has three cylinders, list the maximum power output and the make of the car., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c4), t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select max(cars_data.Horsepower), car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select max(cars_data.Horsepower), car_names.Make",
            "select car_names.Model, max(cars_data.Horsepower), car_names.Make",
            "select car_names.Model, max(cars_data.Horsepower)",
            "select max(cars_data.Accelerate), car_names.Make",
            "select max(cars_data.Horsepower), cars_data.Cylinders",
            "select max(t5_c4), car_names.Make",
            "select cars_data.Horsepower, car_names.Make",
            "select Max(cars_data.Horsepower), car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each model that has three cylinders, list the maximum power output and the make of the car., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the highest power output and the brand for the three cylinder vehicles?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the highest power output and the brand for the three cylinder vehicles?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c4), t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select max(cars_data.Horsepower), car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Horsepower), car_names.Model",
            "select cars_data.Horsepower, car_names.Make",
            "select max(cars_data.Accelerate), car_names.Make",
            "select max(cars_data.Horsepower), cars_data.Cylinders",
            "select max(cars_data.Edispl), car_names.Make",
            "select max(cars_data.Horsepower), car_names.Make)",
            "select max(cars_data.Weight), car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the highest power output and the brand for the three cylinder vehicles?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "",
            "car_makers cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the max power output and the make of the cars which are three cylinder engines?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the max power output and the make of the cars which are three cylinder engines?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c4), t4.c2",
        "label": "select t5.c4, t4.c2",
        "score": false,
        "real_pred": "select max(cars_data.Horsepower), car_names.Make",
        "real_label": "select cars_data.Horsepower, car_names.Make",
        "topk_preds": [
            "select max(cars_data.Horsepower), car_names.Make",
            "select avg(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Accelerate), car_names.Make",
            "select cars_data.Horsepower, car_names.Make",
            "select max(cars_data.Weight), car_names.Make",
            "select max(cars_data.Edispl), car_names.Make",
            "select Max(cars_data.Horsepower), car_names.Make",
            "select max(cars_data.Horsepower), cars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the max power output and the make of the cars which are three cylinder engines?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers cars_data",
            "continents car_names cars_data",
            "model_list cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average mpg for the cars with four cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (Avg(t5.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average mpg for the cars with four cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select the avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)",
            "select avg(cars_data.MPG),",
            "select avg(cars_data.MPG)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average mpg for the cars with four cylinders?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need the average fuel efficiency of the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (avg(t5.c1)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (Avg(t5.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need the average fuel efficiency of the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select the avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)",
            "select avg(cars_data.MPG).",
            "select \u0430vg(cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need the average fuel efficiency of the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: If some cars had been made in 1970, please let me know what manufacturers produced them., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INDEX-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: If some cars had been made in 1970, please let me know what manufacturers produced them., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1, t2.c2",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.Maker, car_makers.FullName",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Maker",
            "select car_makers.FullName",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, car_makers.FullName",
            "select car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: If some cars had been made in 1970, please let me know what manufacturers produced them., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "car_names cars_data",
            "model_list car_names cars_data",
            "countries car_makers car_names cars_data",
            "continents car_makers car_names cars_data",
            "model_list car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the name of the producer of those made cars in the year 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the name of the producer of those made cars in the year 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.FullName",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.FullName",
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Maker",
            "select car_makers.Id, car_makers.FullName",
            "select distinct car_makers.FullName, car_makers.Maker",
            "select t2.c4, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the name of the producer of those made cars in the year 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents car_makers car_names cars_data",
            "",
            "",
            "",
            "car_makers cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Provide me the list of car producers that made their products back in the year 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Provide me the list of car producers that made their products back in the year 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.Maker",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.Maker, car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.FullName, car_makers.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Provide me the list of car producers that made their products back in the year 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "countries car_makers car_names cars_data",
            "continents car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "model_list car_makers car_names cars_data",
            "",
            "",
            "car_makers cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to find the manufacturers of the automobiles that were made in the year 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to find the manufacturers of the automobiles that were made in the year 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.Maker",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.Maker, car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select distinct car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName, car_makers.Maker",
            "select car_makers.Id, car_makers.Maker, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to find the manufacturers of the automobiles that were made in the year 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "continents car_makers car_names cars_data",
            "countries car_makers car_names cars_data",
            "car_names cars_data",
            "model_list car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "model_list car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of the producers who made an automobile in the year of 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of the producers who made an automobile in the year of 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1, t2.c2",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.Maker, car_makers.FullName",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.Id, car_makers.Maker, car_makers.FullName",
            "select car_makers.FullName, car_makers.Maker, car_makers.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of the producers who made an automobile in the year of 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents car_makers car_names cars_data",
            "countries car_makers car_names cars_data",
            "",
            "car_makers cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the names of the manufacturers that made some vehicles in the year of 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the names of the manufacturers that made some vehicles in the year of 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c1",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.FullName, car_makers.Maker",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select distinct car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.Maker",
            "select car_makers.FullName, car_makers.Maker, car_makers.Country",
            "select car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the names of the manufacturers that made some vehicles in the year of 1970., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "continents car_makers car_names cars_data",
            "countries car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "",
            "",
            "",
            "car_makers cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of car manufacturers that produced some cars in the year of 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of car manufacturers that produced some cars in the year of 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1, t2.c2",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.Maker, car_makers.FullName",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.FullName, car_makers.Maker, car_makers.Country",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker",
            "select car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of car manufacturers that produced some cars in the year of 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents car_makers car_names cars_data",
            "car_makers cars_data",
            "",
            "",
            "",
            "car_makers car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the car manufacturers that made some vehicles in the year 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the car manufacturers that made some vehicles in the year 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c2, t2.c1",
        "label": "select distinct t2.c1",
        "score": false,
        "real_pred": "select car_makers.FullName, car_makers.Maker",
        "real_label": "select distinct car_makers.Maker",
        "topk_preds": [
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select distinct car_makers.FullName, car_makers.Maker",
            "select distinct car_makers.Maker, car_makers.FullName",
            "select car_makers.FullName",
            "select car_makers.FullName, car_makers.Maker, car_makers.Country",
            "select car_makers.Maker, car_makers.FullName, car_makers.Country",
            "select car_makers.Id, car_makers.FullName, car_makers.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the car manufacturers that made some vehicles in the year 1970?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents car_makers car_names cars_data",
            "countries car_makers car_names cars_data",
            "",
            "",
            "car_makers car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me information about cars made by either the car-maker General Motors or weighing more than 3500 kg., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me information about cars made by either the car-maker General Motors or weighing more than 3500 kg., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select *",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select *",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select *",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Make",
            "select car_names.MakeId, car_names.Model",
            "select cars_data.MPG, cars_data.Cylinders",
            "select car_names.MakeId",
            "select car_names.Make, car_names.Model",
            "select me car_names.Model, car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me information about cars made by either the car-maker General Motors or weighing more than 3500 kg., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "continents car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_makers car_names cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The types of automobiles made either by the manufacturer General Motors (GM) or weighing more than 3.500 kg., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (gm), c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM cars-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The types of automobiles made either by the manufacturer General Motors (GM) or weighing more than 3.500 kg., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (gm), c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select distinct t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select distinct car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select distinct car_names.Model",
            "select distinct car_names.Model, car_names.Make",
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select only car_names.Model, car_names.Make",
            "select car_makers.FullName, car_makers.Maker",
            "select car_makers.Maker, car_makers.FullName",
            "select distinct car_names.Model, t4.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The types of automobiles made either by the manufacturer General Motors (GM) or weighing more than 3.500 kg., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (gm), c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "countries car_makers car_names cars_data",
            "continents car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "",
            "",
            "car_makers car_names",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The earliest year in which this car was manufactured was when and what make was it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The earliest year in which this car was manufactured was when and what make was it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7, t4.c2",
        "label": "select t4.c2, t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year, car_names.Make",
        "real_label": "select car_names.Make, cars_data.Year",
        "topk_preds": [
            "select cars_data.Year, car_names.Make",
            "select min(cars_data.Year), car_names.Make",
            "select max(cars_data.Year), car_names.Make",
            "select t4.c7, car_names.Make",
            "select cars_data.Year, car_names.Make",
            "select cars_data.Id, car_names.Make",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The earliest year in which this car was manufactured was when and what make was it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            "",
            "car_makers cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the first year of production of that car and what company manufactured it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the first year of production of that car and what company manufactured it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7, t2.c2",
        "label": "select t4.c2, t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year, car_makers.FullName",
        "real_label": "select car_names.Make, cars_data.Year",
        "topk_preds": [
            "select cars_data.Year, car_makers.FullName",
            "select cars_data.Year, car_makers.Maker",
            "select cars_data.Year, car_names.Make",
            "select cars_data.Year, car_names.Model",
            "select cars_data.Year, car_makers.FullName",
            "select t4.c7, car_makers.FullName",
            "select cars_data.Year, cars_data.MPG",
            "select car_names.Model, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the first year of production of that car and what company manufactured it?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "car_makers car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_makers car_names cars_data",
            "countries car_makers car_names cars_data",
            "continents car_makers car_names cars_data",
            "car_names cars_data",
            "model_list car_makers car_names cars_data",
            "",
            "countries car_names cars_data",
            "model_list car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What car was produced in the earliest year and what year was that?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What car was produced in the earliest year and what year was that?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1, t5.c7",
        "label": "select t4.c2, t5.c7",
        "score": false,
        "real_pred": "select car_names.Model, cars_data.Year",
        "real_label": "select car_names.Make, cars_data.Year",
        "topk_preds": [
            "select car_names.Model, cars_data.Year",
            "select car_names.Make, cars_data.Year",
            "select car_names.MakeId, cars_data.Year",
            "select cars_data.MPG, cars_data.Year",
            "select car_names.Model, t4.c7",
            "select car_makers.Maker, cars_data.Year",
            "select car_names.Model, cars_data.Year",
            "select t4, cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What car was produced in the earliest year and what year was that?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "continents car_names cars_data",
            "countries car_names cars_data",
            "countries cars_data",
            "",
            "car_makers cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the make of the car manufactured in the earliest year and what was the year when it was made?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the make of the car manufactured in the earliest year and what was the year when it was made?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2, t5.c7",
        "label": "select t4.c2, t5.c7",
        "score": true,
        "real_pred": "select car_names.Make, cars_data.Year",
        "real_label": "select car_names.Make, cars_data.Year",
        "topk_preds": [
            "select car_names.Make, cars_data.Year",
            "select car_names.Model, cars_data.Year",
            "select car_names.MakeId, car_names.Make, cars_data.Year",
            "select car_makers.FullName, cars_data.Year",
            "select car_names.Make, t4.c7",
            "select car_names.Make, cars_data.Year",
            "select car_names.Make, cars_data.Year, cars_data.Id",
            "select car_names.Make, cars_data.Year, car_names.MakeId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the make of the car manufactured in the earliest year and what was the year when it was made?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The first car that was manufactured by which company and when was it made?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, t4.c2, t4.c7"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The first car that was manufactured by which company and when was it made?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c1, t5.c7",
        "label": "select t4.c2, t5.c7",
        "score": false,
        "real_pred": "select car_makers.Maker, cars_data.Year",
        "real_label": "select car_names.Make, cars_data.Year",
        "topk_preds": [
            "select car_makers.Maker, cars_data.Year",
            "select car_makers.Maker, t4.c7",
            "select car_makers.FullName, t4.c7",
            "select car_makers.FullName, cars_data.Year",
            "select car_names.Model, t4.c7",
            "select car_makers.FullName, t2.c7",
            "select car_names.Make, t4.c7",
            "select car_makers.Maker, t2.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The first car that was manufactured by which company and when was it made?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t4",
        "label": "t4 t5",
        "score": false,
        "real_pred": "car_makers car_names",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_makers car_names",
            "car_makers car_names cars_data",
            "countries car_makers car_names",
            "countries car_makers car_names cars_data",
            "car_names cars_data",
            "continents car_makers car_names cars_data",
            "model_list car_makers car_names cars_data",
            "model_list car_makers car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the brand or company that manufactured the car made in the earlier year and what was the year when this car was first made?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the brand or company that manufactured the car made in the earlier year and what was the year when this car was first made?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2, t5.c7",
        "label": "select t4.c2, t5.c7",
        "score": true,
        "real_pred": "select car_names.Make, cars_data.Year",
        "real_label": "select car_names.Make, cars_data.Year",
        "topk_preds": [
            "select car_names.Make, cars_data.Year",
            "select car_names.Make, car_names.Model, cars_data.Year",
            "select car_names.Make, car_names.Model, t4.c7",
            "select car_names.Make, t4.c7",
            "select car_makers.FullName, car_makers.Maker, cars_data.Year",
            "select car_makers.FullName, cars_data.Year",
            "select car_names.Model, cars_data.Year",
            "select car_names.Make, car_names.Model, cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the brand or company that manufactured the car made in the earlier year and what was the year when this car was first made?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "countries car_makers car_names cars_data",
            "continents car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the make (make = brand/model) of the car that was manufactured in the earliest year and what year did it come out?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the make (make = brand/model) of the car that was manufactured in the earliest year and what year did it come out?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2, t5.c7",
        "label": "select t4.c2, t5.c7",
        "score": true,
        "real_pred": "select car_names.Make, cars_data.Year",
        "real_label": "select car_names.Make, cars_data.Year",
        "topk_preds": [
            "select car_names.Make, cars_data.Year",
            "select car_names.Make, t4.c7",
            "select car_names.Model, t4.c7",
            "select car_names.Make, car_names.Model",
            "select car_names.MakeId, car_names.Make, cars_data.Year",
            "select car_names.MakeId, car_names.Make, t4.c7",
            "select car_names.Model, cars_data.Year",
            "select car_names.Model, car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the make (make = brand/model) of the car that was manufactured in the earliest year and what year did it come out?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For the car manufactured in the earliest year, list the make that made it and in what year was it produced., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For the car manufactured in the earliest year, list the make that made it and in what year was it produced., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2, t5.c7",
        "label": "select t4.c2, t5.c7",
        "score": true,
        "real_pred": "select car_names.Make, cars_data.Year",
        "real_label": "select car_names.Make, cars_data.Year",
        "topk_preds": [
            "select car_names.Make, cars_data.Year",
            "select car_names.Make, t4.c7",
            "select car_names.Model, t4.c7",
            "select car_names.Model, cars_data.Year",
            "select car_names.Make, cars_data.Year",
            "select car_names.Make, cars_data.Year",
            "select car_makers.FullName, cars_data.Year",
            "select cars_data.Cylinders, cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For the car manufactured in the earliest year, list the make that made it and in what year was it produced., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Select for me models having the largest horse power among those that belong to four-cylinder engines., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE or-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE\u2013ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHEREORDER BY-LIMIT",
            "SELECT-FROM-WHERE-1-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Select for me models having the largest horse power among those that belong to four-cylinder engines., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Make",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Make, cars_data.Horsepower",
            "select car_names.MakeId, car_names.Model",
            "select cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Select for me models having the largest horse power among those that belong to four-cylinder engines., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "car_names cars_data",
            "",
            "model_list cars_data",
            "",
            "car_makers cars_data",
            "cars_data car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many vehicles have a larger acceleration rate than the vehicle with the highest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY -LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many vehicles have a larger acceleration rate than the vehicle with the highest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Horsepower",
            "select count(distinct cars_data.Id)",
            "select count(*), cars_data.Id",
            "select count(*), cars_data.Accelerate",
            "select count(*), cars_data.MPG",
            "select count(*), cars_data.Cylinders",
            "select count(*), t5.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many vehicles have a larger acceleration rate than the vehicle with the highest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like you to tell me about the cars with higher accelerations than the one that has the highest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like you to tell me about the cars with higher accelerations than the one that has the highest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c0",
        "label": "select count(*)",
        "score": false,
        "real_pred": "select cars_data.Id",
        "real_label": "select count(*)",
        "topk_preds": [
            "select cars_data.Id",
            "select cars_data.MPG",
            "select car_names.Model, car_names.Make",
            "select car_names.Model",
            "select cars_data.Id, cars_data.Accelerate",
            "select cars_data.MPG, cars_data.Cylinders",
            "select cars_data.Id, cars_data.MPG",
            "select cars_data.Accelerate"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like you to tell me about the cars with higher accelerations than the one that has the highest horsepower., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which car has a greater acceleration than the car that had the greatest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which car has a greater acceleration than the car that had the greatest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select count(*)",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select count(*)",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select cars_data.MPG",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, car_names.MakeId",
            "select car_names.Model, t4.c4",
            "select car_names.MakeId, car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which car has a greater acceleration than the car that had the greatest horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "",
            "cars_data car_names cars_data",
            "model_list car_names cars_data",
            "",
            "model_list cars_data",
            "car_makers cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What kind of car has the least horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What kind of car has the least horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select car_names.Make",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Make",
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Make, car_names.Model",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model (car_names.Make)",
            "select car_names.Make, car_names.MakeId"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What kind of car has the least horsepower?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "countries car_names cars_data",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model of the car that has the smallest amount of power?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model of the car that has the smallest amount of power?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, t4.c3",
            "select model_list.Model, car_names.Model",
            "select car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model of the car that has the smallest amount of power?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data",
            "continents model_list car_names cars_data",
            "continents car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Write down the model of the smallest-powered car please., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Write down the model of the smallest-powered car please., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select model_list.ModelId, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select car_names.Model",
            "select model_list.Model, model_list.ModelId",
            "select model_list.Model, cars_data.Id",
            "select model_list.Model, cars_data.Horsepower",
            "select model_list.Model, cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Write down the model of the smallest-powered car please., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_makers model_list cars_data",
            "countries car_names cars_data",
            "countries model_list cars_data",
            "continents model_list cars_data",
            "model_list cars_data car_names",
            "car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show me the model of the car that weighs less than the average., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show me the model of the car that weighs less than the average., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select car_names.Model, model_list.Model",
            "select car_names.Model, car_names.Make",
            "select model_list.Model, car_names.Model",
            "select car_names.Make",
            "select model_list.Model (or car_names.Model)",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show me the model of the car that weighs less than the average., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents model_list car_names cars_data",
            "car_names cars_data",
            "countries car_names cars_data",
            "model_list cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the models of cars that weigh less than the average one., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the models of cars that weigh less than the average one., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select model_list.Model, car_names.Model",
            "select car_names.Model, model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Make",
            "select model_list.Model, model_list.ModelId",
            "select distinct model_list.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the models of cars that weigh less than the average one., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_makers model_list cars_data",
            "countries car_names cars_data",
            "car_names cars_data",
            "continents model_list cars_data",
            "",
            "car_makers car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the model or make of the car that weighs below the average model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C1-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the model or make of the car that weighs below the average model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1, t4.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select car_names.Model, car_names.Make",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model, car_names.Make",
            "select car_names.Model ou car_names.Make",
            "select distinct car_names.Model, car_names.Make",
            "select car_names.Make, car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, car_names.Make,",
            "select car_names.Model / car_names.Make",
            "select car_names.Model oder car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the model or make of the car that weighs below the average model., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the model of the car that weighs less than the average one?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the model of the car that weighs less than the average one?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select model_list.Model (refers to car_names.Model)",
            "select car_names.Make",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the model of the car that weighs less than the average one?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers car_names cars_data",
            "continents car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the model for the car that weighs less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the model for the car that weighs less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select model_list.ModelId, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select model_list.Model (refers to car_names.Model)",
            "select car_names.Model, model_list.Model",
            "select model_list.Model (or car_names.Model)",
            "select model_list.ModelId, model_list.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the model for the car that weighs less than the average?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_makers model_list car_names cars_data",
            "car_names cars_data",
            "continents model_list car_names cars_data",
            "countries car_names cars_data",
            "car_makers car_names cars_data",
            "continents car_names cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the model and year of the car produced in the earliest years., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the model and year of the car produced in the earliest years., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1, t5.c7",
        "label": "select t4.c2, t5.c7",
        "score": false,
        "real_pred": "select car_names.Model, cars_data.Year",
        "real_label": "select car_names.Make, cars_data.Year",
        "topk_preds": [
            "select car_names.Model, cars_data.Year",
            "select car_names.Model, t4.c7",
            "select car_names.Model, cars_data.Year",
            "select car_makers.FullName, cars_data.Year",
            "select cars_data.MPG, cars_data.Year",
            "select model_list.Model, cars_data.Year",
            "select car_makers.Maker, cars_data.Year",
            "select car_names.Make, cars_data.Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the model and year of the car produced in the earliest years., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "continents car_names cars_data",
            "",
            "countries cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What cars models were produced after 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What cars models were produced after 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select distinct car_names.Model",
            "select model_list.Model",
            "select specific car_names.Model",
            "select distinct model_list.Model",
            "select only car_names.Model",
            "select car_names.Model",
            "select car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What cars models were produced after 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4",
        "label": "t3 t4 t5",
        "score": false,
        "real_pred": "model_list car_names",
        "real_label": "model_list car_names cars_data",
        "topk_preds": [
            "model_list car_names",
            "model_list car_names cars_data",
            "car_names cars_data",
            "car_names",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list car_names",
            "countries car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What models of cars have been manufactured since 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What models of cars have been manufactured since 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select distinct car_names.Model",
            "select model_list.Model",
            "select distinct model_list.Model",
            "select car_names.Model, car_names.Make",
            "select distinct car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Year",
            "select specific car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What models of cars have been manufactured since 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t3 t4 t5",
        "score": false,
        "real_pred": "car_names cars_data",
        "real_label": "model_list car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "model_list car_names",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "car_makers model_list car_names",
            "car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me which cars models were assembled after 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me which cars models were assembled after 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select distinct car_names.Model",
            "select car_names.MakeId, car_names.Model",
            "select car_names.MakeId, car_names.Make",
            "select distinct car_names.Model, car_names.Make",
            "select car_names.Model, car_names.Make",
            "select model_list.Model",
            "select distinct car_names.MakeId, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me which cars models were assembled after 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t3 t4 t5",
        "score": true,
        "real_pred": "model_list car_names cars_data",
        "real_label": "model_list car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "car_names cars_data",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "model_list cars_data",
            "",
            "model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me the acceleration value for the AMC Hornet Sportabout., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me the acceleration value for the AMC Hornet Sportabout., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c6)",
        "label": "select t5.c6",
        "score": false,
        "real_pred": "select avg(cars_data.Accelerate)",
        "real_label": "select cars_data.Accelerate",
        "topk_preds": [
            "select avg(cars_data.Accelerate)",
            "select cars_data.Accelerate",
            "select accel(cars_data.Accelerate)",
            "select max(cars_data.Accelerate)",
            "select accele(cars_data.Accelerate)",
            "select avg(cars_data.Accelerate)",
            "select acc(cars_data.Accelerate)",
            "select acceleration(cars_data.Accelerate)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me the acceleration value for the AMC Hornet Sportabout., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "continents car_names cars_data",
            "countries car_names cars_data",
            "",
            "car_makers cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me about the acceleration of an AMC Hornet Sportabout (SW)., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (t5.c6)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me about the acceleration of an AMC Hornet Sportabout (SW)., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c6)",
        "label": "select t5.c6",
        "score": false,
        "real_pred": "select avg(cars_data.Accelerate)",
        "real_label": "select cars_data.Accelerate",
        "topk_preds": [
            "select avg(cars_data.Accelerate)",
            "select cars_data.Accelerate",
            "select max(cars_data.Accelerate)",
            "select accel(cars_data.Accelerate)",
            "select accele(cars_data.Accelerate)",
            "select avg(cars_data.Accelerate)",
            "select cars_data.Id, cars_data.Accelerate",
            "select avg(cars_data.Accelerate),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me about the acceleration of an AMC Hornet Sportabout (SW)., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (amc), c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (amc)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (amc), c2: make (amc hornet, amc hornet sportabout (sw))) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list car_names cars_data",
            "continents car_names cars_data",
            "countries car_names cars_data",
            "",
            "",
            "car_makers cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For the cars that are equipped with four-cylinder engines, what is the average MPG?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For the cars that are equipped with four-cylinder engines, what is the average MPG?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select the avg(cars_data.MPG)",
            "select avg(cars_data.MPG),",
            "select Avg(cars_data.MPG)",
            "select \u0430vg(cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For the cars that are equipped with four-cylinder engines, what is the average MPG?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The average fuel efficiency for vehicles with four-cylinder engines is what?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The average fuel efficiency for vehicles with four-cylinder engines is what?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select the avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)",
            "select eavg(cars_data.MPG)",
            "select avg(cars_data.MPG),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The average fuel efficiency for vehicles with four-cylinder engines is what?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please provide the average miles per gallon for the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (Avg(t5.c1)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please provide the average miles per gallon for the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select avg(avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select the avg(cars_data.MPG)",
            "select avg(cars_data.MPG).",
            "select Avg(cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please provide the average miles per gallon for the cars with four cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me an approximate average miles per gallon value for all four-cylinder engine cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t5.c1)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me an approximate average miles per gallon value for all four-cylinder engine cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)",
            "select the avg(cars_data.MPG)",
            "select avg(cars_data.MPG).",
            "select avg(cars_data.MPG),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me an approximate average miles per gallon value for all four-cylinder engine cars., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average miles per gallon for the four-cylinder engine?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average miles per gallon for the four-cylinder engine?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c1)",
        "label": "select avg(t5.c1)",
        "score": true,
        "real_pred": "select avg(cars_data.MPG)",
        "real_label": "select avg(cars_data.MPG)",
        "topk_preds": [
            "select avg(cars_data.MPG)",
            "select an avg(cars_data.MPG)",
            "select avg(avg(cars_data.MPG)",
            "select avg(cars_data.MPG)",
            "select  avg(cars_data.MPG)",
            "select Avg(cars_data.MPG)",
            "select the avg(cars_data.MPG)",
            "select avg(cars_data.MPG)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average miles per gallon for the four-cylinder engine?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much was the minimum weight for the eight-cylinder car made in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (MIN(t5.c5)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-1974"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much was the minimum weight for the eight-cylinder car made in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select min(t5.c5)",
        "label": "select min(t5.c5)",
        "score": true,
        "real_pred": "select min(cars_data.Weight)",
        "real_label": "select min(cars_data.Weight)",
        "topk_preds": [
            "select min(cars_data.Weight)",
            "select min(cars_data.Weight), cars_data.Year",
            "select min(cars_data.Weight), cars_data.Accelerate",
            "select min(cars_data.Weight), cars_data.Cylinders",
            "select min(cars_data.Weight), t5.c8",
            "select min(cars_data.Weight), cars_data.MPG",
            "select min(cars_data.Weight), cars_data.Id",
            "select min(cars_data.Weight), car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much was the minimum weight for the eight-cylinder car made in 1974?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list car_names cars_data",
            "model_list cars_data",
            "car_makers cars_data",
            "",
            "countries cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Provide me the number of the cars that were made with engines over 150 HP's., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Provide me the number of the cars that were made with engines over 150 HP's., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*) dependant on cars_data.Id",
            "select count(*) depreciated car_names.Make",
            "select count(*), t5.dcars_data.Id",
            "select count(*) depreciated(car_names.Make)",
            "select count(*),",
            "select count(*), cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Provide me the number of the cars that were made with engines over 150 HP's., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list car_names cars_data",
            "",
            "",
            "model_list cars_data",
            "cars_data car_names cars_data",
            "car_makers cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the number of cars with an engine power larger than 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE_GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE_GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the number of cars with an engine power larger than 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Id",
            "select count(*), t5.datum(cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG, cars_data.Cylinders",
            "select count(*), cars_data.Id, cars_data.Edispl",
            "select count(*) (cars_data.Id)",
            "select count(*), cars_data.Id, cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the number of cars with an engine power larger than 150?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which model has the highest mpg?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which model has the highest mpg?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.MakeId, car_names.Model",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model (cars_data.MPG)",
            "select car_names.MakeId, model_list.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which model has the highest mpg?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t4 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list car_names cars_data",
            "model_list cars_data",
            "car_names cars_data",
            "car_makers model_list cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents model_list cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the models which can give the highest mileage for a gallon of gas consumed?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the models which can give the highest mileage for a gallon of gas consumed?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select model_list.Model, model_list.ModelId",
            "select car_names.Model (cars_data.MPG)",
            "select model_list.Model, cars_data.MPG"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the models which can give the highest mileage for a gallon of gas consumed?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_makers model_list cars_data",
            "countries model_list cars_data",
            "countries car_names cars_data",
            "continents model_list cars_data",
            "",
            "car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which model has the highest mpg rating?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which model has the highest mpg rating?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, model_list.Model",
            "select car_names.MakeId, car_names.Model",
            "select car_names.MakeId, car_names.Make",
            "select car_names.MakeId, model_list.Model",
            "select car_names.Model (cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which model has the highest mpg rating?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_makers model_list cars_data",
            "car_names cars_data",
            "countries car_names cars_data",
            "car_makers car_names cars_data",
            "continents model_list cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What model offers the highest mileage?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What model offers the highest mileage?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select model_list.Model, car_names.Model",
            "select car_names.Model, model_list.Model",
            "select model_list.Model, model_list.ModelId",
            "select model_list.Model, car_names.MakeId",
            "select car_names.Model (cars_data.MPG)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What model offers the highest mileage?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "model_list car_names cars_data",
            "car_makers model_list cars_data",
            "countries car_names cars_data",
            "continents model_list cars_data",
            "countries model_list cars_data",
            "car_names cars_data",
            "countries model_list car_names cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the car model that has the best fuel economy., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the car model that has the best fuel economy., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, car_names.Make",
            "select car_names.MakeId, car_names.Model",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model, model_list.Model",
            "select car_names.MakeId, car_names.Make",
            "select car_names.Model (cars_data.MPG)",
            "select car_names.Model, t4.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the car model that has the best fuel economy., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "car_makers model_list car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The model with the highest fuel efficiency is..., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The model with the highest fuel efficiency is..., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select model_list.ModelId, model_list.Model",
            "select model_list.Model, car_names.Model",
            "select model_list.Model, model_list.ModelId",
            "select model_list.Model, cars_data.MPG",
            "select car_names.Model, car_names.Make",
            "select model_list.ModelId, car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The model with the highest fuel efficiency is..., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "car_makers model_list cars_data",
            "countries model_list cars_data",
            "continents model_list cars_data",
            "car_names cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the average power output of automobiles before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (Avg(t5.c4)",
            "SELECT-FROM-WHERE (avg(t5.c4)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the average power output of automobiles before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c4)",
        "label": "select avg(t5.c4)",
        "score": true,
        "real_pred": "select avg(cars_data.Horsepower)",
        "real_label": "select avg(cars_data.Horsepower)",
        "topk_preds": [
            "select avg(cars_data.Horsepower)",
            "select an avg(cars_data.Horsepower)",
            "select  avg(cars_data.Horsepower)",
            "select avg(cars_data.Horsepower)",
            "select avg(cars_data.Accelerate)",
            "select avg(cars_data.Weight)",
            "select Avg(cars_data.Horsepower)",
            "select the avg(cars_data.Horsepower)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the average power output of automobiles before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the average engine power of cars before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGREG(t5.c4)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the average engine power of cars before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c4)",
        "label": "select avg(t5.c4)",
        "score": true,
        "real_pred": "select avg(cars_data.Horsepower)",
        "real_label": "select avg(cars_data.Horsepower)",
        "topk_preds": [
            "select avg(cars_data.Horsepower)",
            "select an avg(cars_data.Horsepower)",
            "select  avg(cars_data.Horsepower)",
            "select avg(cars_data.Horsepower)",
            "select avg(cars_data.Accelerate)",
            "select Avg(cars_data.Horsepower)",
            "select avg(cars_data.Weight)",
            "select avg(cars_data.Edispl)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the average engine power of cars before 1980., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "model_list cars_data",
            "car_names cars_data",
            "",
            "car_makers cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average power output for cars manufactured before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average power output for cars manufactured before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select avg(t5.c4)",
        "label": "select avg(t5.c4)",
        "score": true,
        "real_pred": "select avg(cars_data.Horsepower)",
        "real_label": "select avg(cars_data.Horsepower)",
        "topk_preds": [
            "select avg(cars_data.Horsepower)",
            "select an avg(cars_data.Horsepower)",
            "select avg(avg(cars_data.Horsepower)",
            "select  avg(cars_data.Horsepower)",
            "select avg(cars_data.Horsepower)",
            "select avg(cars_data.Accelerate)",
            "select Avg(cars_data.Horsepower)",
            "select avg(cars_data.Weight)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average power output for cars manufactured before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "model_list cars_data",
            "",
            "car_makers cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want to see the maximum acceleration for different numbers of cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GROUP BY (t5.c2)",
            "SELECT-FROM for t5.c2",
            "SELECT-FROM per-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want to see the maximum acceleration for different numbers of cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c6), t5.c2",
        "label": "select max(t5.c6), t5.c2",
        "score": true,
        "real_pred": "select max(cars_data.Accelerate), cars_data.Cylinders",
        "real_label": "select max(cars_data.Accelerate), cars_data.Cylinders",
        "topk_preds": [
            "select max(cars_data.Accelerate), cars_data.Cylinders",
            "select cars_data.Cylinders, max(cars_data.Accelerate)",
            "select maximum(cars_data.Accelerate), cars_data.Cylinders",
            "select maxima(cars_data.Accelerate), cars_data.Cylinders",
            "select min(cars_data.Accelerate), cars_data.Cylinders",
            "select Max(cars_data.Accelerate), cars_data.Cylinders",
            "select max(cars_data.Accelerate), cars_data.Cylinders.",
            "select max(cars_data.Accelerate), cars_data.Cylinders,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want to see the maximum acceleration for different numbers of cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list all of the maximum accelerations for each of the different cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-1-GROUP BY",
            "SELECT-FROM per-GROUP BY",
            "SELECT-FROM-4-GROUP BY",
            "SELECT-FROM -GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list all of the maximum accelerations for each of the different cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c6), t5.c2",
        "label": "select max(t5.c6), t5.c2",
        "score": true,
        "real_pred": "select max(cars_data.Accelerate), cars_data.Cylinders",
        "real_label": "select max(cars_data.Accelerate), cars_data.Cylinders",
        "topk_preds": [
            "select max(cars_data.Accelerate), cars_data.Cylinders",
            "select cars_data.Cylinders, max(cars_data.Accelerate)",
            "select maximum(cars_data.Accelerate), cars_data.Cylinders",
            "select Max(cars_data.Accelerate), cars_data.Cylinders",
            "select maxima(cars_data.Accelerate), cars_data.Cylinders",
            "select min(cars_data.Accelerate), cars_data.Cylinders",
            "select max(cars_data.Accelerate), cars_data.Cylinders.",
            "select max(cars_data.Accelerate), cars_data.Cylinders,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list all of the maximum accelerations for each of the different cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please provide the maximum acceleration for each cylinder., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM per-GROUP BY",
            "SELECT-FROM-1-GROUP BY",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM-3-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please provide the maximum acceleration for each cylinder., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c6), t5.c2",
        "label": "select max(t5.c6), t5.c2",
        "score": true,
        "real_pred": "select max(cars_data.Accelerate), cars_data.Cylinders",
        "real_label": "select max(cars_data.Accelerate), cars_data.Cylinders",
        "topk_preds": [
            "select max(cars_data.Accelerate), cars_data.Cylinders",
            "select cars_data.Cylinders, max(cars_data.Accelerate)",
            "select maximum(cars_data.Accelerate), cars_data.Cylinders",
            "select max(cars_data.Accelerate), cars_data.Cylinders.",
            "select max(cars_data.Accelerate), cars_data.Cylinders,",
            "select Max(cars_data.Accelerate), cars_data.Cylinders",
            "select maxim(cars_data.Accelerate), cars_data.Cylinders",
            "select max(cars_data.Accelerate), cars_data.Cylinders2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please provide the maximum acceleration for each cylinder., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many four-cylinder engines are there on the roads?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many four-cylinder engines are there on the roads?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), cars_data.Cylinders",
            "select count(*), cars_data.Id",
            "select count(*) (cars_data.Id)",
            "select count(*), t5.dcars_data.Id",
            "select count(*), cars_data.MPG",
            "select count(*), t5.dcars_data.MPG",
            "select count(*), t5.dcars_data.Cylinders"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many four-cylinder engines are there on the roads?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Identify all car models made by the company General Motors according to their weight exceeding 1,500 kilograms., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Identify all car models made by the company General Motors according to their weight exceeding 1,500 kilograms., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select distinct t3.c2",
        "score": false,
        "real_pred": "select car_names.Model",
        "real_label": "select distinct model_list.Model",
        "topk_preds": [
            "select car_names.Model",
            "select model_list.Model",
            "select car_names.Model, car_makers.FullName",
            "select distinct car_names.Model",
            "select model_list.Model, car_makers.Maker",
            "select car_names.Model, car_names.Make",
            "select distinct model_list.Model",
            "select distinct car_names.Model, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Identify all car models made by the company General Motors according to their weight exceeding 1,500 kilograms., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname (General Motors), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3 t4 t5",
        "score": false,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list car_names cars_data",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers model_list cars_data",
            "car_makers model_list car_names cars_data",
            "car_makers car_names cars_data",
            "",
            "countries car_makers model_list cars_data",
            "car_makers model_list car_makers car_names",
            "countries car_makers model_list car_names"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: When was cars of the weight of 3,000 to 4,000 kg made., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: When was cars of the weight of 3,000 to 4,000 kg made., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select t4.c7",
            "select t7.c7",
            "select t8.c7",
            "select t7",
            "select t12.c7",
            "select cars_data.Year",
            "select t6.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: When was cars of the weight of 3,000 to 4,000 kg made., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "car_names cars_data",
            "car_makers car_names cars_data",
            "model_list cars_data",
            "countries car_names cars_data",
            "countries cars_data",
            "car_makers cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Tell me about the years in which the cars weight less than 4000 and also cars weight more than 3000, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE,",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM when-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Tell me about the years in which the cars weight less than 4000 and also cars weight more than 3000, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t5.c7",
        "label": "select distinct t5.c7",
        "score": false,
        "real_pred": "select cars_data.Year",
        "real_label": "select distinct cars_data.Year",
        "topk_preds": [
            "select cars_data.Year",
            "select cars_data.Year, t5.c8",
            "select cars_data.Year, cars_data.Accelerate",
            "select cars_data.Year, cars_data.MPG0",
            "select cars_data.Year, cars_data.Cylinders",
            "select cars_data.Year, cars_data.MPG",
            "select cars_data.Year, cars_data.MPG2",
            "select cars_data.Year, cars_data.Edispl"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Tell me about the years in which the cars weight less than 4000 and also cars weight more than 3000, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "model_list cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The model with the highest amount of power from the four cylindrical engines is., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The model with the highest amount of power from the four cylindrical engines is., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select model_list.ModelId, model_list.Model",
            "select model_list.Model, cars_data.Horsepower",
            "select model_list.Model, cars_data.Edispl",
            "select model_list.Model, cars_data.MPG",
            "select model_list.Model, model_list.ModelId",
            "select model_list.Model, car_names.Model"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The model with the highest amount of power from the four cylindrical engines is., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "continents model_list cars_data",
            "countries model_list cars_data",
            "car_names cars_data",
            "car_makers cars_data",
            "",
            "",
            "countries cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of the four-cylinder cars, which model has the highest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of the four-cylinder cars, which model has the highest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c1",
        "label": "select t4.c1",
        "score": true,
        "real_pred": "select car_names.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select car_names.Model",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Model, car_names.Make",
            "select car_names.Model, cars_data.Id",
            "select car_names.Model, cars_data.Edispl",
            "select car_names.Model, cars_data.Weight",
            "select car_names.Model (car_names.Make)",
            "select car_names.Model (cars_data.Horsepower)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of the four-cylinder cars, which model has the highest power output?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "car_makers car_names cars_data",
            "countries car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "countries cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For all models that are four-cylinder engines, which model gives the most power?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For all models that are four-cylinder engines, which model gives the most power?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c2",
        "label": "select t4.c1",
        "score": false,
        "real_pred": "select model_list.Model",
        "real_label": "select car_names.Model",
        "topk_preds": [
            "select model_list.Model",
            "select car_names.Model",
            "select model_list.ModelId, model_list.Model",
            "select model_list.Model, cars_data.Horsepower",
            "select car_names.Model, cars_data.Cylinders",
            "select car_names.Make",
            "select car_names.Model, car_names.Make",
            "select model_list.Maker"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For all models that are four-cylinder engines, which model gives the most power?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t3 t5",
        "label": "t4 t5",
        "score": false,
        "real_pred": "model_list cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "model_list cars_data",
            "countries model_list cars_data",
            "car_names cars_data",
            "car_makers cars_data",
            "countries cars_data",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The cars with more than lowest horsepower are those that don't have more than three cylinders. Please list the brand of the vehicle as well as the make id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The cars with more than lowest horsepower are those that don't have more than three cylinders. Please list the brand of the vehicle as well as the make id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t4.c2, t4.c0",
        "label": "select t4.c0, t4.c2",
        "score": false,
        "real_pred": "select car_names.Make, car_names.MakeId",
        "real_label": "select car_names.MakeId, car_names.Make",
        "topk_preds": [
            "select car_names.Make, car_names.MakeId",
            "select car_names.Model, car_names.MakeId",
            "select distinct car_names.Make, car_names.MakeId",
            "select car_names.Make, car_names.MakeId",
            "select car_makers.FullName, car_names.MakeId",
            "select car_names.Make, t4c0",
            "select t4.c 2, car_names.MakeId",
            "select car_names.Make, car_names.MakeId."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The cars with more than lowest horsepower are those that don't have more than three cylinders. Please list the brand of the vehicle as well as the make id., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t4 t5",
        "label": "t4 t5",
        "score": true,
        "real_pred": "car_names cars_data",
        "real_label": "car_names cars_data",
        "topk_preds": [
            "car_names cars_data",
            "model_list car_names cars_data",
            "continents car_names cars_data",
            "car_makers cars_data",
            "countries car_names cars_data",
            "model_list cars_data",
            "countries cars_data",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of the cars with eight cylinders or manufactured before 1980, what was the maximum mileage per gallon?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of the cars with eight cylinders or manufactured before 1980, what was the maximum mileage per gallon?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c1)",
        "label": "select max(t5.c1)",
        "score": true,
        "real_pred": "select max(cars_data.MPG)",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select max(cars_data.MPG)",
            "select max(cars_data.MPG), cars_data.Cylinders",
            "select max(avg(cars_data.MPG)",
            "select max(cars_data.MPG), cars_data.Id",
            "select max(cars_data.MPG) de cars_data.Id",
            "select max(cars_data.MPG), cars_data.Year",
            "select max(cars_data.MPG), cars_data.Accelerate",
            "select max(cars_data.MPG), car_names.Make"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of the cars with eight cylinders or manufactured before 1980, what was the maximum mileage per gallon?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "car_names cars_data",
            "",
            "",
            "model_list cars_data"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the maximum mileage of vehicles with 8 cylinders or manufactured before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (max(t5.c1)",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (MAX(t5.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the maximum mileage of vehicles with 8 cylinders or manufactured before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c1)",
        "label": "select max(t5.c1)",
        "score": true,
        "real_pred": "select max(cars_data.MPG)",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select max(cars_data.MPG)",
            "select max(cars_data.MPG), cars_data.Cylinders",
            "select max(cars_data.MPG), cars_data.Year",
            "select max(cars_data.MPG), cars_data.Accelerate",
            "select max(cars_data.MPG) delegated to cars_data.Id",
            "select max(cars_data.MPG) delegated to cars_data.Cylinders",
            "select max(cars_data.MPG) delegated to cars_data.MPG",
            "select max(cars_data.MPG), t5.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the maximum mileage of vehicles with 8 cylinders or manufactured before 1980?, database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the highest fuel economy for cars which were built before 1980 or had eight cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the highest fuel economy for cars which were built before 1980 or had eight cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select max(t5.c1)",
        "label": "select max(t5.c1)",
        "score": true,
        "real_pred": "select max(cars_data.MPG)",
        "real_label": "select max(cars_data.MPG)",
        "topk_preds": [
            "select max(cars_data.MPG)",
            "select max(cars_data.MPG), cars_data.Cylinders",
            "select cars_data.MPG",
            "select min(cars_data.MPG)",
            "select max(cars_data.MPG) def. cars_data.Cylinders",
            "select max(cars_data.MPG), cars_data.Year",
            "select max(cars_data.MPG), cars_data.Accelerate",
            "select max(cars_data.MPG), t5.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the highest fuel economy for cars which were built before 1980 or had eight cylinders., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "cars_data",
        "real_label": "cars_data",
        "topk_preds": [
            "cars_data",
            "",
            "",
            "car_names cars_data",
            "car_makers cars_data",
            "model_list cars_data",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For what manufacturer makes at least two models and produces more than three cars please give me their model IDs and manufacturer name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING AND-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING - INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING and-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING,-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTENT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For what manufacturer makes at least two models and produces more than three cars please give me their model IDs and manufacturer name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t3.c0, t2.c2",
        "label": "select t2.c0, t2.c1",
        "score": false,
        "real_pred": "select model_list.ModelId, car_makers.FullName",
        "real_label": "select car_makers.Id, car_makers.Maker",
        "topk_preds": [
            "select model_list.ModelId, car_makers.FullName",
            "select model_list.ModelId, car_makers.Maker",
            "select model_list.Model, car_makers.Maker",
            "select car_makers.Id, car_makers.Maker",
            "select car_makers.Id, car_makers.FullName",
            "select car_names.MakeId, car_makers.FullName",
            "select model_list.Maker, car_makers.FullName",
            "select car_names.Model, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For what manufacturer makes at least two models and produces more than three cars please give me their model IDs and manufacturer name., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3 t4",
        "score": true,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list car_names",
        "topk_preds": [
            "car_makers model_list car_names",
            "countries car_makers model_list car_names",
            "",
            "continents car_makers model_list car_names",
            "car_makers model_list car_makers car_names",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter below the ids and names of all the companies which have at least two different models of cars produced in their factories as well as making more than three vehicles., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING/INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING AND-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING,-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM at-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING AND-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter below the ids and names of all the companies which have at least two different models of cars produced in their factories as well as making more than three vehicles., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t2.c0, t2.c2",
        "label": "select t2.c0, t2.c1",
        "score": false,
        "real_pred": "select car_makers.Id, car_makers.FullName",
        "real_label": "select car_makers.Id, car_makers.Maker",
        "topk_preds": [
            "select car_makers.Id, car_makers.FullName",
            "select car_makers.Id, car_makers.FullName, car_makers.Country",
            "select car_makers.Maker, car_makers.FullName",
            "select car_makers.Id, car_makers.Maker",
            "select car_makers.Id, car_makers.FullName.",
            "select car_makers.Id, car_makers.FullName,",
            "select car_names.Make, car_makers.Maker, car_makers.FullName",
            "select countries.CountryId, car_makers.FullName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter below the ids and names of all the companies which have at least two different models of cars produced in their factories as well as making more than three vehicles., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker, c2: fullname, c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model, c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t2 t3 t4",
        "label": "t2 t3 t4",
        "score": true,
        "real_pred": "car_makers model_list car_names",
        "real_label": "car_makers model_list car_names",
        "topk_preds": [
            "car_makers model_list car_names",
            "car_makers car_names",
            "",
            "",
            "countries car_makers model_list car_names",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the id and name of the countries that have at least three car manufacturers or produce cars under the model 'Fiat'., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GEO-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING or-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the id and name of the countries that have at least three car manufacturers or produce cars under the model 'Fiat'., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "select t1.c0, t1.c1",
        "label": "select t1.c0, t1.c1",
        "score": true,
        "real_pred": "select countries.CountryId, countries.CountryName",
        "real_label": "select countries.CountryId, countries.CountryName",
        "topk_preds": [
            "select countries.CountryId, countries.CountryName",
            "select car_makers.Id, countries.CountryName",
            "select countries.CountryId, countries.CountryName, car_makers.Country",
            "select countries.CountryName, countries.CountryId",
            "select t1, car_makers.Id, countries.CountryName",
            "select countries.CountryId, countries.CountryName,",
            "select car_names.Model, countries.CountryId",
            "select countries.CountryId, countries.CountryName, min(car_makers.Country)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the id and name of the countries that have at least three car manufacturers or produce cars under the model 'Fiat'., database: Database: car_1. t0: continents(c0: contid, c1: continent). t1: countries(c0: countryid, c1: countryname, c2: continent) (c2) refers to t0(c0). t2: car_makers(c0: id, c1: maker (fiat), c2: fullname (Fiat), c3: country) (c3) refers to t1(c0). t3: model_list(c0: modelid, c1: maker, c2: model (fiat)) (c1) refers to t2(c0). t4: car_names(c0: makeid, c1: model (fiat), c2: make) (c1) refers to t3(c2). t5: cars_data(c0: id, c1: mpg, c2: cylinders, c3: edispl, c4: horsepower, c5: weight, c6: accelerate, c7: year) (c0) refers to t4(c0).",
        "prediction": "t1 t2 t3 t4",
        "label": "t1 t2 t3",
        "score": false,
        "real_pred": "countries car_makers model_list car_names",
        "real_label": "countries car_makers model_list",
        "topk_preds": [
            "countries car_makers model_list car_names",
            "countries car_makers model_list",
            "",
            "",
            "",
            "",
            "",
            "countries car_makers"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the acronym for JetBlue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the acronym for JetBlue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select airlines.Abbreviation",
        "real_label": "select airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Airline",
            "select avg(airlines.Abbreviation)",
            "select airlines.Abbreviation (or airlines.Country)",
            "select airlines.Abbreviation2",
            "select airlines.Abbreviation, airlines.Country",
            "select jetblue.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the acronym for JetBlue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the short form of Airline \"JetBlue Airways\"., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the short form of Airline \"JetBlue Airways\"., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select airlines.Abbreviation",
        "real_label": "select airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Airline",
            "select airlines.Airline-, airlines.Abbreviation",
            "select airlines.Airline",
            "select airlines.Abbreviation (or airlines.Country)",
            "select airlines.Abbreviation (or airlines.Airline)",
            "select jetblue.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the short form of Airline \"JetBlue Airways\"., database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the short form for the full name of JetBlue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the short form for the full name of JetBlue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c2",
        "score": false,
        "real_pred": "select airlines.Airline, airlines.Abbreviation",
        "real_label": "select airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Airline",
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.Airline + airlines.Abbreviation",
            "select airlines.Airline-, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, airlines.Abbreviation2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the short form for the full name of JetBlue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the numbers for the flights coming from Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the numbers for the flights coming from Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select flights.FlightNo",
        "real_label": "select flights.FlightNo",
        "topk_preds": [
            "select flights.FlightNo",
            "select flights.FlightNo, airports.City",
            "select distinct flights.FlightNo",
            "select flights.FlightNo, airports.AirportName",
            "select flights.FlightNo, airports.AirportCode",
            "select unique flights.FlightNo",
            "select flights.FlightNo (flights.Airline)",
            "select the flights.FlightNo"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the numbers for the flights coming from Aberdeen?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like you to display (or return) the codes of the flights from Aberdeen Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INVIT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like you to display (or return) the codes of the flights from Aberdeen Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select flights.FlightNo",
        "real_label": "select flights.FlightNo",
        "topk_preds": [
            "select flights.FlightNo",
            "select flights.FlightNo, airports.AirportCode",
            "select flights.FlightNo, airports.AirportName",
            "select flights.FlightNo (or return flights.FlightNo)",
            "select flights.FlightNo (or flights.DestAirport)",
            "select flights.FlightNo, flights.SourceAirport",
            "select flights.FlightNo, airports.City",
            "select flights.FlightNo (or flights.SourceAirport)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like you to display (or return) the codes of the flights from Aberdeen Airport., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find every company that has routes from both of airports' 'APG' and 'CVO'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROMWHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM'-WHERE",
            "SELECT-FROM-WHERE-INTERSECTS-SELECT-FROM-WHERE",
            "SELECT-FROMWHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find every company that has routes from both of airports' 'APG' and 'CVO'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select flights.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select flights.Airline",
            "select airlines.Airline",
            "select flights.FlightNo",
            "select airlines.Airline, airlines.Abbreviation",
            "select flights.Airline, airlines.Airline",
            "select flights.Airline, flights.FlightNo",
            "select airlines.Airline, flights.SourceAirport",
            "select flights.Airline, flights.SourceAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find every company that has routes from both of airports' 'APG' and 'CVO'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "airports flights",
            "flights",
            "",
            "",
            "airlines airports airports flights",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the list of all the companies which fly from both airports 'APG' and 'CVO'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROMWHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECTS-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROMWHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the list of all the companies which fly from both airports 'APG' and 'CVO'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select flights.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select flights.Airline",
            "select flights.FlightNo",
            "select flights.Airline, flights.SourceAirport",
            "select airlines.Airline",
            "select flights.Airline, airlines.Airline",
            "select flights.FlightNo, flights.DestAirport",
            "select flights.Airline, airports.AirportName",
            "select flights.FlightNo, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the list of all the companies which fly from both airports 'APG' and 'CVO'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airports flights",
            "airlines airports flights",
            "flights",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the letters that correspond to Jetblue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the letters that correspond to Jetblue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2",
        "label": "select t0.c2",
        "score": true,
        "real_pred": "select airlines.Abbreviation",
        "real_label": "select airlines.Abbreviation",
        "topk_preds": [
            "select airlines.Abbreviation",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Airline",
            "select airlines.Airline",
            "select distinct airlines.Abbreviation",
            "select jetblue.c2",
            "select airlines.Abbreviation (compare airlines.Airline)",
            "select the airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the letters that correspond to Jetblue Airways?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (JetBlue Airways), c2: abbreviation (JetBlue), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of the flights out of AHD, how many were 'United Airlines'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of the flights out of AHD, how many were 'United Airlines'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(*), flights.SourceAirport",
            "select count(*), airlines.Airline",
            "select count(distinct flights.FlightNo)",
            "select flights.Airline, count(*)",
            "select count(*), airports.AirportName",
            "select count(*), flights.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of the flights out of AHD, how many were 'United Airlines'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "airlines airports",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of the flight out of AHD, how many are United Airlines?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE - GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY -LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY (LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of the flight out of AHD, how many are United Airlines?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select flights.Airline, count(*)",
            "select airlines.Airline, count(*)",
            "select count(distinct flights.Airline)",
            "select count(distinct flights.FlightNo)",
            "select flights.FlightNo, count(*)",
            "select count(AHD-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of the flight out of AHD, how many are United Airlines?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of all the flights coming out of 'AHD', how many were 'United Airlines'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE - GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE/GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of all the flights coming out of 'AHD', how many were 'United Airlines'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(*), flights.SourceAirport",
            "select count(*), flights.SourceAirport, flights.DestAirport",
            "select count(*), airlines.Airline, flights.SourceAirport",
            "select flights.Airline, count(*)",
            "select count(*), airlines.Airline",
            "select count(distinct flights.FlightNo)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of all the flights coming out of 'AHD', how many were 'United Airlines'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of the flights out of AHD, how many were United Airlines?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE/GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of the flights out of AHD, how many were United Airlines?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(distinct flights.Airline)",
            "select count(distinct flights.FlightNo)",
            "select airlines.Airline, count(*)",
            "select flights.Airline, count(*)",
            "select count(*), flights.SourceAirport",
            "select count(flights.Airline)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of the flights out of AHD, how many were United Airlines?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many of the flights out of 'AHD' were United Airlines?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE/GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE/GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many of the flights out of 'AHD' were United Airlines?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), airlines.Airline",
            "select count(distinct flights.Airline)",
            "select count(distinct flights.FlightNo)",
            "select count(*), flights.SourceAirport, flights.DestAirport",
            "select count(*), airlines.Airline, flights.SourceAirport",
            "select count(*), airlines.Airline",
            "select count(*), airlines.Airline, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many of the flights out of 'AHD' were United Airlines?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline (United Airlines), c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Provide all the numbers for all flights that are departing from Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Provide all the numbers for all flights that are departing from Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select flights.FlightNo",
        "real_label": "select flights.FlightNo",
        "topk_preds": [
            "select flights.FlightNo",
            "select flights.FlightNo, airports.City",
            "select flights.FlightNo, airports.AirportName",
            "select distinct flights.FlightNo",
            "select all flights.FlightNo",
            "select flights.FlightNo, airports.AirportCode",
            "select flights.FlightNo, airports.Country",
            "select the flights.FlightNo"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Provide all the numbers for all flights that are departing from Aberdeen., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city (Aberdeen), c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me all the airlines that fly into 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me all the airlines that fly into 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select flights.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select flights.Airline",
            "select flights.Airline, airlines.Airline",
            "select flights.Airline, flights.SourceAirport",
            "select airlines.Airline",
            "select flights.Airline, airports.AirportName",
            "select avg(flights.Airline)",
            "select distinct flights.Airline",
            "select airlines.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me all the airlines that fly into 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airports flights",
            "airlines airports flights",
            "",
            "flights",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the airlines that fly into 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the airlines that fly into 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select flights.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select flights.Airline",
            "select airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, airports.AirportName",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, flights.SourceAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the airlines that fly into 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "",
            "airports flights",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me all the information regarding to airlines landing at airport 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INVEST-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE INVEST-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me all the information regarding to airlines landing at airport 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select *",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select *",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select *",
            "select flights.Airline, flights.DestAirport",
            "select flights.Airline, flights.SourceAirport",
            "select detailed info(flights.Airline)",
            "select flights.Airline",
            "select every bit of info(flights.Airline)",
            "select flights.Airline, airports.AirportName",
            "select flights.Airline, flights.FlightNo"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me all the information regarding to airlines landing at airport 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airports flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airlines fly into  AHD '?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ATTACH-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ATTACH-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airlines fly into  AHD '?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select flights.Airline",
            "select airlines.Airline, airports.AirportName",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.Airline",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, flights.SourceAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airlines fly into  AHD '?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list all airlines that fly into 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list all airlines that fly into 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select flights.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select flights.Airline",
            "select airlines.Airline",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select flights.Airline, flights.SourceAirport",
            "select airlines.Airline, flights.Airline",
            "select flights.Airline, airports.AirportName",
            "select airlines.Airline, airlines.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list all airlines that fly into 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "airports flights",
            "",
            "flights",
            "airlines flights",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I am interested in knowing about which companies operate flights to '' AHD ''., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ATTACH-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ATTACH-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ATTACH-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I am interested in knowing about which companies operate flights to '' AHD ''., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select flights.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select flights.Airline",
            "select flights.Airline, flights.FlightNo",
            "select flights.Airline, flights.DestAirport",
            "select flights.Airline, flights.SourceAirport",
            "select flights.Airline, airlines.Airline",
            "select flights.Airline, airports.AirportName",
            "select distinct flights.Airline",
            "select flights.Airline, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I am interested in knowing about which companies operate flights to '' AHD ''., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "flights",
            "airports flights",
            "airlines airports flights",
            "",
            "",
            "",
            "airlines flights",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airports doesn't have any outgoing or incoming flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-SECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airports doesn't have any outgoing or incoming flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportName, flights.SourceAirport",
            "select airports.City, airports.AirportCode",
            "select airports.AirportName, airports.Country",
            "select airports.AirportName,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airports doesn't have any outgoing or incoming flights?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "airports",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me the airports that do not have any incoming or outgoing flight., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me the airports that do not have any incoming or outgoing flight., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportName, airports.AirportCode, airports.Country",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.City, airports.AirportName, airports.Country",
            "select airports.AirportName de-selected, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me the airports that do not have any incoming or outgoing flight., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1 t2",
        "score": false,
        "real_pred": "airports",
        "real_label": "airports flights",
        "topk_preds": [
            "airports",
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me all the airports that do not have a flight taking off or landing at them., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-I-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me all the airports that do not have a flight taking off or landing at them., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.City, airports.AirportName, airports.Country",
            "select airports.AirportName, airports.AirportCode, airports.Country",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportName de-selected, airports.AirportCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me all the airports that do not have a flight taking off or landing at them., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "airports",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of the airports that do not have flights arriving into them and departing to them?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of the airports that do not have flights arriving into them and departing to them?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.AirportName, flights.SourceAirport",
            "select airports.AirportName, airports.Country",
            "select airports.AirportCode, airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.AirportName, flights.DestAirport",
            "select airports.AirportName, t1.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of the airports that do not have flights arriving into them and departing to them?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "airports",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of these airports, list the ones that have no incoming or outgoing flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of these airports, list the ones that have no incoming or outgoing flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.City, airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.City, airports.AirportName, airports.Country",
            "select airports.AirportCode, airports.AirportName, airports.Country",
            "select airports.AirportName, airports.AirportCode, airports.Country",
            "select airports.AirportName, flights.SourceAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of these airports, list the ones that have no incoming or outgoing flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1",
        "label": "t1 t2",
        "score": false,
        "real_pred": "airports",
        "real_label": "airports flights",
        "topk_preds": [
            "airports",
            "",
            "airports flights",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to find out if there are any airports without any incoming or outgoing flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-FROM-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to find out if there are any airports without any incoming or outgoing flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select airports.AirportName",
        "real_label": "select airports.AirportName",
        "topk_preds": [
            "select airports.AirportName",
            "select airports.AirportCode, airports.AirportName",
            "select airports.AirportName, airports.AirportCode",
            "select airports.City, airports.AirportName",
            "select airports.AirportName, flights.SourceAirport",
            "select empty airports.AirportName",
            "select airports.City",
            "select airports.AirportName, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to find out if there are any airports without any incoming or outgoing flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "airports flights",
        "real_label": "airports flights",
        "topk_preds": [
            "airports flights",
            "airports",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which company does UAL belong to?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (UAL), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INSERT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-CORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which company does UAL belong to?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (UAL), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Country",
            "select airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Country",
            "select t0.c5",
            "select t0.c7",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Abbreviation, airlines.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which company does UAL belong to?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation (UAL), c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "airlines",
        "real_label": "airlines",
        "topk_preds": [
            "airlines",
            "airlines airports",
            "",
            "",
            "airlines airports flights",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need to find the acronym and country of the airline that had the least number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need to find the acronym and country of the airline that had the least number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c2, t0.c3",
        "label": "select t0.c2, t0.c3",
        "score": true,
        "real_pred": "select airlines.Abbreviation, airlines.Country",
        "real_label": "select airlines.Abbreviation, airlines.Country",
        "topk_preds": [
            "select airlines.Abbreviation, airlines.Country",
            "select airlines.Airline, airlines.Abbreviation, airlines.Country",
            "select airlines.uid, airlines.Abbreviation, airlines.Country",
            "select airlines.Country, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Abbreviation, airlines.Country, airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Abbreviation.c2, airlines.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need to find the acronym and country of the airline that had the least number of flights., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode, c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport, c3: destairport) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "",
            "",
            "",
            "",
            "",
            "",
            "airlines airports flights"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List airlines who had taken off from airport 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List airlines who had taken off from airport 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select flights.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select flights.Airline",
            "select airlines.Airline",
            "select flights.Airline, flights.SourceAirport",
            "select flights.Airline, airlines.Airline",
            "select flights.Airline, airports.AirportName",
            "select airlines.Airline, airports.AirportName",
            "select flights.Airline, airports.AirportCode",
            "select airlines.Airline, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List airlines who had taken off from airport 'AHD'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airports flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which airlines flew from Airport 'AHD'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which airlines flew from Airport 'AHD'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select flights.Airline",
            "select flights.FlightNo",
            "select airlines.Airline, airports.AirportName",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.Airline",
            "select flights.FlightNo, airlines.Abbreviation"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which airlines flew from Airport 'AHD'?, database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airports flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Provide a list of airlines that fly to the airport of AHD., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (t0.c1) SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Provide a list of airlines that fly to the airport of AHD., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select flights.Airline",
            "select airlines.Airline, airports.AirportName",
            "select flights.FlightNo",
            "select flights.Airline, airports.AirportName",
            "select airlines.Airline, airlines.Abbreviation",
            "select a airlines.Airline",
            "select airlines.Airline, airlines.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Provide a list of airlines that fly to the airport of AHD., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the names of the airlines having flights to AHD.'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the names of the airlines having flights to AHD.'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, airlines.Country",
            "select airlines.Airline, flights.Airline",
            "select distinct airlines.Airline",
            "select airlines.Airline, airports.AirportName",
            "select distinct airlines.Airline, airlines.Abbreviation",
            "select avg(airlines.Airline)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the names of the airlines having flights to AHD.'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (AHD), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (AHD), c3: destairport (AHD)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all those airlines that fly out of CVO but not out of APG below., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHEREE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE BUT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all those airlines that fly out of CVO but not out of APG below., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select airlines.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select airlines.Airline",
            "select flights.Airline",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.Airline",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, flights.FlightNo",
            "select airlines.Airline, airlines.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all those airlines that fly out of CVO but not out of APG below., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t1 t2",
        "label": "t0 t2",
        "score": false,
        "real_pred": "airlines airports flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines airports flights",
            "airlines flights",
            "",
            "",
            "airports flights",
            "",
            "flights",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me a list of the airlines which have flown out of CVO but not APG., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHEREE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE BUT-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me a list of the airlines which have flown out of CVO but not APG., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select flights.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select flights.Airline",
            "select airlines.Airline",
            "select flights.Airline, flights.SourceAirport",
            "select airlines.Airline, airlines.Abbreviation",
            "select flights.Airline, airlines.Airline",
            "select flights.FlightNo",
            "select airlines.Airline, flights.SourceAirport",
            "select airlines.Airline, airlines.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me a list of the airlines which have flown out of CVO but not APG., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "flights",
            "airports flights",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need to find all airlines that fly out of 'CVO' but do not go out of 'APG'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHEREE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need to find all airlines that fly out of 'CVO' but do not go out of 'APG'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select flights.Airline",
        "real_label": "select airlines.Airline",
        "topk_preds": [
            "select flights.Airline",
            "select airlines.Airline",
            "select flights.Airline, airlines.Airline",
            "select airlines.Airline, airlines.Abbreviation",
            "select flights.Airline, airlines.Abbreviation",
            "select airlines.Airline, flights.SourceAirport",
            "select flights.Airline, flights.SourceAirport",
            "select airlines.Airline, flights.Airline"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need to find all airlines that fly out of 'CVO' but do not go out of 'APG'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG, CVO), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG, CVO), c3: destairport (APG, CVO)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "airlines flights",
        "real_label": "airlines flights",
        "topk_preds": [
            "airlines flights",
            "airlines airports flights",
            "flights",
            "airports flights",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The flight numbers of the flights out of \"APG\" are listed below., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG), c3: destairport (APG)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The flight numbers of the flights out of \"APG\" are listed below., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG), c3: destairport (APG)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select flights.FlightNo",
        "real_label": "select flights.FlightNo",
        "topk_preds": [
            "select flights.FlightNo",
            "select flights.FlightNo, flights.SourceAirport",
            "select flights.FlightNo, flights.SourceAirport, flights.DestAirport",
            "select flights.FlightNo, flights.DestAirport",
            "select distinct flights.FlightNo",
            "select flights.FlightNoavg(flights.FlightNo)",
            "select flights.FlightNo, flights.SourceAirport (if flights.DestAirport)",
            "select flights.FlightNo, flights.SourceAirport - flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The flight numbers of the flights out of \"APG\" are listed below., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG), c3: destairport (APG)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "flights",
        "real_label": "flights",
        "topk_preds": [
            "flights",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me the numbers of the flights flying out of APG., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG), c3: destairport (APG)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me the numbers of the flights flying out of APG., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG), c3: destairport (APG)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select flights.FlightNo",
        "real_label": "select flights.FlightNo",
        "topk_preds": [
            "select flights.FlightNo",
            "select flights.FlightNo, flights.SourceAirport, flights.DestAirport",
            "select flights.FlightNo, flights.SourceAirport",
            "select count(*)",
            "select flights.FlightNo, flights.DestAirport",
            "select flights.FlightNo, flights.SourceAirport (APG), flights.DestAirport",
            "select the flights.FlightNo",
            "select flights.FlightNo, flights.SourceAirport.c2, flights.DestAirport"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me the numbers of the flights flying out of APG., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG), c3: destairport (APG)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "flights",
        "real_label": "flights",
        "topk_preds": [
            "flights",
            "airports flights",
            "airlines airports flights",
            "airlines flights",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need the flight numbers for all flights that landed in 'APG'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG), c3: destairport (APG)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need the flight numbers for all flights that landed in 'APG'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG), c3: destairport (APG)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select flights.FlightNo",
        "real_label": "select flights.FlightNo",
        "topk_preds": [
            "select flights.FlightNo",
            "select flights.FlightNo, flights.DestAirport",
            "select flights.FlightNo, flights.SourceAirport",
            "select flights.FlightNo, flights.SourceAirport, flights.DestAirport",
            "select flights.FlightNo, airports.AirportCode",
            "select flights.FlightNo, airports.AirportName, flights.DestAirport",
            "select flights.FlightNo, airports.AirportCode, flights.DestAirport",
            "select flights.FlightNo, airports.AirportName"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need the flight numbers for all flights that landed in 'APG'., database: Database: flight_2. t0: airlines(c0: uid, c1: airline, c2: abbreviation, c3: country). t1: airports(c0: city, c1: airportcode (APG), c2: airportname, c3: country, c4: countryabbrev). t2: flights(c0: airline, c1: flightno, c2: sourceairport (APG), c3: destairport (APG)) (c3) refers to t1(c1), (c2) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "flights",
        "real_label": "flights",
        "topk_preds": [
            "flights",
            "airports flights",
            "airlines airports flights",
            "airlines flights",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many stores are found at each area?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM",
            "SELECT-FROM at-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many stores are found at each area?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c2, count(*)",
        "label": "select count(*), t1.c2",
        "score": false,
        "real_pred": "select shop.Location, count(*)",
        "real_label": "select count(*), shop.Location",
        "topk_preds": [
            "select shop.Location, count(*)",
            "select shop.District, count(*)",
            "select shop.Location.c3, count(*)",
            "select shop_shop.Location, count(*)",
            "select count(*), shop.Location",
            "select shop.Location3, count(*)",
            "select distinct shop.Location, count(*)",
            "select shop.Location-, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many stores are found at each area?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the name of the boss and district of this store which sold the most products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the name of the boss and district of this store which sold the most products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c5, t1.c3",
        "label": "select t1.c5, t1.c3",
        "score": true,
        "real_pred": "select shop.Manager_name, shop.District",
        "real_label": "select shop.Manager_name, shop.District",
        "topk_preds": [
            "select shop.Manager_name, shop.District",
            "select shop.Name, shop.District",
            "select shop.Manager_name, shop.Location",
            "select shop.Location, shop.Manager_name",
            "select shop.Manager_name, shop.District,",
            "select shop.District, shop.Manager_name",
            "select shop.Number_products, shop.District",
            "select shop.Manager_name, shop.District."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the name of the boss and district of this store which sold the most products?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the maximum and minimum number of items across all shops?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the maximum and minimum number of items across all shops?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select max(t1.c4), min(t1.c4)",
        "label": "select min(t1.c4), max(t1.c4)",
        "score": false,
        "real_pred": "select max(shop.Number_products), min(shop.Number_products)",
        "real_label": "select min(shop.Number_products), max(shop.Number_products)",
        "topk_preds": [
            "select max(shop.Number_products), min(shop.Number_products)",
            "select max(t1.c6), min(shop.Number_products)",
            "select max(shop.Manager_name), min(shop.Number_products)",
            "select max(t1.c8), min(shop.Number_products)",
            "select max(shop.District), min(shop.Number_products)",
            "select max(shop.Location), min(shop.Number_products)",
            "select max(t1.c6), min(t1.c6)",
            "select max(t1.c7), min(shop.Number_products)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the maximum and minimum number of items across all shops?, database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The minimum and maximum number of goods across all the stores is given here., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM the sum(t1.c4), max(t1.c4)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM the sum(t1.c4), min(t1.c4)",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The minimum and maximum number of goods across all the stores is given here., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select min(t1.c4), max(t1.c4)",
        "label": "select min(t1.c4), max(t1.c4)",
        "score": true,
        "real_pred": "select min(shop.Number_products), max(shop.Number_products)",
        "real_label": "select min(shop.Number_products), max(shop.Number_products)",
        "topk_preds": [
            "select min(shop.Number_products), max(shop.Number_products)",
            "select min(shop.District), max(shop.Number_products)",
            "select min(shop.Location), max(shop.Number_products)",
            "select min(shop.Manager_name), max(shop.Number_products)",
            "select min(t1.c6), max(t1.c6)",
            "select min(t1.c6), max(shop.Number_products)",
            "select min(t1.c8), max(shop.Number_products)",
            "select min(shop.Number_products), max(shop.Number_products)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The minimum and maximum number of goods across all the stores is given here., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please sort all the shops that contain products in descending order by product count, return the name of the store, the location of the store, and the name of its district., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-FROM-WHERE-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING ORDER BY",
            "SELECT-FROM-GROUP BY-HAVINGORDER BY",
            "SELECT-FROM-WHERE-ORDER BY."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please sort all the shops that contain products in descending order by product count, return the name of the store, the location of the store, and the name of its district., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c3",
        "label": "select t1.c1, t1.c2, t1.c3",
        "score": true,
        "real_pred": "select shop.Name, shop.Location, shop.District",
        "real_label": "select shop.Name, shop.Location, shop.District",
        "topk_preds": [
            "select shop.Name, shop.Location, shop.District",
            "select shop.Name, shop.District, shop.Location",
            "select shop.Name, shop.Location and shop.District",
            "select shop.Name, shop.Location, shop.District",
            "select shop.Name, shop.Location, shop.District.",
            "select shop.Name, shop.Location, shop.District",
            "select shop.Name, shop.Location & shop.District",
            "select shop.Name, t1.c 2, shop.District"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please sort all the shops that contain products in descending order by product count, return the name of the store, the location of the store, and the name of its district., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For getting sorted shops, sort them by their total product count in descending order, and for each shop, list its name, location and the district where it is located., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY (t1.c1), t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY t1.C1, t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2 and t1.c3",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2 & t1.c3",
            "SELECT-FROM-ORDER BY (c1), t1.c2, t1.c3",
            "SELECT-FROM-ORDER BY t1.c1, t1.c2, t1.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For getting sorted shops, sort them by their total product count in descending order, and for each shop, list its name, location and the district where it is located., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2, t1.c3",
        "label": "select t1.c1, t1.c2, t1.c3",
        "score": true,
        "real_pred": "select shop.Name, shop.Location, shop.District",
        "real_label": "select shop.Name, shop.Location, shop.District",
        "topk_preds": [
            "select shop.Name, shop.Location, shop.District",
            "select shop.Name, shop.Location, shop.District",
            "select shop.Name, shop.Location, shop.District",
            "select shop.Name, shop.Location and shop.District",
            "select shop.Name, shop.District, shop.Location",
            "select shop.Name, shop.Location & shop.District",
            "select shop.Name, shop.Location., shop.District",
            "select shop.Name, shop.Location, shop.District,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For getting sorted shops, sort them by their total product count in descending order, and for each shop, list its name, location and the district where it is located., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the names of stores which have more products than the average product count., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the names of stores which have more products than the average product count., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Number_products",
            "select shop.Name - shop.Manager_name",
            "select shop.Name (or shop.Manager_name)",
            "select shop.Name, t1.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the names of stores which have more products than the average product count., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: To find the name of the store which sells in quantity of more than the average total number of items., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOMETRY-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAUSS-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: To find the name of the store which sells in quantity of more than the average total number of items., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Number_products",
            "select shop.Name, t1.c6",
            "select shop.Name Item_count(*)",
            "select shop.Name (shop.Number_products)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: To find the name of the store which sells in quantity of more than the average total number of items., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of the shops' products, which ones are above the average? Provide the names of those businesses., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of the shops' products, which ones are above the average? Provide the names of those businesses., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select shop.Name",
        "real_label": "select shop.Name",
        "topk_preds": [
            "select shop.Name",
            "select shop.Name, shop.Number_products",
            "select shop.Name, shop.District",
            "select shop.Name, shop.Location",
            "select shop.Name, shop.Manager_name",
            "select shop.Name, t1.c6",
            "select shop.Name (shop.Number_products)",
            "select shop.Name (or shop.Manager_name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of the shops' products, which ones are above the average? Provide the names of those businesses., database: Database: employee_hire_evaluation. t0: employee(c0: employee_id, c1: name, c2: age, c3: city). t1: shop(c0: shop_id, c1: name, c2: location, c3: district, c4: number_products, c5: manager_name). t2: hiring(c0: shop_id, c1: employee_id, c2: start_from, c3: is_full_time) (c1) refers to t0(c0), (c0) refers to t1(c0). t3: evaluation(c0: employee_id, c1: year_awarded, c2: bonus) (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "shop",
        "real_label": "shop",
        "topk_preds": [
            "shop",
            "shop hiring",
            "",
            "shop hiring evaluation",
            "shop evaluation",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all template types and their description., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all template types and their description., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "real_label": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "topk_preds": [
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, Ref_Template_Types.Template_Type_Code",
            "select t0.c2, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description.",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description,",
            "select t0.d0, Ref_Template_Types.Template_Type_Description",
            "select t0.c, Ref_Template_Types.Template_Type_Description",
            "select t 0.c0, Ref_Template_Types.Template_Type_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all template types and their description., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Ref_Template_Types",
        "real_label": "Ref_Template_Types",
        "topk_preds": [
            "Ref_Template_Types",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like you to show me all template type ids and their descriptions., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM INVEST-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like you to show me all template type ids and their descriptions., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "real_label": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "topk_preds": [
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, Ref_Template_Types.Template_Type_Code",
            "select Templates.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Documents.Document_Name, Ref_Template_Types.Template_Type_Description",
            "select Paragraphs.Paragraph_ID, Ref_Template_Types.Template_Type_Description",
            "select Documents.Document_ID, Ref_Template_Types.Template_Type_Description",
            "select Documents.Template_ID, Ref_Template_Types.Template_Type_Description",
            "select t 0.c0, Ref_Template_Types.Template_Type_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like you to show me all template type ids and their descriptions., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Ref_Template_Types",
        "real_label": "Ref_Template_Types",
        "topk_preds": [
            "Ref_Template_Types",
            "Ref_Template_Types Templates",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show all template type descriptions and their template types., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM (GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show all template type descriptions and their template types., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t0.c1, t1.c2",
        "label": "select t0.c0, t0.c1",
        "score": false,
        "real_pred": "select Ref_Template_Types.Template_Type_Description, Templates.Template_Type_Code",
        "real_label": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "topk_preds": [
            "select Ref_Template_Types.Template_Type_Description, Templates.Template_Type_Code",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, Ref_Template_Types.Template_Type_Code",
            "select Ref_Template_Types.Template_Type_Description, Documents.Document_Name",
            "select Ref_Template_Types.Template_Type_Description, Templates.Template_ID",
            "select Ref_Template_Types.Template_Type_Description.c1, Templates.Template_Type_Code",
            "select Ref_Template_Types.Template_Type_Description, Templates.Version_Number",
            "select Ref_Template_Types.Template_Type_Description, t01.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show all template type descriptions and their template types., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0 t1",
        "label": "t0",
        "score": false,
        "real_pred": "Ref_Template_Types Templates",
        "real_label": "Ref_Template_Types",
        "topk_preds": [
            "Ref_Template_Types Templates",
            "Ref_Template_Types",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list all template types and their description., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list all template types and their description., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "real_label": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "topk_preds": [
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, Ref_Template_Types.Template_Type_Code",
            "select t0.c2, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description.",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description,",
            "select Ref_Template_Types.Template_Type_Description, t0.c2",
            "select t0.c, Ref_Template_Types.Template_Type_Description",
            "select t 0.c0, Ref_Template_Types.Template_Type_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list all template types and their description., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Ref_Template_Types",
        "real_label": "Ref_Template_Types",
        "topk_preds": [
            "Ref_Template_Types",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the list of all template types as well as their description., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the list of all template types as well as their description., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "real_label": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "topk_preds": [
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, Ref_Template_Types.Template_Type_Code",
            "select t0.c2, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, t0.c2",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description.",
            "select Templates.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select t0.c, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the list of all template types as well as their description., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Ref_Template_Types",
        "real_label": "Ref_Template_Types",
        "topk_preds": [
            "Ref_Template_Types",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me the codes, names and descriptions of all documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me the codes, names and descriptions of all documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c1, t2.c2, t2.c3",
        "label": "select t2.c0, t2.c2, t2.c3",
        "score": false,
        "real_pred": "select Documents.Template_ID, Documents.Document_Name, Documents.Document_Description",
        "real_label": "select Documents.Document_ID, Documents.Document_Name, Documents.Document_Description",
        "topk_preds": [
            "select Documents.Template_ID, Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Document_Name, Documents.Document_Description",
            "select Documents.Template_ID, Documents.Document_Name, Documents.Document_Description",
            "select Documents.Template_ID, Documents.Document_Description, Documents.Document_Name",
            "select Documents.Document_Name, Documents.Document_Description, Documents.Other_Details",
            "select Documents.Template_ID), Documents.Document_Name, Documents.Document_Description",
            "select Documents.Template_ID, Documents.Document_Name, Documents.Document_Description",
            "select Documents.Document_Name, Documents.Document_Description, Documents.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me the codes, names and descriptions of all documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all template types ids and their corresponding numbers of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (t1.c2) et count(*)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY (t1.c2), count(*)",
            "SELECT-FROM-GROUP BY (t1.c2) & count(*)",
            "SELECT-FROM-GROUP BY, count(*)",
            "SELECT-FROM-GROUP BY (t1.c2)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all template types ids and their corresponding numbers of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2, count(*)",
        "label": "select t1.c2, count(*)",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code, count(*)",
        "real_label": "select Templates.Template_Type_Code, count(*)",
        "topk_preds": [
            "select Templates.Template_Type_Code, count(*)",
            "select Templates.Template_Type_Code.c2, count(*)",
            "select Templates.Template_Type_Code, count(*), Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, count(**)",
            "select Templates.Template_Type_Code, count(*),",
            "select Templates.Template_Type_Code, count(Templates.Template_ID)",
            "select Templates.Template_Type_Code, count(*), Templates.Version_Number",
            "select Templates.Template_Type_Code, count(*), Templates.Template_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all template types ids and their corresponding numbers of templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need you to show me all template style code and their count for each template design., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-VARIATION-GROUP BY",
            "SELECT-FROM-GROUP BY, count(*)",
            "SELECT-FROM-GROUP BY (t1.c2)",
            "SELECT-FROM-1-GROUP BY",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GIGROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need you to show me all template style code and their count for each template design., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2, count(*)",
        "label": "select t1.c2, count(*)",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code, count(*)",
        "real_label": "select Templates.Template_Type_Code, count(*)",
        "topk_preds": [
            "select Templates.Template_Type_Code, count(*)",
            "select Templates.Template_Type_Code, count(*), Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, count(**)",
            "select Documents.Document_Name, count(*)",
            "select Templates.Template_Type_Code.c2, count(*)",
            "select Templates.Template_Type_Code, count(*),",
            "select Templates.Template_Type_Code, count(*)",
            "select Templates.Template_Type_Code, count(*), Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need you to show me all template style code and their count for each template design., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "Templates Documents Paragraphs",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter all template type ids and the number of templates used for each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY, count(*)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY (t1.c2)",
            "SELECT-FROM-GROUP BY.",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GROUP BY (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter all template type ids and the number of templates used for each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2, count(*)",
        "label": "select t1.c2, count(*)",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code, count(*)",
        "real_label": "select Templates.Template_Type_Code, count(*)",
        "topk_preds": [
            "select Templates.Template_Type_Code, count(*)",
            "select Templates.Template_Type_Code, count(*), Templates.Date_Effective_From",
            "select Templates.Template_Type_Code.c2, count(*)",
            "select Templates.Template_Type_Code, count(**)",
            "select Templates.Template_Type_Code-Templates.Template_Details, count(*)",
            "select Templates.Template_Type_Code, count(*),",
            "select Templates.Template_Type_Code, count(*), http://www.Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, count(*), Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter all template type ids and the number of templates used for each., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me a list of the codes for which template types described with \"Presentation.\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SQL-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me a list of the codes for which template types described with \"Presentation.\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t0.c0",
        "label": "select t1.c0",
        "score": false,
        "real_pred": "select Ref_Template_Types.Template_Type_Code",
        "real_label": "select Templates.Template_ID",
        "topk_preds": [
            "select Ref_Template_Types.Template_Type_Code",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, t0.c2",
            "select t0.c, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, Ref_Template_Types.Template_Type_Code",
            "select Ref_Template_Types.Template_Type_Code - Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me a list of the codes for which template types described with \"Presentation.\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "Ref_Template_Types",
        "real_label": "Ref_Template_Types Templates",
        "topk_preds": [
            "Ref_Template_Types",
            "",
            "",
            "",
            "Ref_Template_Types Templates",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you give me back the type ids of the template which has a description \"Book\"?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Book)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you give me back the type ids of the template which has a description \"Book\"?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Book)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t0.c0",
        "score": false,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Ref_Template_Types.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_ID",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Templates.Version_Number",
            "select Templates.Template_Details, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you give me back the type ids of the template which has a description \"Book\"?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Book)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0 t1",
        "label": "t0",
        "score": false,
        "real_pred": "Ref_Template_Types Templates",
        "real_label": "Ref_Template_Types",
        "topk_preds": [
            "Ref_Template_Types Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please return the type ids of the template type, which has the description Book'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Book)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SQL-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SQL-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please return the type ids of the template type, which has the description Book'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Book)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t0.c0",
        "score": false,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Ref_Template_Types.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Ref_Template_Types.Template_Type_Code",
            "select Templates.Template_ID",
            "select Templates.Template_Type_Code, Templates.Version_Number",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Templates.Template_Type_Code, Templates.Template_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please return the type ids of the template type, which has the description Book'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Book)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0 t1",
        "label": "t0",
        "score": false,
        "real_pred": "Ref_Template_Types Templates",
        "real_label": "Ref_Template_Types",
        "topk_preds": [
            "Ref_Template_Types Templates",
            "Ref_Template_Types",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like you to send me the document ID, Template ID, and description for the Robbin CV document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT.C0, SELECT-C1, SELECT-FROM-WHERE",
            "SELECT.C0, SELECT.C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT.C0, SELECT.C1, SELECT.C3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like you to send me the document ID, Template ID, and description for the Robbin CV document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c1, t2.c3",
        "label": "select t2.c0, t2.c1, t2.c3",
        "score": true,
        "real_pred": "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
        "real_label": "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID.c1, Documents.Document_Description",
            "select t2, Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID-, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID & Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description.",
            "select Documents.Document_ID, Documents.Template_ID, and Documents.Document_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like you to send me the document ID, Template ID, and description for the Robbin CV document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Could you show me one of your document ID, Template ID as well as the Description of a document you created called 'Robbin CV'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Could you show me one of your document ID, Template ID as well as the Description of a document you created called 'Robbin CV'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c1, t2.c3",
        "label": "select t2.c0, t2.c1, t2.c3",
        "score": true,
        "real_pred": "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
        "real_label": "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID as well as Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID & Documents.Document_Description",
            "select t2, Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID-, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description.",
            "select Documents.Document_ID, Documents.Template_ID as well Documents.Document_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Could you show me one of your document ID, Template ID as well as the Description of a document you created called 'Robbin CV'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the document ID, template ID, and the description of the document that has the title 'Robbin CV'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT.C0, SELECT.C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT.C0, SELECT-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT.C0, SELECT.C1, t2.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the document ID, template ID, and the description of the document that has the title 'Robbin CV'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t2.c0, t2.c1, t2.c3",
        "label": "select t2.c0, t2.c1, t2.c3",
        "score": true,
        "real_pred": "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
        "real_label": "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
        "topk_preds": [
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID.c1, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID & Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Name",
            "select Documents.Document_ID-, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description",
            "select Documents.Document_ID, Documents.Template_ID, Documents.Document_Description."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the document ID, template ID, and the description of the document that has the title 'Robbin CV'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Robbin CV), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Documents",
        "real_label": "Documents",
        "topk_preds": [
            "Documents",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want to see the IDs, versions, and type ids for each template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM, t1.c0, t1.c1, t1.c2",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM",
            "SELECT-FROM-VARIATION-UNION-SELECT-FROM",
            "SELECT-FROM, t1.c0, t1.c1, t1.c2"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want to see the IDs, versions, and type ids for each template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c0, t1.c1, t1.c2",
        "label": "select t1.c0, t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Version_Number.c1, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Template_ID, t1.c 1, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select t1.co, Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Version_Number), Templates.Template_Type_Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want to see the IDs, versions, and type ids for each template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the ids, versions, and type codes of all templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT.C0, SELECT.C1, SELECT-FROM",
            "SELECT.C0, t1.c1, t1.c2",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT.C0, SELECT.C1, SELECT.C2",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT.C0, SELECT-C1, SELECT-C2",
            "SELECT-FROM SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the ids, versions, and type codes of all templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c0, t1.c1, t1.c2",
        "label": "select t1.c0, t1.c1, t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code",
        "real_label": "select Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Version_Number.c1, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code, Templates.Version_Number",
            "select Templates.Template_ID, t1.c 1, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Version_Number), Templates.Template_Type_Code",
            "select t1.co, Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Template_Type_Code, Templates.Date_Effective_From"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the ids, versions, and type codes of all templates., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids of templates with the tag (PP)or (PPT)?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT, PP), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT, PP), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-UNION/SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids of templates with the tag (PP)or (PPT)?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT, PP), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT, PP), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c0",
        "label": "select t1.c0",
        "score": true,
        "real_pred": "select Templates.Template_ID",
        "real_label": "select Templates.Template_ID",
        "topk_preds": [
            "select Templates.Template_ID",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Templates.Template_ID, Templates.Date_Effective_From",
            "select Templates.Template_ID, Templates.Template_Details",
            "select Templates.Template_ID, Templates.Version_Number",
            "select Templates.Template_ID, t1.c6",
            "select Templates.Template_ID, t1.c7",
            "select Templates.Template_ID, Templates.Date_Effective_To"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids of templates with the tag (PP)or (PPT)?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT, PP), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT, PP), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "Ref_Template_Types Templates",
            "",
            "",
            "Templates Documents Paragraphs",
            "Templates Documents"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I am looking for templates with template type ID PP or PPT, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT, PP), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT, PP), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I am looking for templates with template type ID PP or PPT, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT, PP), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT, PP), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c5",
        "label": "select t1.c0",
        "score": false,
        "real_pred": "select Templates.Template_Details",
        "real_label": "select Templates.Template_ID",
        "topk_preds": [
            "select Templates.Template_Details",
            "select Templates.Version_Number",
            "select Templates.Template_ID",
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_Details, t1.c6",
            "select Templates.Template_ID, Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Details",
            "select Templates.Date_Effective_To"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I am looking for templates with template type ID PP or PPT, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (PPT, PP), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (PPT, PP), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For template CV code, how many templates are there?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-VARIATION-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE -GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For template CV code, how many templates are there?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2, count(*)",
        "label": "select count(*)",
        "score": false,
        "real_pred": "select Templates.Template_Type_Code, count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select Templates.Template_Type_Code, count(*)",
            "select Templates.Version_Number, count(*)",
            "select count(*), Templates.Template_Type_Code",
            "select Templates.Template_ID, count(*)",
            "select Templates.Date_Effective_To, count(*)",
            "select Templates.Template_Details, count(*)",
            "select Templates.Date_Effective_From, count(*)",
            "select t1.c count(*), Templates.Template_Type_Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For template CV code, how many templates are there?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the amount of templates tagged with 'CV' below., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the amount of templates tagged with 'CV' below., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Templates.Template_Type_Code",
            "select count(*), Templates.Template_ID",
            "select count(*), Templates.Version_Number",
            "select count(*), Templates.Template_Details",
            "select count(*), Templates.Date_Effective_To",
            "select count(*),",
            "select count(*), Templates.Date_Effective_From"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the amount of templates tagged with 'CV' below., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (CV), c1: template_type_description (CV)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (CV), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of all the template types, which one had a higher number of documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of all the template types, which one had a higher number of documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Templates.Version_Number",
            "select Templates.Template_Type_Code, Documents.Document_ID",
            "select Templates.Template_Type_Code (Documents.Template_ID)",
            "select Documents.Document_Name",
            "select Templates.Template_Type_Code(Documents.Template_ID)",
            "select Templates.Template_Type_Code.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of all the template types, which one had a higher number of documents?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "Templates Documents",
        "real_label": "Templates",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the lowest version number as well as its corresponding model type code?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the lowest version number as well as its corresponding model type code?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select min(t1.c1), min(t1.c2)",
        "label": "select min(t1.c1), t1.c2",
        "score": false,
        "real_pred": "select min(Templates.Version_Number), min(Templates.Template_Type_Code)",
        "real_label": "select min(Templates.Version_Number), Templates.Template_Type_Code",
        "topk_preds": [
            "select min(Templates.Version_Number), min(Templates.Template_Type_Code)",
            "select min(Templates.Version_Number), Templates.Template_Type_Code",
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select min(Templates.Version_Number)., min(Templates.Template_Type_Code)",
            "select max(Templates.Version_Number), min(Templates.Template_Type_Code)",
            "select min(Templates.Template_Type_Code), min(Templates.Version_Number)",
            "select max(Templates.Version_Number), Templates.Template_Type_Code",
            "select minimum(Templates.Version_Number), Templates.Template_Type_Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the lowest version number as well as its corresponding model type code?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Templates",
        "real_label": "Templates",
        "topk_preds": [
            "Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which template type is being used by the file named \"data base\"?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Data base), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which template type is being used by the file named \"data base\"?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Data base), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_ID",
            "select Ref_Template_Types.Template_Type_Code",
            "select Ref_Template_Types.Template_Type_Description",
            "select distinct Templates.Template_Type_Code",
            "select Templates.Version_Number",
            "select t0.c2",
            "select Templates.Template_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which template type is being used by the file named \"data base\"?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Data base), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The template type for the file named \"Data Base\" is..., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Data base), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The template type for the file named \"Data Base\" is..., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Data base), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_ID",
            "select Templates.Version_Number",
            "select Ref_Template_Types.Template_Type_Code",
            "select Ref_Template_Types.Template_Type_Description",
            "select Templates.Template_Details",
            "select t0.c2",
            "select Templates.Date_Effective_From"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The template type for the file named \"Data Base\" is..., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Data base), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the model type of the template associated with data base file?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Data base), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the model type of the template associated with data base file?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Data base), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_ID",
            "select Documents.Document_Name",
            "select Templates.Version_Number",
            "select Ref_Template_Types.Template_Type_Code",
            "select Templates.Template_Details",
            "select Ref_Template_Types.Template_Type_Description",
            "select Templates.Date_Effective_From"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the model type of the template associated with data base file?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Data base), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all template types and the number of files that use each type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY, count(*)",
            "SELECT-FROM-GROUP BY (t1.c2)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY ",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all template types and the number of files that use each type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2, count(*)",
        "label": "select t1.c2, count(*)",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code, count(*)",
        "real_label": "select Templates.Template_Type_Code, count(*)",
        "topk_preds": [
            "select Templates.Template_Type_Code, count(*)",
            "select Templates.Template_Type_Code, count(Documents.Template_ID)",
            "select Templates.Template_Type_Code, count(*), Documents.Template_ID",
            "select Templates.Template_Type_Code, count(*), Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, count(**)",
            "select Templates.Template_Type_Code, count(Documents.Document_ID)",
            "select Templates.Template_Type_Code, count(*), Templates.Template_Details",
            "select Templates.Template_Type_Code.c2, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all template types and the number of files that use each type., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "",
            "",
            "",
            "",
            "Ref_Template_Types Templates Documents",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Display the template type ids for the templates which aren't currently being used by documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-NOT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-NO-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Display the template type ids for the templates which aren't currently being used by documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Template_ID",
            "select Templates.Template_Type_Code, Templates.Date_Effective_To",
            "select Templates.Template_Type_Code, Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Display the template type ids for the templates which aren't currently being used by documents., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Templates",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you provide codes for template categories which have no documents associated with them?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-ELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you provide codes for template categories which have no documents associated with them?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_Type_Code",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Date_Effective_From",
            "select Templates.Template_Type_Code, Documents.Document_Description",
            "select Templates.Version_Number, Templates.Template_Type_Code",
            "select Templates.Template_Type_Code, Templates.Template_Details",
            "select Templates.Template_Type_Code, Documents.Template_ID",
            "select Templates.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, Templates.Template_Type_Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you provide codes for template categories which have no documents associated with them?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "Templates Documents",
        "real_label": "Templates Documents",
        "topk_preds": [
            "Templates Documents",
            "Ref_Template_Types Templates Documents",
            "Templates",
            "",
            "Ref_Template_Types Templates",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please provide the type numbers and their accompanying descriptions for all of the listed template types., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please provide the type numbers and their accompanying descriptions for all of the listed template types., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "real_label": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "topk_preds": [
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, Ref_Template_Types.Template_Type_Code",
            "select Documents.Document_Name, Ref_Template_Types.Template_Type_Description",
            "select t0.c2, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description,",
            "select Templates.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select t 0.c0, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please provide the type numbers and their accompanying descriptions for all of the listed template types., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Ref_Template_Types",
        "real_label": "Ref_Template_Types",
        "topk_preds": [
            "Ref_Template_Types",
            "",
            "",
            "",
            "",
            "",
            "",
            "Ref_Template_Types Templates"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For every template type that you have, state their type numbers and definitions here., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM Liste(*), SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM TEXT-UNION-SELECT-FROM",
            "SELECT-FROM Liste(*) SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For every template type that you have, state their type numbers and definitions here., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "real_label": "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
        "topk_preds": [
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, Ref_Template_Types.Template_Type_Code",
            "select Documents.Document_Name, Ref_Template_Types.Template_Type_Description",
            "select Templates.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select t0.c2, Ref_Template_Types.Template_Type_Description",
            "select Paragraphs.Paragraph_ID, Ref_Template_Types.Template_Type_Description",
            "select t4.c0, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, t0.c2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For every template type that you have, state their type numbers and definitions here., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0 t1",
        "label": "t0",
        "score": false,
        "real_pred": "Ref_Template_Types Templates",
        "real_label": "Ref_Template_Types",
        "topk_preds": [
            "Ref_Template_Types Templates",
            "Ref_Template_Types",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What template type descriptor is for template type code AD?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (AD), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (AD), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What template type descriptor is for template type code AD?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (AD), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (AD), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select Ref_Template_Types.Template_Type_Description",
        "real_label": "select Ref_Template_Types.Template_Type_Description",
        "topk_preds": [
            "select Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Description, t0.c2",
            "select Ref_Template_Types.Template_Type_Description, Ref_Template_Types.Template_Type_Code",
            "select Ref_Template_Types.Template_Type_Description, t0.c3",
            "select Ref_Template_Types.Template_Type_Description, t0.c4",
            "select Ref_Template_Types.Template_Type_Description, t0.c5",
            "select Ref_Template_Types.Template_Type_Description, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What template type descriptor is for template type code AD?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code (AD), c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code (AD), c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Ref_Template_Types",
        "real_label": "Ref_Template_Types",
        "topk_preds": [
            "Ref_Template_Types",
            "",
            "",
            "",
            "Ref_Template_Types Templates",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the template type code for the template type described as \"Book\" here., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Book)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the template type code for the template type described as \"Book\" here., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Book)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t0.c0",
        "label": "select t0.c0",
        "score": true,
        "real_pred": "select Ref_Template_Types.Template_Type_Code",
        "real_label": "select Ref_Template_Types.Template_Type_Code",
        "topk_preds": [
            "select Ref_Template_Types.Template_Type_Code",
            "select t0.c, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description",
            "select Ref_Template_Types.Template_Type_Code (symbol Ref_Template_Types.Template_Type_Description)",
            "select Ref_Template_Types.Template_Type_Code (symbol Ref_Template_Types.Template_Type_Code)",
            "select Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description, Templates.Template_Type_Code",
            "select Ref_Template_Types.Template_Type_Description",
            "select t0.c, Templates.Template_Type_Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the template type code for the template type described as \"Book\" here., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Book)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Ref_Template_Types",
        "real_label": "Ref_Template_Types",
        "topk_preds": [
            "Ref_Template_Types",
            "Ref_Template_Types Templates",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need to find the template IDs which describe Presentations., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need to find the template IDs which describe Presentations., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c0",
        "label": "select t1.c0",
        "score": true,
        "real_pred": "select Templates.Template_ID",
        "real_label": "select Templates.Template_ID",
        "topk_preds": [
            "select Templates.Template_ID",
            "select Templates.Template_ID, Ref_Template_Types.Template_Type_Description",
            "select Templates.Template_ID, t0.c2",
            "select Templates.Template_ID, Ref_Template_Types.Template_Type_Code",
            "select Templates.Template_ID - Ref_Template_Types.Template_Type_Description",
            "select Templates.Template_ID, t0.c3",
            "select Templates.Template_ID, t0.c5",
            "select Templates.Version_Number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need to find the template IDs which describe Presentations., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Ref_Template_Types Templates",
        "real_label": "Ref_Template_Types Templates",
        "topk_preds": [
            "Ref_Template_Types Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each presentation template that has a name of 'Presentation', return the code assigned to it., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each presentation template that has a name of 'Presentation', return the code assigned to it., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c0",
        "score": false,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_ID",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_ID",
            "select Templates.Version_Number",
            "select Templates.Date_Effective_From",
            "select Templates.Template_ID2",
            "select Templates.Template_Details",
            "select Templates.Template_Type_Code0",
            "select Templates.Template_Type_Code-"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each presentation template that has a name of 'Presentation', return the code assigned to it., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Ref_Template_Types Templates",
        "real_label": "Ref_Template_Types Templates",
        "topk_preds": [
            "Ref_Template_Types Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return to me the code for the Presentation Template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SQL-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return to me the code for the Presentation Template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t1.c2",
        "label": "select t1.c0",
        "score": false,
        "real_pred": "select Templates.Template_Type_Code",
        "real_label": "select Templates.Template_ID",
        "topk_preds": [
            "select Templates.Template_Type_Code",
            "select Templates.Template_Details",
            "select Documents.Document_Name",
            "select Templates.Template_ID",
            "select Templates.Date_Effective_To",
            "select Templates.Date_Effective_From",
            "select Templates.Version_Number",
            "select t1.c code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return to me the code for the Presentation Template., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description (Presentation)). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "Ref_Template_Types Templates",
        "real_label": "Ref_Template_Types Templates",
        "topk_preds": [
            "Ref_Template_Types Templates",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Could you count the number of paragraphs in the document called Summer Show?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Summer Show), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Could you count the number of paragraphs in the document called Summer Show?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Summer Show), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Documents.Document_ID",
            "select count(distinct Paragraphs.Paragraph_Text)",
            "select count(*), Documents.Document_Name",
            "select count(*), Documents.Document_Description",
            "select count(*), Documents.Template_ID",
            "select count(distinct Paragraphs.Paragraph_ID)",
            "select count(*), Documents.Other_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Could you count the number of paragraphs in the document called Summer Show?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Summer Show), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "",
            "Templates Documents Paragraphs",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me an exact count of the number of paragraphs in the document called Summer Show., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Summer Show), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me an exact count of the number of paragraphs in the document called Summer Show., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Summer Show), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Documents.Document_ID",
            "select count(*), Documents.Document_Name",
            "select count(*), Documents.Template_ID",
            "select count(*), Documents.Document_Description",
            "select count(*), Documents.Other_Details",
            "select count(*), t2.c5",
            "select count(*), Paragraphs.Document_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me an exact count of the number of paragraphs in the document called Summer Show., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Summer Show), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "Ref_Template_Types Documents Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like you to count the number of paragraphs in the document titled 'Summer Show'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Summer Show), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like you to count the number of paragraphs in the document titled 'Summer Show'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Summer Show), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Documents.Document_ID",
            "select count(*), Documents.Template_ID",
            "select count(*), Documents.Document_Description",
            "select count(*), Documents.Document_Name",
            "select count(*), Paragraphs.Document_ID",
            "select count(*), Documents.Other_Details",
            "select count(*), t2.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like you to count the number of paragraphs in the document titled 'Summer Show'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Summer Show), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "Ref_Template_Types Documents Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show the additional information for the paragraph with'Korea '., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show the additional information for the paragraph with'Korea '., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "select t3.c3",
        "label": "select t3.c3",
        "score": true,
        "real_pred": "select Paragraphs.Other_Details",
        "real_label": "select Paragraphs.Other_Details",
        "topk_preds": [
            "select Paragraphs.Other_Details",
            "select Paragraphs.Paragraph_Text, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Other_Details, Paragraphs.Paragraph_Text",
            "select Paragraphs.Other_Details, t3.c4",
            "select Paragraphs.Other_Details.c3",
            "select Paragraphs.Other_Details,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show the additional information for the paragraph with'Korea '., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need further details on the paragraph that mentions the word Korea., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need further details on the paragraph that mentions the word Korea., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "select t3.c3",
        "label": "select t3.c3",
        "score": true,
        "real_pred": "select Paragraphs.Other_Details",
        "real_label": "select Paragraphs.Other_Details",
        "topk_preds": [
            "select Paragraphs.Other_Details",
            "select Paragraphs.Paragraph_Text, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Other_Details, Paragraphs.Paragraph_Text",
            "select Paragraphs.Other_Details, t3.c4",
            "select Paragraphs.Other_Details.c3",
            "select Paragraphs.Other_Details,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need further details on the paragraph that mentions the word Korea., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please provide the details about the paragraph that contains the word Korea., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SQL-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SQL-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please provide the details about the paragraph that contains the word Korea., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "select t3.c3",
        "label": "select t3.c3",
        "score": true,
        "real_pred": "select Paragraphs.Other_Details",
        "real_label": "select Paragraphs.Other_Details",
        "topk_preds": [
            "select Paragraphs.Other_Details",
            "select Paragraphs.Paragraph_Text, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Other_Details, Paragraphs.Paragraph_Text",
            "select Paragraphs.Other_Details, t3.c4",
            "select Paragraphs.Other_Details.c3",
            "select Paragraphs.Other_Details,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please provide the details about the paragraph that contains the word Korea., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the paragraph that has the word Korea in it?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the paragraph that has the word Korea in it?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "select t3.c0",
        "label": "select t3.c3",
        "score": false,
        "real_pred": "select Paragraphs.Paragraph_ID",
        "real_label": "select Paragraphs.Other_Details",
        "topk_preds": [
            "select Paragraphs.Paragraph_ID",
            "select Paragraphs.Document_ID",
            "select Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Other_Details",
            "select Paragraphs.Paragraph_ID, Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the paragraph that has the word Korea in it?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "",
            "",
            "",
            "",
            "Documents Paragraphs",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to get more information on the paragraph that contains the word 'Korea'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to get more information on the paragraph that contains the word 'Korea'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "select t3.c3",
        "label": "select t3.c3",
        "score": true,
        "real_pred": "select Paragraphs.Other_Details",
        "real_label": "select Paragraphs.Other_Details",
        "topk_preds": [
            "select Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Other_Details",
            "select Paragraphs.Other_Details, Paragraphs.Paragraph_Text",
            "select Paragraphs.Other_Details, t3.c4",
            "select t3.c4",
            "select Paragraphs.Paragraph_Text"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to get more information on the paragraph that contains the word 'Korea'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the detail for the passage that mentions Korea below., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the detail for the passage that mentions Korea below., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "select t3.c3",
        "label": "select t3.c3",
        "score": true,
        "real_pred": "select Paragraphs.Other_Details",
        "real_label": "select Paragraphs.Other_Details",
        "topk_preds": [
            "select Paragraphs.Other_Details",
            "select Paragraphs.Paragraph_Text, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Other_Details, Paragraphs.Paragraph_Text",
            "select Paragraphs.Other_Details,",
            "select Paragraphs.Other_Details, t3.c4",
            "select Paragraphs.Document_ID, t3.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the detail for the passage that mentions Korea below., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Korea), c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show me all the paragraphs that are in the document \"Customer Reviews\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show me all the paragraphs that are in the document \"Customer Reviews\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Paragraphs.Paragraph_Text",
        "real_label": "select Paragraphs.Paragraph_Text",
        "topk_preds": [
            "select Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Document_ID",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_ID",
            "select Paragraphs.Paragraph_Text, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, t3.c4",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Documents.Document_Description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show me all the paragraphs that are in the document \"Customer Reviews\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "Ref_Template_Types Documents Paragraphs",
            "",
            "",
            "Templates Documents Paragraphs",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the paragraphs with the phrase \"customer reviews\" as title., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the paragraphs with the phrase \"customer reviews\" as title., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Paragraphs.Paragraph_Text",
        "real_label": "select Paragraphs.Paragraph_Text",
        "topk_preds": [
            "select Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID",
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Document_ID",
            "select Paragraphs.Paragraph_ID",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the paragraphs with the phrase \"customer reviews\" as title., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "Templates Documents Paragraphs",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list all paragraphs of the \"Customer Reviews\" document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list all paragraphs of the \"Customer Reviews\" document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Paragraphs.Paragraph_Text",
        "real_label": "select Paragraphs.Paragraph_Text",
        "topk_preds": [
            "select Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Other_Details",
            "select Paragraphs.Paragraph_Text, Paragraphs.Document_ID",
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_ID",
            "select Paragraphs.Paragraph_Text, t3.c4",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_Text"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list all paragraphs of the \"Customer Reviews\" document., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "",
            "Templates Documents Paragraphs",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all paragraphs from the document \"Customer Reviews\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all paragraphs from the document \"Customer Reviews\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "select t3.c2",
        "label": "select t3.c2",
        "score": true,
        "real_pred": "select Paragraphs.Paragraph_Text",
        "real_label": "select Paragraphs.Paragraph_Text",
        "topk_preds": [
            "select Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_Text, Paragraphs.Paragraph_ID",
            "select Paragraphs.Paragraph_Text, Paragraphs.Other_Details",
            "select Paragraphs.Paragraph_Text, t3.c4",
            "select Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Other_Details, Paragraphs.Paragraph_Text"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all paragraphs from the document \"Customer Reviews\", database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name (Customer reviews), c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text, c3: other_details).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "Documents Paragraphs",
        "real_label": "Documents Paragraphs",
        "topk_preds": [
            "Documents Paragraphs",
            "",
            "",
            "",
            "Ref_Template_Types Documents Paragraphs",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Below, you can find the ids of documents contain the content 'Brazil' and Ireland'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Ireland, Brazil), c3: other_details).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-2-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE'-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE AND-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE&INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Below, you can find the ids of documents contain the content 'Brazil' and Ireland'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Ireland, Brazil), c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Paragraph_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_ID",
            "select Paragraphs.Document_ID, Documents.Document_ID",
            "select Paragraphs.Document_ID, t3.c4",
            "select Paragraphs.Document_ID - Paragraphs.Paragraph_Text"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Below, you can find the ids of documents contain the content 'Brazil' and Ireland'., database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Ireland, Brazil), c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "Documents Paragraphs",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's document IDs contain the paragraph containing the sentences Brazil and Ireland?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Ireland, Brazil), c3: other_details).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE&INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's document IDs contain the paragraph containing the sentences Brazil and Ireland?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Ireland, Brazil), c3: other_details).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Paragraphs.Document_ID",
        "real_label": "select Paragraphs.Document_ID",
        "topk_preds": [
            "select Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_Text",
            "select Paragraphs.Paragraph_ID",
            "select Paragraphs.Paragraph_ID, Paragraphs.Document_ID",
            "select Paragraphs.Document_ID, Paragraphs.Paragraph_ID",
            "select Paragraphs.Document_ID, Paragraphs.Other_Details",
            "select Paragraphs.Document_ID, t3.c4",
            "select Paragraphs.Document_ID, t3.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's document IDs contain the paragraph containing the sentences Brazil and Ireland?, database: Database: cre_Doc_Template_Mgt. t0: ref_template_types(c0: template_type_code, c1: template_type_description). t1: templates(c0: template_id, c1: version_number, c2: template_type_code, c3: date_effective_from, c4: date_effective_to, c5: template_details). t2: documents(c0: document_id, c1: template_id, c2: document_name, c3: document_description, c4: other_details). t3: paragraphs(c0: paragraph_id, c1: document_id, c2: paragraph_text (Ireland, Brazil), c3: other_details).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "Paragraphs",
        "real_label": "Paragraphs",
        "topk_preds": [
            "Paragraphs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the ages and origins of every instructor listed., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY LUNCHT1.c2, t1.c3",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY LUNCHT1.C2, t1.c3",
            "SELECT-FROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the ages and origins of every instructor listed., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select teacher.Age, teacher.Hometown",
        "real_label": "select teacher.Age, teacher.Hometown",
        "topk_preds": [
            "select teacher.Age, teacher.Hometown",
            "select teacher.Hometown, teacher.Age",
            "select distinct teacher.Age, teacher.Hometown",
            "select teacher.Age, teacher.Hometown, teacher.Teacher_ID",
            "select teacher.Age, teacher.Hometown,",
            "select teacher.Age, teacher.Hometown,",
            "select teacher.Age), teacher.Hometown",
            "select teacher.Age, teacher.Hometown, t1.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the ages and origins of every instructor listed., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I'd like to know each teacher's age along with his or her birthplace., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I'd like to know each teacher's age along with his or her birthplace., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c2, t1.c3",
        "label": "select t1.c2, t1.c3",
        "score": true,
        "real_pred": "select teacher.Age, teacher.Hometown",
        "real_label": "select teacher.Age, teacher.Hometown",
        "topk_preds": [
            "select teacher.Age, teacher.Hometown",
            "select teacher.Teacher_ID, teacher.Age, teacher.Hometown",
            "select teacher.Hometown, teacher.Age",
            "select teacher.Name, teacher.Age, teacher.Hometown",
            "select teacher.Age, teacher.Hometown,",
            "select teacher.Age, teacher.Hometown, teacher.Teacher_ID",
            "select teacher.Age, teacher.Hometown.",
            "select teacher.Age), teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I'd like to know each teacher's age along with his or her birthplace., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each city, how many teachers are from there?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY, count(*)",
            "SELECT-FROM-GROUP BY TI1.c3, count(*)",
            "SELECT-FROM-GROUP BY TI1.C3, count(*)",
            "SELECT-FROM-GROUP BY t1.c3, count(*)",
            "SELECT-FROM-GROUP BY -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each city, how many teachers are from there?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3, count(*)",
        "label": "select t1.c3, count(*)",
        "score": true,
        "real_pred": "select teacher.Hometown, count(*)",
        "real_label": "select teacher.Hometown, count(*)",
        "topk_preds": [
            "select teacher.Hometown, count(*)",
            "select teacher.Hometown, count(*)",
            "select teacher.Hometown, count(*), teacher.Teacher_ID",
            "select teacher.Hometown.c3, count(*)",
            "select count(*), teacher.Hometown",
            "select teacher.Hometown, count(*),",
            "select teacher.Hometown, count(*), t1.c4",
            "select teacher.Hometown, counts(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each city, how many teachers are from there?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For every town, how many teachers are from there?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY, count(*)",
            "SELECT-FROM-GROUP BY TI1.c3, count(*)",
            "SELECT-FROM-GROUP BY TI1.C3, count(*)",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For every town, how many teachers are from there?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3, count(*)",
        "label": "select t1.c3, count(*)",
        "score": true,
        "real_pred": "select teacher.Hometown, count(*)",
        "real_label": "select teacher.Hometown, count(*)",
        "topk_preds": [
            "select teacher.Hometown, count(*)",
            "select teacher.Hometown, count(*)",
            "select teacher.Hometown, count(*), teacher.Teacher_ID",
            "select count(*), teacher.Hometown",
            "select teacher.Hometown.c3, count(*)",
            "select teacher.Hometown, count(*),",
            "select t1, teacher.Hometown, count(*)",
            "select teacher.Hometown, count(*), t1.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For every town, how many teachers are from there?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show the names of the teachers and their classes they will be teaching., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM the SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM -ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show the names of the teachers and their classes they will be teaching., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t0.c2",
        "label": "select t1.c1, t0.c2",
        "score": true,
        "real_pred": "select teacher.Name, course.Course",
        "real_label": "select teacher.Name, course.Course",
        "topk_preds": [
            "select teacher.Name, course.Course",
            "select course_arrange.Teacher_ID, course.Course",
            "select teacher.Name, course.Course, course_arrange.Teacher_ID",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, course.Course,",
            "select teacher.Name, course.Course, course_arrange.Course_ID",
            "select distinct teacher.Name, course.Course",
            "select teacher.Name, course.Course, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show the names of the teachers and their classes they will be teaching., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the names of the teachers and their teaching subjects below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the names of the teachers and their teaching subjects below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t2.c2",
        "label": "select t1.c1, t0.c2",
        "score": false,
        "real_pred": "select teacher.Name, course_arrange.Grade",
        "real_label": "select teacher.Name, course.Course",
        "topk_preds": [
            "select teacher.Name, course_arrange.Grade",
            "select teacher.Name, course.Course",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, t3.c2",
            "select teacher.Name, t2.c3",
            "select teacher.Name, t02.c2",
            "select teacher.Name, t4.c2",
            "select teacher.Name, t0.c3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the names of the teachers and their teaching subjects below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "teacher course_arrange",
            "",
            "course teacher",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all of the teacher's information such as their name and what classes they are teaching., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM each SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all of the teacher's information such as their name and what classes they are teaching., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t0.c2",
        "label": "select t1.c1, t0.c2",
        "score": true,
        "real_pred": "select teacher.Name, course.Course",
        "real_label": "select teacher.Name, course.Course",
        "topk_preds": [
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Course, teacher.Hometown",
            "select distinct teacher.Name, course.Course",
            "select course_arrange.Teacher_ID, teacher.Name, course.Course",
            "select teacher.Name, course.Course, course_arrange.Teacher_ID",
            "select teacher.Name, course.Course, t0.c3",
            "select teacher.Name, course.Course, teacher.Teacher_ID",
            "select course_arrange.Teacher_ID, teacher.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all of the teacher's information such as their name and what classes they are teaching., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter teachers who are not born in Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter teachers who are not born in Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c0",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select teacher.Teacher_ID",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Teacher_ID",
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age",
            "select teacher.Teacher_ID, teacher.Name",
            "select teacher.Name, teacher.Hometown,",
            "select teacher.Name, teacher.Teacher_ID3",
            "select teacher.Name, teacher.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter teachers who are not born in Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter teachers who were born outside Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter teachers who were born outside Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c0",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select teacher.Teacher_ID",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Teacher_ID",
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age",
            "select teacher.Teacher_ID, teacher.Name",
            "select teacher.Teacher_ID, teacher.Hometown",
            "select teacher.Teacher_ID, teacher.Age",
            "select teacher.Name, teacher.Hometown,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter teachers who were born outside Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter teachers who were not born in Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter teachers who were not born in Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c0",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select teacher.Teacher_ID",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Teacher_ID",
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age",
            "select teacher.Teacher_ID, teacher.Name",
            "select teacher.Teacher_ID, teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Hometown, teacher.Teacher_ID",
            "select teacher.Name, teacher.Age, teacher.Hometown"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter teachers who were not born in Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to see the names of all teachers who were not born in Little Lever Urban District., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to see the names of all teachers who were not born in Little Lever Urban District., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age",
            "select teacher.Name (or teacher.Age)",
            "select teacher.Name (not teacher.Age)",
            "select teacher.Name - teacher.Hometown",
            "select teacher.Name, teacher.Hometown,",
            "select teacher.Name (not teacher.Hometown)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to see the names of all teachers who were not born in Little Lever Urban District., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the names of the teachers whose birthplace was not Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the names of the teachers whose birthplace was not Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age",
            "select teacher.Name - teacher.Hometown",
            "select teacher.Name, teacher.Hometown,",
            "select teacher.Name (not teacher.Age)",
            "select teacher.Name (or teacher.Age)",
            "select teacher.Name - teacher.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the names of the teachers whose birthplace was not Little Lever Urban District below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which are the teachers whose place of birth is not Little Lever Urban District?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which are the teachers whose place of birth is not Little Lever Urban District?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age",
            "select teacher.Teacher_ID",
            "select teacher.Name, teacher.Name",
            "select teacher.Name, teacher.Teacher_ID3",
            "select teacher.Name, teacher.Hometown,",
            "select teacher.Name, teacher.Teacher_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which are the teachers whose place of birth is not Little Lever Urban District?, database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know who are the teachers whose birthplace was not Little Lever Urban District., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know who are the teachers whose birthplace was not Little Lever Urban District., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Age",
            "select teacher.Teacher_ID, teacher.Name",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name,",
            "select teacher.Name, t1.c6",
            "select teacher.Name (teacher.Teacher_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know who are the teachers whose birthplace was not Little Lever Urban District., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown (Little Lever Urban District)). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter the youngest teacher's city of origin below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter the youngest teacher's city of origin below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown, teacher.Age",
            "select teacher.Age, teacher.Hometown",
            "select teacher.Hometown, max(teacher.Age)",
            "select teacher.Hometown (or teacher.Age)",
            "select teacher.Hometown (teacher.Age)",
            "select min(teacher.Hometown)",
            "select teacher.Hometown, max(teacher.Hometown)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter the youngest teacher's city of origin below., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want to know which are the most common cities that some teachers come from., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want to know which are the most common cities that some teachers come from., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select teacher.Hometown",
        "real_label": "select teacher.Hometown",
        "topk_preds": [
            "select teacher.Hometown",
            "select teacher.Hometown, t1.c4",
            "select teacher.Hometown, count(*)",
            "select teacher.Hometown, teacher.Age",
            "select teacher.Hometown, teacher.Teacher_ID",
            "select teacher.Hometown, teacher.Hometown",
            "select teacher.Hometown, t1.c6",
            "select teacher.Hometown, t1.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want to know which are the most common cities that some teachers come from., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "teacher",
        "real_label": "teacher",
        "topk_preds": [
            "teacher",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show the name of the teacher taking math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show the name of the teacher taking math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Staring_Date",
            "select teacher.Name, teacher.Teacher_ID",
            "select distinct teacher.Name",
            "select teacher.Name, course.Course_ID",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, teacher.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show the name of the teacher taking math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the name of the teacher who taught the math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the name of the teacher who taught the math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, course_arrange.Grade",
            "select distinct teacher.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the name of the teacher who taught the math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name of your instructor for the Math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INSTRUCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name of your instructor for the Math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, course.Course",
            "select teacher.Name, course_arrange.Grade",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, course_arrange.Course_ID",
            "select teacher.Name, teacher.Age",
            "select teacher.Name (teacher.Teacher_ID)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name of your instructor for the Math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name of the person teaching the math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name of the person teaching the math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course.Course, teacher.Hometown",
            "select teacher.Name, course.Course, teacher.Name",
            "select teacher.Name, course.Course, teacher.Teacher_ID",
            "select teacher.Name, course.Course, teacher.Hometown",
            "select teacher.Name (select teacher.Name)",
            "select distinct teacher.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name of the person teaching the math class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please display the name of the teacher for the maths class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please display the name of the teacher for the maths class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select teacher.Name",
        "real_label": "select teacher.Name",
        "topk_preds": [
            "select teacher.Name",
            "select teacher.Name, course.Course",
            "select teacher.Name, course_arrange.Teacher_ID",
            "select teacher.Name, teacher.Age",
            "select teacher.Name, course_arrange.Grade",
            "select teacher.Name, teacher.Teacher_ID",
            "select teacher.Name, teacher.Hometown",
            "select teacher.Name, course_arrange.Course_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please display the name of the teacher for the maths class., database: Database: course_teach. t0: course(c0: course_id, c1: staring_date, c2: course (Math)). t1: teacher(c0: teacher_id, c1: name, c2: age, c3: hometown). t2: course_arrange(c0: course_id, c1: teacher_id, c2: grade) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1 t2",
        "score": true,
        "real_pred": "course teacher course_arrange",
        "real_label": "course teacher course_arrange",
        "topk_preds": [
            "course teacher course_arrange",
            "course teacher",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of people who are members but not higher than Level four, how old are they on average?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY (INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of people who are members but not higher than Level four, how old are they on average?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t1.c3)",
        "label": "select avg(t1.c3)",
        "score": true,
        "real_pred": "select avg(visitor.Age)",
        "real_label": "select avg(visitor.Age)",
        "topk_preds": [
            "select avg(visitor.Age)",
            "select an avg(visitor.Age)",
            "select  avg(visitor.Age)",
            "select Avg(visitor.Age)",
            "select age(avg(visitor.Age)",
            "select avg(visitor.Age).",
            "select \u0430vg(visitor.Age)",
            "select avg(visitor.Age),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of people who are members but not higher than Level four, how old are they on average?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the names and levels of the people who are higher than level four and then sort them from oldest to youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY",
        "label": "SELECT-FROM-WHERE-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY",
        "real_label": "SELECT-FROM-WHERE-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY.",
            "SELECT-FROM-WHERE-ORDER BY(t1.c1)",
            "SELECT-FROM-WHEREF-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY (",
            "SELECT-FROM-WHERE-ORDER BY ",
            "SELECT-FROM-WHEREORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the names and levels of the people who are higher than level four and then sort them from oldest to youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t1.c1, t1.c2",
        "label": "select t1.c1, t1.c2",
        "score": true,
        "real_pred": "select visitor.Name, visitor.Level_of_membership",
        "real_label": "select visitor.Name, visitor.Level_of_membership",
        "topk_preds": [
            "select visitor.Name, visitor.Level_of_membership",
            "select visitor.Name, visitor.Level_of_membership, visitor.Age",
            "select visitor.Name, t1.c4",
            "select visitor.Name, visitor.Age",
            "select visitor.Name, visitor.Level_of_membership and then sort them from oldest to youngest",
            "select visitor.Name, visitor.Level_of_membership, order(visitor.Age)",
            "select visitor.Name, visitor.Level_of_membership sort(visitor.Age)",
            "select visitor.Name, visitor.Level_of_membership sort order(visitor.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the names and levels of the people who are higher than level four and then sort them from oldest to youngest., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "visitor",
        "real_label": "visitor",
        "topk_preds": [
            "visitor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the ID and name of the museum that has the highest number of employees?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the ID and name of the museum that has the highest number of employees?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select museum.Museum_ID, museum.Name",
        "real_label": "select museum.Museum_ID, museum.Name",
        "topk_preds": [
            "select museum.Museum_ID, museum.Name",
            "select museum.Name, museum.Museum_ID",
            "select museum.Museum_ID, museum.Name, museum.Num_of_Staff",
            "select museum.Num_of_Staff, museum.Name",
            "select museum.Museum_ID, museum.Name, museum.Open_Year",
            "select museum.Museum_ID, museum.Name (ORDER BY-LIMIT)",
            "select museum.Museum_ID1, museum.Name",
            "select museum.Museum_ID, museum.Name (or museum.Num_of_Staff)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the ID and name of the museum that has the highest number of employees?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: please find the average number of employees which had been employed in the museums opened before 2009, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AVERAGE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: please find the average number of employees which had been employed in the museums opened before 2009, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t0.c2)",
        "label": "select avg(t0.c2)",
        "score": true,
        "real_pred": "select avg(museum.Num_of_Staff)",
        "real_label": "select avg(museum.Num_of_Staff)",
        "topk_preds": [
            "select avg(museum.Num_of_Staff)",
            "select avg(t0.c4)",
            "select an avg(museum.Num_of_Staff)",
            "select  avg(museum.Num_of_Staff)",
            "select avg(museum.Open_Year)",
            "select avg(t0.c6)",
            "select avg(museum.Num_of_Staff).",
            "select avg(t0.c5)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: please find the average number of employees which had been employed in the museums opened before 2009, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The average number of employees working at the museums being built before 2009 should be mentioned., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The average number of employees working at the museums being built before 2009 should be mentioned., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t0.c2)",
        "label": "select avg(t0.c2)",
        "score": true,
        "real_pred": "select avg(museum.Num_of_Staff)",
        "real_label": "select avg(museum.Num_of_Staff)",
        "topk_preds": [
            "select avg(museum.Num_of_Staff)",
            "select avg(t0.c4)",
            "select an avg(museum.Num_of_Staff)",
            "select avg(museum.Open_Year)",
            "select  avg(museum.Num_of_Staff)",
            "select avg(t0.c5)",
            "select avg(t0.c6)",
            "select avg(museum.Num_of_Staff)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The average number of employees working at the museums being built before 2009 should be mentioned., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the year when the building now known as Plaza Museum opened and how many staff it had?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name (Plaza Museum), c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (T0.c3), SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (T0.c3), SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (T0.c3), SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the year when the building now known as Plaza Museum opened and how many staff it had?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name (Plaza Museum), c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c3, t0.c2",
        "label": "select t0.c2, t0.c3",
        "score": false,
        "real_pred": "select museum.Open_Year, museum.Num_of_Staff",
        "real_label": "select museum.Num_of_Staff, museum.Open_Year",
        "topk_preds": [
            "select museum.Open_Year, museum.Num_of_Staff",
            "select museum.Name, museum.Num_of_Staff",
            "select museum.Name, museum.Open_Year, museum.Num_of_Staff",
            "select museum.Museum_ID, museum.Open_Year, museum.Num_of_Staff",
            "select museum.Museum_ID, museum.Open_Year",
            "select museum.Num_of_Staff, museum.Open_Year",
            "select museum.Museum_ID, museum.Num_of_Staff",
            "select museum.Name, museum.Open_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the year when the building now known as Plaza Museum opened and how many staff it had?, database: Database: museum_visit. t0: museum(c0: museum_id, c1: name (Plaza Museum), c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please fill in the names of museums that had more staff than the amount for all museums established after 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please fill in the names of museums that had more staff than the amount for all museums established after 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select museum.Name",
        "real_label": "select museum.Name",
        "topk_preds": [
            "select museum.Name",
            "select museum.Name, museum.Num_of_Staff",
            "select museum.Name, museum.Num_of_Staff, museum.Open_Year",
            "select museum.Name, museum.Open_Year",
            "select museum.Museum_ID, museum.Name",
            "select museum.Name, museum.Num_of_Staff, museum.Open_Year",
            "select museum.Name (instead of museum.Num_of_Staff)",
            "select museum.Name (or museum.Num_of_Staff)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please fill in the names of museums that had more staff than the amount for all museums established after 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the list of museums with more staff members than the minimum amount of staff members for all museums opened after 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the list of museums with more staff members than the minimum amount of staff members for all museums opened after 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select museum.Name",
        "real_label": "select museum.Name",
        "topk_preds": [
            "select museum.Name",
            "select museum.Name, museum.Num_of_Staff",
            "select museum.Museum_ID, museum.Name",
            "select museum.Museum_ID, museum.Name, museum.Num_of_Staff",
            "select museum.Name, museum.Num_of_Staff, museum.Open_Year",
            "select museum.Name, museum.Open_Year",
            "select museum.Museum_ID, museum.Num_of_Staff",
            "select museum.Name, museum.Num_of_Staff, museum.Open_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the list of museums with more staff members than the minimum amount of staff members for all museums opened after 2010., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "museum",
        "real_label": "museum",
        "topk_preds": [
            "museum",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please calculate the averages and maximums about num of ticket sold., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM AVG(t2.c2), max(t2.c2)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM AVG(t2.c2), MAX(t2.c2)",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please calculate the averages and maximums about num of ticket sold., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select avg(t2.c2), max(t2.c2)",
        "label": "select avg(t2.c2), max(t2.c2)",
        "score": true,
        "real_pred": "select avg(visit.Num_of_Ticket), max(visit.Num_of_Ticket)",
        "real_label": "select avg(visit.Num_of_Ticket), max(visit.Num_of_Ticket)",
        "topk_preds": [
            "select avg(visit.Num_of_Ticket), max(visit.Num_of_Ticket)",
            "select avg(t2.c8), max(visit.Num_of_Ticket)",
            "select avg(t2.c6), max(visit.Num_of_Ticket)",
            "select avg(t2.c5), max(visit.Num_of_Ticket)",
            "select avg(t2.c4), max(visit.Num_of_Ticket)",
            "select max(visit.Num_of_Ticket), avg(visit.Num_of_Ticket)",
            "select avg(visit.Num_of_Ticket)., max(visit.Num_of_Ticket)",
            "select avg(t2.c4), max(t2.c4)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please calculate the averages and maximums about num of ticket sold., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "visit",
        "real_label": "visit",
        "topk_preds": [
            "visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find out the total amount of money that was spent on tickets for member level 1., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find out the total amount of money that was spent on tickets for member level 1., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select sum(t2.c3)",
        "label": "select sum(t2.c3)",
        "score": true,
        "real_pred": "select sum(visit.Total_spent)",
        "real_label": "select sum(visit.Total_spent)",
        "topk_preds": [
            "select sum(visit.Total_spent)",
            "select sum(visit.Total_spent), visitor.ID",
            "select sum(visit.Total_spent), visitor.Level_of_membership",
            "select sum(visit.Total_spent) dependant on visitor.Level_of_membership",
            "select sum(visit.Total_spent) descripted in visitor.Name",
            "select sum(visit.Total_spent), visitor.Name",
            "select sum(visit.Total_spent) descripted in visitor.ID",
            "select sum(visit.Total_spent) descripted by visitor.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find out the total amount of money that was spent on tickets for member level 1., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The total amount of money spent on tickets for those who are at level 1 should be written here., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE ADDIT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE ADDIT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The total amount of money spent on tickets for those who are at level 1 should be written here., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select sum(t2.c3)",
        "label": "select sum(t2.c3)",
        "score": true,
        "real_pred": "select sum(visit.Total_spent)",
        "real_label": "select sum(visit.Total_spent)",
        "topk_preds": [
            "select sum(visit.Total_spent)",
            "select sum(visit.Total_spent), visitor.ID",
            "select sum(visit.Total_spent) descripted in visitor.Name",
            "select sum(visit.Total_spent) descripted by visitor.ID",
            "select sum(visit.Total_spent) denoted by visitor.ID",
            "select sum(visit.Total_spent), visitor.Name",
            "select sum(visit.Total_spent),",
            "select sum(visit.Total_spent) descripted in visitor.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The total amount of money spent on tickets for those who are at level 1 should be written here., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need to find out the total amount spent on tickets for the members of level 1., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need to find out the total amount spent on tickets for the members of level 1., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select sum(t2.c3)",
        "label": "select sum(t2.c3)",
        "score": true,
        "real_pred": "select sum(visit.Total_spent)",
        "real_label": "select sum(visit.Total_spent)",
        "topk_preds": [
            "select sum(visit.Total_spent)",
            "select sum(visit.Total_spent), visitor.ID",
            "select sum(visit.Total_spent) descripted in visitor.ID",
            "select sum(visit.Total_spent) descripted in visitor.Level_of_membership",
            "select sum(visit.Total_spent) descripted by visitor.ID",
            "select sum(visit.Total_spent)aft visitor.ID",
            "select sum(visit.Total_spent) descripted by visitor.Level_of_membership",
            "select sum(visit.Total_spent),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need to find out the total amount spent on tickets for the members of level 1., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me the total expenditure on tickets for those people whose membership level is one., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-AGGRESS-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me the total expenditure on tickets for those people whose membership level is one., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select sum(t2.c3)",
        "label": "select sum(t2.c3)",
        "score": true,
        "real_pred": "select sum(visit.Total_spent)",
        "real_label": "select sum(visit.Total_spent)",
        "topk_preds": [
            "select sum(visit.Total_spent)",
            "select sum(visit.Total_spent), visitor.ID",
            "select sum(visit.Total_spent), visitor.Name",
            "select sum(visit.Total_spent) descripted in visitor.Name",
            "select sum(visit.Total_spent)aft visitor.ID",
            "select sum(visit.Total_spent),",
            "select sum(visit.Total_spent)aft visitor.Name",
            "select sum(visit.Total_spent) descripted in visitor.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me the total expenditure on tickets for those people whose membership level is one., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The amount of money that was spent on tickets for the members who are in level one., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The amount of money that was spent on tickets for the members who are in level one., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "select sum(t2.c3)",
        "label": "select sum(t2.c3)",
        "score": true,
        "real_pred": "select sum(visit.Total_spent)",
        "real_label": "select sum(visit.Total_spent)",
        "topk_preds": [
            "select sum(visit.Total_spent)",
            "select sum(visit.Total_spent) denoted by visit.Num_of_Ticket",
            "select sum(visit.Total_spent) delegated to visit.Num_of_Ticket",
            "select sum(visit.Total_spent), visitor.ID",
            "select sum(visit.Total_spent) denoted by visitor.ID",
            "select sum(visit.Total_spent) delegated to visitor.ID",
            "select sum(visit.Total_spent),",
            "select sum(visit.Total_spent) descripted in visitor.ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The amount of money that was spent on tickets for the members who are in level one., database: Database: museum_visit. t0: museum(c0: museum_id, c1: name, c2: num_of_staff, c3: open_year). t1: visitor(c0: id, c1: name, c2: level_of_membership, c3: age). t2: visit(c0: museum_id, c1: visitor_id, c2: num_of_ticket, c3: total_spent) (c1) refers to t1(c0), (c0) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "visitor visit",
        "real_label": "visitor visit",
        "topk_preds": [
            "visitor visit",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all those that won the most times, their names and their ranking points., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t2.c2, t2.c3",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t2.c27, t2.c3",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t2.c2, t2.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all those that won the most times, their names and their ranking points., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t2.c2, t2.c27, t2.c3",
        "label": "select t1.c27, t1.c29",
        "score": false,
        "real_pred": "select rankings.player_id, rankings.player_id7, rankings.ranking_points",
        "real_label": "select matches.winner_name, matches.winner_rank_points",
        "topk_preds": [
            "select rankings.player_id, rankings.player_id7, rankings.ranking_points",
            "select matches.draw_size, players.last_name, rankings.ranking_points",
            "select rankings.player_id, players.first_name, players.last_name, rankings.ranking_points",
            "select matches.draw_size, matches.loser_age, rankings.ranking_points",
            "select players.first_name, players.last_name, rankings.ranking_points",
            "select matches.winner_name, rankings.ranking_points",
            "select matches.winner_name, rankings.player_id8, rankings.ranking_points",
            "select rankings.player_id, t2.c7, rankings.ranking_points"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all those that won the most times, their names and their ranking points., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "matches rankings",
        "real_label": "matches",
        "topk_preds": [
            "matches rankings",
            "players matches rankings",
            "",
            "rankings",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the name and ranking points of the player who has won the most times., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-C1, t0.c2, t2.c3",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t2.c2, t2.c3",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, t2.c2, t2.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the name and ranking points of the player who has won the most times., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2, t2.c3",
        "label": "select t1.c27, t1.c29",
        "score": false,
        "real_pred": "select players.first_name, players.last_name, rankings.ranking_points",
        "real_label": "select matches.winner_name, matches.winner_rank_points",
        "topk_preds": [
            "select players.first_name, players.last_name, rankings.ranking_points",
            "select rankings.ranking, rankings.player_id",
            "select matches.draw_size, players.last_name, rankings.ranking_points",
            "select t3.c1, players.first_name, players.last_name",
            "select rankings.ranking, players.first_name, players.last_name",
            "select players.first_name, players.last_name, t2c3",
            "select t.c1, players.last_name, rankings.ranking_points",
            "select t10.c1, players.last_name, rankings.ranking_points"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the name and ranking points of the player who has won the most times., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "players matches rankings",
        "real_label": "matches",
        "topk_preds": [
            "players matches rankings",
            "players rankings",
            "",
            "",
            "",
            "",
            "",
            "players matches"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the average rank for each player and his or her first name here., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t0.c0, SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t0.c1, avg(t2.c1)",
            "SELECT-FROM-GROUP BY t0.c0, SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GROUP BY t0.c0, SELECT-FROM-GROUP BY t0.c1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the average rank for each player and his or her first name here., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select avg(t2.c1), t0.c1",
        "label": "select avg(t2.c1), t0.c1",
        "score": true,
        "real_pred": "select avg(rankings.ranking), players.first_name",
        "real_label": "select avg(rankings.ranking), players.first_name",
        "topk_preds": [
            "select avg(rankings.ranking), players.first_name",
            "select rankings.ranking, players.first_name",
            "select players.player_id, players.first_name",
            "select players.player_id, players.first_name, avg(rankings.ranking)",
            "select rankings.player_id, avg(rankings.ranking)",
            "select players.first_name, avg(rankings.ranking)",
            "select avg(rankings.ranking), players.first_name, players.last_name",
            "select rankings.player_id, players.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the average rank for each player and his or her first name here., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "players rankings",
        "real_label": "players rankings",
        "topk_preds": [
            "players rankings",
            "players matches rankings",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the average age of people who lost and won during all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the average age of people who lost and won during all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select avg(t1.c2), avg(t1.c21)",
        "label": "select avg(t1.c2), avg(t1.c21)",
        "score": true,
        "real_pred": "select avg(matches.loser_age), avg(matches.winner_age)",
        "real_label": "select avg(matches.loser_age), avg(matches.winner_age)",
        "topk_preds": [
            "select avg(matches.loser_age), avg(matches.winner_age)",
            "select avg(matches.loser_age), avg(matches.winner_age",
            "select avg(matches.loser_age), avg(matches.loser_age)",
            "select avg(matches.loser_age), avg(matches.loser_entry)",
            "select avg(matches.loser_age), avg(matches.draw_size)",
            "select avg(matches.loser_age), avg(matches.winner_hand)",
            "select avg(matches.loser_age)., avg(matches.winner_age)",
            "select avg(matches.loser_age), avg(matches.tourney_name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the average age of people who lost and won during all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the average ages of players that lost (and won) each match., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the average ages of players that lost (and won) each match., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select avg(t1.c2), avg(t1.c21)",
        "label": "select avg(t1.c2), avg(t1.c21)",
        "score": true,
        "real_pred": "select avg(matches.loser_age), avg(matches.winner_age)",
        "real_label": "select avg(matches.loser_age), avg(matches.winner_age)",
        "topk_preds": [
            "select avg(matches.loser_age), avg(matches.winner_age)",
            "select avg(matches.loser_age), avg(matches.winner_age), matches.match_num",
            "select matches.loser_age, avg(matches.winner_age)",
            "select avg(matches.loser_age), avg(matches.loser_age)",
            "select avg(matches.loser_age), avg(matches.loser_entry)",
            "select avg(matches.loser_age), avg(matches.winner_age), matches.minutes",
            "select avg(matches.loser_age), avg(matches.winner_age),",
            "select avg(matches.loser_age), avg(matches.winner_age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the average ages of players that lost (and won) each match., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I am looking for the average age of those who lost and won in all games., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I am looking for the average age of those who lost and won in all games., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select avg(t1.c2), avg(t1.c21)",
        "label": "select avg(t1.c2), avg(t1.c21)",
        "score": true,
        "real_pred": "select avg(matches.loser_age), avg(matches.winner_age)",
        "real_label": "select avg(matches.loser_age), avg(matches.winner_age)",
        "topk_preds": [
            "select avg(matches.loser_age), avg(matches.winner_age)",
            "select avg(matches.loser_age), avg(matches.winner_age",
            "select avg(matches.loser_age), avg(matches.loser_age)",
            "select avg(matches.loser_age), avg(matches.loser_entry)",
            "select avg(matches.loser_age), avg(matches.draw_size)",
            "select avg(matches.loser_age)., avg(matches.winner_age)",
            "select avg(matches.loser_age), avg(matches.winner_hand)",
            "select avg(matches.loser_age), avg(matches.tourney_name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I am looking for the average age of those who lost and won in all games., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The average ages of players on the winning and losing sides of alll matches are listed here., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The average ages of players on the winning and losing sides of alll matches are listed here., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select avg(t1.c21, avg(t1.c2)",
        "label": "select avg(t1.c2), avg(t1.c21)",
        "score": false,
        "real_pred": "select avg(matches.winner_age, avg(matches.loser_age)",
        "real_label": "select avg(matches.loser_age), avg(matches.winner_age)",
        "topk_preds": [
            "select avg(matches.winner_age, avg(matches.loser_age)",
            "select avg(matches.winner_age - matches.loser_age)",
            "select avg(matches.loser_age), matches.winner_age",
            "select avg(matches.winner_age - avg(matches.loser_age)",
            "select avg(matches.winner_age, matches.loser_age)",
            "select avg(matches.winner_age, avg(matches.winner_entry)",
            "select avg(matches.winner_age & avg(matches.loser_age)",
            "select matches.winner_age, avg(matches.loser_age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The average ages of players on the winning and losing sides of alll matches are listed here., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the name of the winner who won the most matches and how many point he/she had., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the name of the winner who won the most matches and how many point he/she had., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27, t1.c29",
        "label": "select t1.c27, t1.c29",
        "score": true,
        "real_pred": "select matches.winner_name, matches.winner_rank_points",
        "real_label": "select matches.winner_name, matches.winner_rank_points",
        "topk_preds": [
            "select matches.winner_name, matches.winner_rank_points",
            "select matches.winner_name, matches.winner_seed",
            "select matches.loser_name, matches.winner_rank_points",
            "select matches.loser_ioc, matches.winner_rank_points",
            "select matches.winner_name, matches.winner_rank",
            "select matches.winner_ioc, matches.winner_rank_points",
            "select matches.winner_rank, matches.winner_name",
            "select matches.loser_age, matches.winner_rank_points"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the name of the winner who won the most matches and how many point he/she had., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the name of the winner who had the highest rank points and participated in the Australian Open tournament., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the name of the winner who had the highest rank points and participated in the Australian Open tournament., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27",
        "label": "select t1.c27",
        "score": true,
        "real_pred": "select matches.winner_name",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select matches.winner_name",
            "select matches.winner_name, rankings.ranking_points",
            "select matches.winner_name, rankings.player_id",
            "select matches.winner_name, matches.winner_rank",
            "select matches.winner_name, matches.winner_ioc",
            "select matches.winner_name, matches.winner_rank_points",
            "select matches.winner_name, rankings.ranking_date",
            "select matches.winner_name, rankings.ranking"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the name of the winner who had the highest rank points and participated in the Australian Open tournament., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "matches rankings",
        "real_label": "matches",
        "topk_preds": [
            "matches rankings",
            "",
            "players matches rankings",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you please find the name of the winner who had the highest rank points and played in the Australian Open tournament?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you please find the name of the winner who had the highest rank points and played in the Australian Open tournament?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27",
        "label": "select t1.c27",
        "score": true,
        "real_pred": "select matches.winner_name",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select matches.winner_name",
            "select matches.winner_name, rankings.ranking_points",
            "select matches.winner_name, matches.winner_rank",
            "select matches.winner_name, matches.winner_ioc",
            "select matches.winner_name, rankings.player_id",
            "select matches.winner_name, matches.winner_rank_points",
            "select matches.winner_name, matches.winner_entry",
            "select matches.winner_name, matches.winner_hand"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you please find the name of the winner who had the highest rank points and played in the Australian Open tournament?, database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "matches rankings",
        "real_label": "matches",
        "topk_preds": [
            "matches rankings",
            "",
            "",
            "players matches rankings",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the name of the winner who had the highest rank points and played in the Australian Open tournament., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE.INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the name of the winner who had the highest rank points and played in the Australian Open tournament., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27",
        "label": "select t1.c27",
        "score": true,
        "real_pred": "select matches.winner_name",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select matches.winner_name",
            "select matches.winner_name, rankings.ranking_points",
            "select matches.winner_name, rankings.player_id",
            "select matches.winner_name, matches.winner_rank",
            "select matches.winner_name, matches.winner_ioc",
            "select matches.winner_name, matches.winner_entry",
            "select matches.winner_name, matches.winner_rank_points",
            "select matches.winner_name, matches.winner_hand"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the name of the winner who had the highest rank points and played in the Australian Open tournament., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1 t2",
        "label": "t1",
        "score": false,
        "real_pred": "matches rankings",
        "real_label": "matches",
        "topk_preds": [
            "matches rankings",
            "",
            "",
            "players matches rankings",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who was the winner who had the most points and was playing at the Australian Open tournament., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who was the winner who had the most points and was playing at the Australian Open tournament., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27",
        "label": "select t1.c27",
        "score": true,
        "real_pred": "select matches.winner_name",
        "real_label": "select matches.winner_name",
        "topk_preds": [
            "select matches.winner_name",
            "select matches.winner_name, matches.winner_ioc",
            "select matches.winner_name, matches.winner_rank",
            "select matches.winner_name, matches.winner_rank_points",
            "select matches.winner_name, matches.winner_entry",
            "select matches.best_of, matches.winner_name",
            "select matches.winner_name, matches.winner_hand",
            "select matches.winner_name, matches.winner_seed"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who was the winner who had the most points and was playing at the Australian Open tournament., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name (Australian Open), c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "matches rankings",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Let's find the winner and loser with the highest amount of time on the field of play in a particular game., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Field), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Let's find the winner and loser with the highest amount of time on the field of play in a particular game., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Field), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c27, t1.c8",
        "label": "select t1.c27, t1.c8",
        "score": true,
        "real_pred": "select matches.winner_name, matches.loser_name",
        "real_label": "select matches.winner_name, matches.loser_name",
        "topk_preds": [
            "select matches.winner_name, matches.loser_name",
            "select matches.winner_rank, matches.loser_rank",
            "select matches.winner_hand, matches.loser_name",
            "select matches.minutes, matches.loser_name",
            "select matches.winner_id, matches.loser_name",
            "select matches.winner_entry, matches.loser_name",
            "select matches.winner_ht, matches.loser_name",
            "select matches.winner_ioc, matches.loser_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Let's find the winner and loser with the highest amount of time on the field of play in a particular game., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Field), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Let's find out the names of the loser and winner that were on the pitch for the longest time., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-T1.c8, SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-T1.c8 - SELECT-FROM-WHERE",
            "SELECT-FROM-T1.c8, SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Let's find out the names of the loser and winner that were on the pitch for the longest time., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t1.c8, t1.c27",
        "label": "select t1.c27, t1.c8",
        "score": false,
        "real_pred": "select matches.loser_name, matches.winner_name",
        "real_label": "select matches.winner_name, matches.loser_name",
        "topk_preds": [
            "select matches.loser_name, matches.winner_name",
            "select matches.loser_ioc, matches.loser_name",
            "select matches.loser_name, t1.c 27",
            "select matches.loser_name, matches.loser_ioc",
            "select matches.loser_ht, matches.loser_ioc",
            "select t1.c 8, matches.winner_name",
            "select matches.loser_name, matches.winner_ioc",
            "select matches.loser_name, matches.winner_hand"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Let's find out the names of the loser and winner that were on the pitch for the longest time., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "matches",
        "real_label": "matches",
        "topk_preds": [
            "matches",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give the names of the player who won and lost for the longest duration of time., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give the names of the player who won and lost for the longest duration of time., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t1.c27, t1.c8",
        "score": false,
        "real_pred": "select players.first_name, players.last_name",
        "real_label": "select matches.winner_name, matches.loser_name",
        "topk_preds": [
            "select players.first_name, players.last_name",
            "select matches.winner_name, players.last_name",
            "select rankings.ranking, players.last_name",
            "select t3.c1, players.last_name",
            "select matches.draw_size, players.last_name",
            "select matches.winner_hand, players.last_name",
            "select t5.c1, players.last_name",
            "select t10.c1, players.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give the names of the player who won and lost for the longest duration of time., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t1",
        "score": false,
        "real_pred": "players matches",
        "real_label": "matches",
        "topk_preds": [
            "players matches",
            "players matches rankings",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please provide me information regarding the total score for each player and his or her first name., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t0.c0, SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t0.C0, SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY t0.c1, sum(t1.c15)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please provide me information regarding the total score for each player and his or her first name., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select sum(t1.c15), t0.c1",
        "label": "select sum(t2.c3), t0.c1",
        "score": false,
        "real_pred": "select sum(matches.score), players.first_name",
        "real_label": "select sum(rankings.ranking_points), players.first_name",
        "topk_preds": [
            "select sum(matches.score), players.first_name",
            "select matches.score, players.first_name",
            "select sum(matches.loser_ht), players.first_name",
            "select players.player_id, sum(matches.score)",
            "select rankings.ranking5, players.first_name",
            "select sum(matches.loser_id), players.first_name",
            "select players.first_name, sum(matches.score)",
            "select sum(matches.loser_name), players.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please provide me information regarding the total score for each player and his or her first name., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t2",
        "score": false,
        "real_pred": "players matches",
        "real_label": "players rankings",
        "topk_preds": [
            "players matches",
            "players matches rankings",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need the total ranking score for each player and his or her first name., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t0.c0, SELECT-FROM-GROUP BY",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t0.c0, sum(t2.c3)",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need the total ranking score for each player and his or her first name., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select sum(t2.c1), t0.c1",
        "label": "select sum(t2.c3), t0.c1",
        "score": false,
        "real_pred": "select sum(rankings.ranking), players.first_name",
        "real_label": "select sum(rankings.ranking_points), players.first_name",
        "topk_preds": [
            "select sum(rankings.ranking), players.first_name",
            "select sum(rankings.ranking_points), players.first_name",
            "select rankings.ranking, players.first_name",
            "select sum(rankings.player_id), players.first_name",
            "select sum(t2.c6), players.first_name",
            "select sum(t2.c5), players.first_name",
            "select sum(rankings.tours), players.first_name",
            "select sum(t2.c7), players.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need the total ranking score for each player and his or her first name., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name, c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "players rankings",
        "real_label": "players rankings",
        "topk_preds": [
            "players rankings",
            "players matches rankings",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the first name, country code and birth date of the winner who was ranked the highest in all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the first name, country code and birth date of the winner who was ranked the highest in all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c5, t0.c4",
        "label": "select t0.c1, t0.c5, t0.c4",
        "score": true,
        "real_pred": "select players.first_name, players.country_code, players.birth_date",
        "real_label": "select players.first_name, players.country_code, players.birth_date",
        "topk_preds": [
            "select players.first_name, players.country_code, players.birth_date",
            "select players.first_name, players.birth_date, players.country_code",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.country_code, players.birth_date",
            "select players.first_name, players.hand, players.birth_date",
            "select players.first_name, players.country_code), players.birth_date",
            "select players.first_name, players.country_code, players.last_name",
            "select players.first_name, players.country_code and players.birth_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the first name, country code and birth date of the winner who was ranked the highest in all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t1 t2",
        "label": "t0 t1",
        "score": false,
        "real_pred": "players matches rankings",
        "real_label": "players matches",
        "topk_preds": [
            "players matches rankings",
            "players matches",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Search for the first name, country code and birth date of the player with the highest points after winning all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Search for the first name, country code and birth date of the player with the highest points after winning all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c5, t0.c4",
        "label": "select t0.c1, t0.c5, t0.c4",
        "score": true,
        "real_pred": "select players.first_name, players.country_code, players.birth_date",
        "real_label": "select players.first_name, players.country_code, players.birth_date",
        "topk_preds": [
            "select players.first_name, players.country_code, players.birth_date",
            "select players.first_name, players.birth_date, players.country_code",
            "select players.first_name, players.country_code, players.birth_date",
            "select players.first_name, players.last_name, players.birth_date",
            "select players.first_name, players.country_code, players.birth_date",
            "select players.first_name, players.country_code), players.birth_date",
            "select players.first_name, players.hand, players.birth_date",
            "select players.first_name, players.country_code and players.birth_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Search for the first name, country code and birth date of the player with the highest points after winning all matches., database: Database: wta_1. t0: players(c0: player_id, c1: first_name, c2: last_name (Date), c3: hand, c4: birth_date, c5: country_code). t1: matches(c0: best_of, c1: draw_size, c2: loser_age, c3: loser_entry, c4: loser_hand, c5: loser_ht, c6: loser_id, c7: loser_ioc, c8: loser_name, c9: loser_rank, c10: loser_rank_points, c11: loser_seed, c12: match_num, c13: minutes, c14: round, c15: score, c16: surface, c17: tourney_date, c18: tourney_id, c19: tourney_level, c20: tourney_name, c21: winner_age, c22: winner_entry, c23: winner_hand, c24: winner_ht, c25: winner_id, c26: winner_ioc, c27: winner_name, c28: winner_rank, c29: winner_rank_points, c30: winner_seed, c31: year) (c25) refers to t0(c0), (c6) refers to t0(c0). t2: rankings(c0: ranking_date, c1: ranking, c2: player_id, c3: ranking_points, c4: tours) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "players matches",
        "real_label": "players matches",
        "topk_preds": [
            "players matches",
            "",
            "",
            "players matches rankings",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the number of people who were injured and killed by the ship with tonnage 't'?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COMBINAT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-COMBINAT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the number of people who were injured and killed by the ship with tonnage 't'?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t2.c4, t2.c3",
        "label": "select t2.c3, t2.c4",
        "score": false,
        "real_pred": "select death.injured, death.killed",
        "real_label": "select death.killed, death.injured",
        "topk_preds": [
            "select death.injured, death.killed",
            "select sum(death.injured), sum(death.killed)",
            "select death.killed, death.injured",
            "select sum(death.killed), sum(death.killed)",
            "select sum(death.killed), sum(death.injured)",
            "select count(death.injured), count(death.killed)",
            "select death.injured, t2.c5",
            "select death.id, death.killed"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the number of people who were injured and killed by the ship with tonnage 't'?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "ship death",
        "real_label": "ship death",
        "topk_preds": [
            "ship death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many people died and were wounded in ships weighing  t'., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C3, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-C3, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-C3, SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-C3, t2.c4"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many people died and were wounded in ships weighing  t'., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t2.c3, t2.c4",
        "label": "select t2.c3, t2.c4",
        "score": true,
        "real_pred": "select death.killed, death.injured",
        "real_label": "select death.killed, death.injured",
        "topk_preds": [
            "select death.killed, death.injured",
            "select sum(death.killed), sum(death.injured)",
            "select death.caused_by_ship_id, death.killed, death.injured",
            "select death.note, death.killed, death.injured",
            "select count(death.killed), count(death.injured)",
            "select death.killed, death.injured, ship.id",
            "select death.killed, death.injured, death.id",
            "select death.killed, death.injured, death.caused_by_ship_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many people died and were wounded in ships weighing  t'., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "ship death",
        "real_label": "ship death",
        "topk_preds": [
            "ship death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many people have died and been injured due to the ship with tonnage 't'?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C3, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE t2.c3, t2.c4",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C3-, SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many people have died and been injured due to the ship with tonnage 't'?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t2.c3, t2.c4",
        "label": "select t2.c3, t2.c4",
        "score": true,
        "real_pred": "select death.killed, death.injured",
        "real_label": "select death.killed, death.injured",
        "topk_preds": [
            "select death.killed, death.injured",
            "select sum(death.killed), sum(death.injured)",
            "select death.caused_by_ship_id, death.killed, death.injured",
            "select death.id, death.killed, death.injured",
            "select death.note, death.killed, death.injured",
            "select count(death.killed), count(death.injured)",
            "select death.killed, death.injured, death.caused_by_ship_id",
            "select death.killed, death.injured, death.id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many people have died and been injured due to the ship with tonnage 't'?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t1 t2",
        "label": "t1 t2",
        "score": true,
        "real_pred": "ship death",
        "real_label": "ship death",
        "topk_preds": [
            "ship death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the highest and lowest number of people killed each incident?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM each t2.c1, max(t2.c3), min(t2.c3)",
            "SELECT-FROM t2.c1, max(t2.c3), min(t2.c3)",
            "SELECT-FROM-GROUP BY t2.c1, max(t2.c3), min(t2.c3)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY t2.c0, max(t2.c3), min(t2.c3)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the highest and lowest number of people killed each incident?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t2.c1, max(t2.c3), min(t2.c3)",
        "label": "select max(t2.c3), min(t2.c3)",
        "score": false,
        "real_pred": "select death.id, max(death.killed), min(death.killed)",
        "real_label": "select max(death.killed), min(death.killed)",
        "topk_preds": [
            "select death.id, max(death.killed), min(death.killed)",
            "select death.caused_by_ship_id, max(death.killed), min(death.killed)",
            "select max(death.killed), min(death.killed), death.caused_by_ship_id",
            "select max(death.killed), min(death.killed), death.id",
            "select battle.name, max(death.killed), min(death.killed)",
            "select t2.c5, max(death.killed), min(death.killed)",
            "select death.note, max(death.killed), min(death.killed)",
            "select death.injured, max(death.killed), min(death.killed)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the highest and lowest number of people killed each incident?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "death",
        "real_label": "death",
        "topk_preds": [
            "death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How high or low did casualties reach each time?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM at each t2.c3, t2.c4",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-T2.C1, max(t2.c3)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How high or low did casualties reach each time?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t2.c3, t2.c4",
        "label": "select max(t2.c3), min(t2.c3)",
        "score": false,
        "real_pred": "select death.killed, death.injured",
        "real_label": "select max(death.killed), min(death.killed)",
        "topk_preds": [
            "select death.killed, death.injured",
            "select max(death.killed), min(death.injured)",
            "select death.killed, death.injured, min(death.killed)",
            "select max(death.killed), min(death.killed)",
            "select death.id, max(death.killed)",
            "select death.killed, death.injured, max(death.killed)",
            "select avg(death.killed), min(death.killed)",
            "select min(death.killed), max(death.killed)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How high or low did casualties reach each time?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "death",
        "real_label": "death",
        "topk_preds": [
            "death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of the casualties, what is the maximum and minimum number of deaths?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM, MAX(t2.c3), min(t2.c3)",
            "SELECT-FROM, max(t2.c3), min(t2.c3)",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM the total(t2.c3), min(t2.c3)",
            "SELECT-FROM the total(t2.c3), MINIMUM(t2.c3)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of the casualties, what is the maximum and minimum number of deaths?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select max(t2.c3), min(t2.c3)",
        "label": "select max(t2.c3), min(t2.c3)",
        "score": true,
        "real_pred": "select max(death.killed), min(death.killed)",
        "real_label": "select max(death.killed), min(death.killed)",
        "topk_preds": [
            "select max(death.killed), min(death.killed)",
            "select max(death.injured), min(death.killed)",
            "select max(t2.c6), min(death.killed)",
            "select max(death.note), min(death.killed)",
            "select max(t2.c8), min(death.killed)",
            "select max(t2.c5), min(death.killed)",
            "select max(t2.c9), min(death.killed)",
            "select max(t2.c7), min(death.killed)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of the casualties, what is the maximum and minimum number of deaths?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "death",
        "real_label": "death",
        "topk_preds": [
            "death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the highest and lowest number of death per incident?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM t2.c1, max(t2.c3), min(t2.c3)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT, max(t2.c3), min(t2.c3)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the highest and lowest number of death per incident?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select max(t2.c3), min(t2.c3)",
        "label": "select max(t2.c3), min(t2.c3)",
        "score": true,
        "real_pred": "select max(death.killed), min(death.killed)",
        "real_label": "select max(death.killed), min(death.killed)",
        "topk_preds": [
            "select max(death.killed), min(death.killed)",
            "select max(death.injured), min(death.killed)",
            "select max(death.killed), min(death.injured)",
            "select max(t2.c6), min(death.killed)",
            "select max(death.injured), min(death.injured)",
            "select max(t2.c5), min(death.killed)",
            "select max(t2.c8), min(death.killed)",
            "select max(t2.c7), min(death.killed)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the highest and lowest number of death per incident?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "death",
        "real_label": "death",
        "topk_preds": [
            "death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the highest and lowest number of deaths during each event?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM each t0.c1, max(t2.c3), min(t2.c3)",
            "SELECT-FROM each t0.c1, SELECT-FROM-GROUP BY",
            "SELECT-FROM each t0.c1, SELECT-FROM",
            "SELECT-FROM each t0.c1, min(t2.c3)",
            "SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the highest and lowest number of deaths during each event?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t0.c1, max(t2.c3), min(t2.c3)",
        "label": "select max(t2.c3), min(t2.c3)",
        "score": false,
        "real_pred": "select battle.name, max(death.killed), min(death.killed)",
        "real_label": "select max(death.killed), min(death.killed)",
        "topk_preds": [
            "select battle.name, max(death.killed), min(death.killed)",
            "select battle.date, max(death.killed), min(death.killed)",
            "select max(death.killed), min(death.killed), battle.date",
            "select battle.id, max(death.killed), min(death.killed)",
            "select max(death.killed), min(death.killed), battle.name",
            "select death.id, max(death.killed), min(death.killed)",
            "select battle.date, max(death.killed)",
            "select battle.name, max(death.injured), min(death.killed)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the highest and lowest number of deaths during each event?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t2",
        "score": false,
        "real_pred": "battle death",
        "real_label": "death",
        "topk_preds": [
            "battle death",
            "battle ship death",
            "ship death",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What were the battle IDs and names where the total number of deaths was more than 10?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What were the battle IDs and names where the total number of deaths was more than 10?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select battle.id, battle.name",
        "real_label": "select battle.id, battle.name",
        "topk_preds": [
            "select battle.id, battle.name",
            "select battle.name, battle.id",
            "select battle.date, battle.name",
            "select death.id, battle.name",
            "select t.c0, battle.name",
            "select t0.c, battle.name",
            "select t 0.c0, battle.name",
            "select t0-c0, battle.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What were the battle IDs and names where the total number of deaths was more than 10?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t1 t2",
        "score": false,
        "real_pred": "battle death",
        "real_label": "battle ship death",
        "topk_preds": [
            "battle death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the ids or names of battles that resulted in more than 10 deaths in total?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the ids or names of battles that resulted in more than 10 deaths in total?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t0.c0, t0.c1",
        "label": "select t0.c0, t0.c1",
        "score": true,
        "real_pred": "select battle.id, battle.name",
        "real_label": "select battle.id, battle.name",
        "topk_preds": [
            "select battle.id, battle.name",
            "select battle.name, battle.id",
            "select battle.id ou battle.name",
            "select battle.id / battle.name",
            "select battle.id or battle.name",
            "select battle.date, battle.name",
            "select t0-c0, battle.name",
            "select t0.c, battle.name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the ids or names of battles that resulted in more than 10 deaths in total?, database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0 t2",
        "label": "t0 t1 t2",
        "score": false,
        "real_pred": "battle death",
        "real_label": "battle ship death",
        "topk_preds": [
            "battle death",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the names of battles that Bulgarian officer Kaloyan fought against Latin officer Baldwin., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the names of battles that Bulgarian officer Kaloyan fought against Latin officer Baldwin., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select battle.name",
        "real_label": "select battle.name",
        "topk_preds": [
            "select battle.name",
            "select battle.name, battle.date",
            "select battle.name, battle.date, battle.bulgarian_commander",
            "select battle.name, battle.date, battle.latin_commander",
            "select battle.name, battle.date, battle.result",
            "select battle.name, battle.date, battle.bulgarian_commander",
            "select battle.name, battle.bulgarian_commander, battle.latin_commander",
            "select battle.name, battle.latin_commander"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the names of battles that Bulgarian officer Kaloyan fought against Latin officer Baldwin., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "battle",
        "real_label": "battle",
        "topk_preds": [
            "battle",
            "",
            "battle ship",
            "",
            "battle death",
            "",
            "",
            "battle ship death"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the battle names which are between the Bulgarian leader, Kaloyan, and the Latin leader, Baldwin I., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the battle names which are between the Bulgarian leader, Kaloyan, and the Latin leader, Baldwin I., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select battle.name",
        "real_label": "select battle.name",
        "topk_preds": [
            "select battle.name",
            "select battle.name, battle.bulgarian_commander, battle.latin_commander",
            "select battle.name, battle.date",
            "select battle.name, battle.date, battle.bulgarian_commander",
            "select battle.name, battle.date, battle.latin_commander",
            "select battle.name - battle.bulgarian_commander - battle.latin_commander",
            "select battle.name, battle.latin_commander",
            "select battle.name, battle.bulgarian_commander-, battle.latin_commander"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the battle names which are between the Bulgarian leader, Kaloyan, and the Latin leader, Baldwin I., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander (Kaloyan), c4: latin_commander (Baldwin I), c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "battle",
        "real_label": "battle",
        "topk_preds": [
            "battle",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me further information on deaths that contain the word \"East\"., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me further information on deaths that contain the word \"East\"., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "select t2.c2",
        "label": "select t2.c2",
        "score": true,
        "real_pred": "select death.note",
        "real_label": "select death.note",
        "topk_preds": [
            "select death.note",
            "select *",
            "select death.caused_by_ship_id, death.note",
            "select death.id, death.note",
            "select death.id, death.killed",
            "select death.injured",
            "select death.id",
            "select death.killed"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me further information on deaths that contain the word \"East\"., database: Database: battle_death. t0: battle(c0: id, c1: name, c2: date, c3: bulgarian_commander, c4: latin_commander, c5: result). t1: ship(c0: lost_in_battle, c1: id, c2: name, c3: tonnage, c4: ship_type, c5: location, c6: disposition_of_ship) (c0) refers to t0(c0). t2: death(c0: caused_by_ship_id, c1: id, c2: note, c3: killed, c4: injured) (c0) refers to t1(c1).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "death",
        "real_label": "death",
        "topk_preds": [
            "death",
            "",
            "",
            "",
            "",
            "ship death",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the names and content of all the sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the names and content of all the sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "select t4.c2, t4.c3",
        "label": "select t4.c2, t4.c3",
        "score": true,
        "real_pred": "select Sections.section_name, Sections.section_description",
        "real_label": "select Sections.section_name, Sections.section_description",
        "topk_preds": [
            "select Sections.section_name, Sections.section_description",
            "select Sections.section_name, Sections.section_description, Sections.other_details",
            "select Sections.section_name, Sections.section_description.",
            "select Sections.course_id, Sections.section_description",
            "select Departments.department_description, Sections.section_description",
            "select Sections.section_name, Sections.section_description, Sections.section_id",
            "select Sections.section_name-, Sections.section_description",
            "select Sections.section_name, Sections.section_description,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the names and content of all the sections., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Sections",
        "real_label": "Sections",
        "topk_preds": [
            "Sections",
            "",
            "",
            "",
            "",
            "Departments Sections",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the descriptions for all math classes?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name (math), c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name (math), c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the descriptions for all math classes?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name (math), c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name (math), c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select Courses.course_description",
        "real_label": "select Courses.course_description",
        "topk_preds": [
            "select Courses.course_description",
            "select Courses.course_description, Courses.other_details",
            "select Courses.course_description, Courses.course_name",
            "select Courses.course_description, Courses.course_id",
            "select t1.c5, Courses.course_description",
            "select Courses.course_description, t1.c4",
            "select Courses.course_description, t1.c7",
            "select Courses.course_description, t1.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the descriptions for all math classes?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name (math), c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name (math), c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Courses",
        "real_label": "Courses",
        "topk_preds": [
            "Courses",
            "Courses Student_Enrolment_Courses",
            "Courses Departments Sections",
            "Courses Departments Degree_Programs",
            "Courses Student_Enrolment",
            "Courses Departments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I'm looking for all the addresses on line one and line two., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ON-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-LINE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I'm looking for all the addresses on line one and line two., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select Addresses.line_1, Addresses.line_2",
        "real_label": "select Addresses.line_1, Addresses.line_2",
        "topk_preds": [
            "select Addresses.line_1, Addresses.line_2",
            "select Addresses.line_1, Addresses.line_2, Addresses.other_address_details",
            "select Addresses.line_1, Addresses.line_2, Addresses.line_3",
            "select Addresses.line_1, Addresses.line_2 - Addresses.other_address_details",
            "select Addresses.line_1, Addresses.line_2,",
            "select Addresses.line_1, Addresses.line_2, Addresses.other_address_details",
            "select Addresses.line_1, Addresses.line_2.",
            "select Addresses.line_1.c1, Addresses.line_2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I'm looking for all the addresses on line one and line two., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Addresses",
        "real_label": "Addresses",
        "topk_preds": [
            "Addresses",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please provide me with all the addresses including line one and two., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description (provident), c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-INCLUDE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-INC1, SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please provide me with all the addresses including line one and two., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description (provident), c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select Addresses.line_1, Addresses.line_2",
        "real_label": "select Addresses.line_1, Addresses.line_2",
        "topk_preds": [
            "select Addresses.line_1, Addresses.line_2",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
            "select Addresses.line_1, Addresses.line_2, Addresses.line_3",
            "select Addresses.line_1, Addresses.line_2, Addresses.other_address_details",
            "select distinct Addresses.line_1, Addresses.line_2",
            "select full Addresses.line_1, Addresses.line_2",
            "select Addresses.zip_postcode, Addresses.state_province_county",
            "select Addresses.line_1, Addresses.line_2, Addresses.city"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please provide me with all the addresses including line one and two., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description (provident), c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Addresses",
        "real_label": "Addresses",
        "topk_preds": [
            "Addresses",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter the addresses that include the first line followed by the second line., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter the addresses that include the first line followed by the second line., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "select t0.c8",
        "label": "select t0.c1, t0.c2",
        "score": false,
        "real_pred": "select Addresses.other_address_details",
        "real_label": "select Addresses.line_1, Addresses.line_2",
        "topk_preds": [
            "select Addresses.other_address_details",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
            "select Addresses.address_id",
            "select Addresses.line_1, Addresses.line_2",
            "select Addresses.zip_postcode, Addresses.state_province_county",
            "select Addresses.state_province_county, Addresses.other_address_details",
            "select Addresses.address_id, Addresses.line_1 + Addresses.line_2",
            "select Addresses.address_id, Addresses.line_1"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter the addresses that include the first line followed by the second line., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Addresses",
        "real_label": "Addresses",
        "topk_preds": [
            "Addresses",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are lines 1 and 2 of all addresses?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-INTERSECT-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are lines 1 and 2 of all addresses?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select Addresses.line_1, Addresses.line_2",
        "real_label": "select Addresses.line_1, Addresses.line_2",
        "topk_preds": [
            "select Addresses.line_1, Addresses.line_2",
            "select Addresses.address_id, Addresses.line_1, Addresses.line_2",
            "select distinct Addresses.line_1, Addresses.line_2",
            "select Addresses.line_1, Addresses.line_2, Addresses.line_3",
            "select Addresses.line_1, Addresses.line_2,",
            "select Addresses.line_1, Addresses.line_2.",
            "select t0.c 1, Addresses.line_2",
            "select Addresses.line_1, Addresses.line_2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are lines 1 and 2 of all addresses?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "Addresses",
        "real_label": "Addresses",
        "topk_preds": [
            "Addresses",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list all the sections and their relevant details here., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list all the sections and their relevant details here., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "select t4.c0, t4.c2, t4.c3, t4.c4",
        "label": "select t4.c2, t4.c3",
        "score": false,
        "real_pred": "select Sections.section_id, Sections.section_name, Sections.section_description, Sections.other_details",
        "real_label": "select Sections.section_name, Sections.section_description",
        "topk_preds": [
            "select Sections.section_id, Sections.section_name, Sections.section_description, Sections.other_details",
            "select Sections.section_name, Sections.section_description, Sections.other_details",
            "select Sections.section_id, Sections.course_id, Sections.section_name, Sections.section_description, Sections.other_details",
            "select Sections.course_id, Sections.section_name, Sections.section_description, Sections.other_details",
            "select Sections.section_id, Sections.section_name, Sections.section_description",
            "select Sections.section_id, Sections.section_name, Sections.other_details",
            "select Sections.section_id, Sections.course_id, Sections.section_description, Sections.other_details",
            "select Sections.section_name, Sections.other_details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list all the sections and their relevant details here., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Sections",
        "real_label": "Sections",
        "topk_preds": [
            "Sections",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the information on the department that uses the word \"computer\"?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SQL-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the information on the department that uses the word \"computer\"?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t2.c2",
        "label": "select t2.c2",
        "score": true,
        "real_pred": "select Departments.department_description",
        "real_label": "select Departments.department_description",
        "topk_preds": [
            "select Departments.department_description",
            "select Departments.other_details",
            "select t2.c4",
            "select t2.c5",
            "select Departments.department_name, Departments.department_description",
            "select Departments.department_description, Departments.other_details",
            "select Departments.department_name, Departments.other_details",
            "select Departments.department_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the information on the department that uses the word \"computer\"?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Departments",
        "real_label": "Departments",
        "topk_preds": [
            "Departments",
            "Courses Departments",
            "Departments Degree_Programs",
            "Departments Transcripts",
            "Addresses Departments",
            "Departments Sections",
            "Departments Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The department which has the substring 'computers' should be described., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DEFECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DEFECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-DEFINIT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DEFINIT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The department which has the substring 'computers' should be described., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t2.c2",
        "label": "select t2.c2",
        "score": true,
        "real_pred": "select Departments.department_description",
        "real_label": "select Departments.department_description",
        "topk_preds": [
            "select Departments.department_description",
            "select t2.c5, Departments.department_description",
            "select Departments.department_id, Departments.department_description",
            "select Departments.department_name, Departments.department_description",
            "select Departments.department_description, Departments.department_name",
            "select t2.c5, t2.c6",
            "select Departments.department_description, Departments.department_id",
            "select Departments.department_description, Departments.other_details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The department which has the substring 'computers' should be described., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Departments",
        "real_label": "Departments",
        "topk_preds": [
            "Departments",
            "Departments Transcripts",
            "Courses Departments",
            "",
            "Departments Student_Enrolment_Courses",
            "Addresses Departments",
            "",
            "Departments Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For everybody enrolled in a bachelors program, what are the full names?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For everybody enrolled in a bachelors program, what are the full names?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select distinct t6.c3, t6.c4, t6.c5",
        "score": false,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select distinct Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.current_address_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.current_address_id, Students.middle_name, Students.last_name",
            "select distinct Students.first_name, Students.middle_name, Students.last_name",
            "select Student_Enrolment.student_id, Students.middle_name, Students.last_name",
            "select t.c3, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For everybody enrolled in a bachelors program, what are the full names?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t6 t7",
        "label": "t3 t6 t7",
        "score": false,
        "real_pred": "Students Student_Enrolment",
        "real_label": "Degree_Programs Students Student_Enrolment",
        "topk_preds": [
            "Students Student_Enrolment",
            "Degree_Programs Students Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "",
            "Sections Students Student_Enrolment",
            "Departments Students Student_Enrolment",
            "Addresses Degree_Programs Students Student_Enrolment",
            "Addresses Students Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter the mobile number of the student named Timmy Ward below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter the mobile number of the student named Timmy Ward below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t6.c6",
        "label": "select t6.c6",
        "score": true,
        "real_pred": "select Students.cell_mobile_number",
        "real_label": "select Students.cell_mobile_number",
        "topk_preds": [
            "select Students.cell_mobile_number",
            "select Students.cell_mobile_number, Students.email_address",
            "select Students.cell_mobile_number, Students.date_first_registered",
            "select Students.cell_mobile_number, Students.ssn",
            "select Students.cell_mobile_number, Students.last_name",
            "select t.c6",
            "select Students.cell_mobile_number - Students.email_address",
            "select Students.cell_mobile_number, Students.date_left"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter the mobile number of the student named Timmy Ward below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "Students Student_Enrolment",
            "",
            "Students Student_Enrolment_Courses",
            "",
            "Semesters Students Student_Enrolment",
            "Addresses Students Student_Enrolment",
            "Semesters Students Student_Enrolment_Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the cell mobile number of the student named Timmothy Ward., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name (Timmothy), c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7:",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the cell mobile number of the student named Timmothy Ward., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name (Timmothy), c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details).",
        "prediction": "select t6.c6",
        "label": "select t6.c6",
        "score": true,
        "real_pred": "select Students.cell_mobile_number",
        "real_label": "select Students.cell_mobile_number",
        "topk_preds": [
            "select Students.cell_mobile_number",
            "select Students.cell_mobile_number, Students.email_address",
            "select Students.cell_mobile_number, Students.last_name",
            "select Students.cell_mobile_number, Students.date_first_registered",
            "select Students.cell_mobile_number, Students.ssn",
            "select Students.cell_mobile_number - Students.email_address",
            "select Students.cell_mobile_number, Students.other_student_details",
            "select Students.cell_mobile_number, Students.current_address_id3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the cell mobile number of the student named Timmothy Ward., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name (Timmothy), c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "Students Student_Enrolment",
            "Addresses Students Student_Enrolment",
            "Semesters Students Student_Enrolment",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which cell number belongs to the student Timothy Ward?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which cell number belongs to the student Timothy Ward?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "select t6.c6",
        "label": "select t6.c6",
        "score": true,
        "real_pred": "select Students.cell_mobile_number",
        "real_label": "select Students.cell_mobile_number",
        "topk_preds": [
            "select Students.cell_mobile_number",
            "select t66.c6",
            "select t.c6",
            "select t62.c6",
            "select t61.c6",
            "select Students.cell_mobile_number6",
            "select Students.cell_mobile_number)",
            "select t 6.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which cell number belongs to the student Timothy Ward?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_i",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "Students Student_Enrolment_Courses",
            "Semesters Students",
            "Students Student_Enrolment",
            "Addresses Students",
            "Courses Students",
            "Sections Students",
            "Degree_Programs Students"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter the cell phone number for the student named Timmothy Ward below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name (Timmothy), c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_en",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter the cell phone number for the student named Timmothy Ward below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name (Timmothy), c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7",
        "prediction": "select t6.c6",
        "label": "select t6.c6",
        "score": true,
        "real_pred": "select Students.cell_mobile_number",
        "real_label": "select Students.cell_mobile_number",
        "topk_preds": [
            "select Students.cell_mobile_number",
            "select Students.cell_mobile_number, Students.email_address",
            "select Students.cell_mobile_number, Students.first_name, Students.last_name",
            "select Students.cell_mobile_number, Students.email_address, Students.ssn",
            "select Students.cell_mobile_number, Students.last_name",
            "select Students.cell_mobile_number, Students.email_address, Students.date_left",
            "select Students.cell_mobile_number, Students.ssn",
            "select Students.cell_mobile_number, Students.date_first_registered"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter the cell phone number for the student named Timmothy Ward below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name (Timmothy), c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrol",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "Students Student_Enrolment",
            "Students Student_Enrolment_Courses",
            "Addresses Students",
            "Semesters Students",
            "Degree_Programs Students",
            "Courses Students",
            "Sections Students"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me the cellphone number of the student called Timothy Ward., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me the cellphone number of the student called Timothy Ward., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select t6.c6",
        "label": "select t6.c6",
        "score": true,
        "real_pred": "select Students.cell_mobile_number",
        "real_label": "select Students.cell_mobile_number",
        "topk_preds": [
            "select Students.cell_mobile_number",
            "select Students.cell_mobile_number, Students.email_address",
            "select Students.cell_mobile_number, Students.date_first_registered",
            "select Students.cell_mobile_number, Students.ssn",
            "select Students.cell_mobile_number - Students.email_address",
            "select Students.cell_mobile_number, Students.last_name",
            "select Students.cell_mobile_number, Student_Enrolment.semester_id",
            "select Students.cell_mobile_number, Student_Enrolment_Courses.course_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me the cellphone number of the student called Timothy Ward., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name (Ward), c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "Students Student_Enrolment_Courses",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: First name, middle name, surname - list those students who came first to be a student on this day., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_en",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ON-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: First name, middle name, surname - list those students who came first to be a student on this day., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7",
        "prediction": "select t6.c3, t6.c4, t6.c5",
        "label": "select t6.c3, t6.c4, t6.c5",
        "score": true,
        "real_pred": "select Students.first_name, Students.middle_name, Students.last_name",
        "real_label": "select Students.first_name, Students.middle_name, Students.last_name",
        "topk_preds": [
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.student_id, Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name., Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select distinct Students.first_name, Students.middle_name, Students.last_name",
            "select Students.current_address_id, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.middle_name, Students.last_name.",
            "select Students.first_name, Students.middle_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: First name, middle name, surname - list those students who came first to be a student on this day., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrol",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please indicate when can be seen the first transcript and provide additional information., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description (provident), c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please indicate when can be seen the first transcript and provide additional information., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description (provident), c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t8.c5, t9.c6",
            "select t8.c5, t10.c6",
            "select t7.c9, Student_Enrolment.degree_program_id0",
            "select t10.c5, t10.c6",
            "select t8.c5, t7.c6",
            "select t9.c5, t9.c6",
            "select t7.c9, Student_Enrolment.degree_program_id2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please indicate when can be seen the first transcript and provide additional information., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description (provident), c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t8",
        "label": "t9",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "Transcripts",
            "Courses Student_Enrolment_Courses",
            "Student_Enrolment",
            "Courses",
            "Courses Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me when the first transcript was released and what information it contains., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me when the first transcript was released and what information it contains., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t7.c9, Student_Enrolment.degree_program_id0",
            "select t10.c5, t10.c6",
            "select t7.c5, t7.c6",
            "select t11.c2, t11.c3",
            "select t9.c5, t9.c6",
            "select t8.c5, t9.c6",
            "select t8.c5, t10.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me when the first transcript was released and what information it contains., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "t8",
        "label": "t9",
        "score": false,
        "real_pred": "Student_Enrolment_Courses",
        "real_label": "Transcripts",
        "topk_preds": [
            "Student_Enrolment_Courses",
            "Transcripts",
            "Transcript_Contents",
            "Addresses Transcripts",
            "Addresses Student_Enrolment_Courses",
            "Addresses",
            "Courses Student_Enrolment_Courses",
            "Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you tell me the earliest date of the transcript release, along with all the information about it?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you tell me the earliest date of the transcript release, along with all the information about it?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_en",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select t8.c5, t8.c6, t8.c7",
            "select t14.c5, t14.c6",
            "select t8.c5, t10.c6",
            "select t9.c5, t9.c6",
            "select t10.c5, t10.c6",
            "select t13.c5, t13.c6",
            "select t8.c5, t9.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you tell me the earliest date of the transcript release, along with all the information about it?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "",
            "Student_Enrolment_Courses",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the earliest available transcript release, and can you tell me more information about it?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the earliest available transcript release, and can you tell me more information about it?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrol",
        "prediction": "select t8.c5, t8.c6",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t8.c5, t8.c6",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5, t8.c6",
            "select Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id",
            "select Transcripts.transcript_id, Transcripts.other_details",
            "select t9.c5, t9.c6",
            "select t8.c5, t10.c6",
            "select Student_Enrolment_Courses.course_id, t8.c3",
            "select t10.c5, t10.c6",
            "select t14.c5, t14.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the earliest available transcript release, and can you tell me more information about it?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0:",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Transcript_Contents",
            "Student_Enrolment_Courses",
            "Courses Student_Enrolment_Courses",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: On which date was the first transcript released? Please give some more information on this., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: On which date was the first transcript released? Please give some more information on this., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t8.c5",
        "label": "select t9.c1, t9.c2",
        "score": false,
        "real_pred": "select t8.c5",
        "real_label": "select Transcripts.transcript_date, Transcripts.other_details",
        "topk_preds": [
            "select t8.c5",
            "select t10.c5",
            "select t13.c5",
            "select t12.c5",
            "select t14.c5",
            "select t9.c5",
            "select t11.c3",
            "select Addresses.zip_postcode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: On which date was the first transcript released? Please give some more information on this., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t9",
        "label": "t9",
        "score": true,
        "real_pred": "Transcripts",
        "real_label": "Transcripts",
        "topk_preds": [
            "Transcripts",
            "Student_Enrolment_Courses",
            "Transcript_Contents",
            "Student_Enrolment",
            "",
            "",
            "",
            "Courses"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For the enrollment period, when was it for Master's students and Bachelor's students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name (Bachelor, Master), c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_en",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISPATCH-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For the enrollment period, when was it for Master's students and Bachelor's students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name (Bachelor, Master), c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7",
        "prediction": "select t6.c9, t6.c10",
        "label": "select distinct t7.c2",
        "score": false,
        "real_pred": "select Students.date_first_registered, Students.date_left",
        "real_label": "select distinct Student_Enrolment.semester_id",
        "topk_preds": [
            "select Students.date_first_registered, Students.date_left",
            "select Students.current_address_id3, Students.current_address_id4",
            "select Student_Enrolment.degree_program_id3, Student_Enrolment.degree_program_id4",
            "select Student_Enrolment.degree_program_id3, Students.current_address_id4",
            "select Student_Enrolment.degree_program_id2, Student_Enrolment.degree_program_id3",
            "select Student_Enrolment.student_id, Student_Enrolment.other_details",
            "select t7.c5, t7.c6",
            "select Students.date_left, Students.current_address_id3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For the enrollment period, when was it for Master's students and Bachelor's students?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name (Bachelor, Master), c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrol",
        "prediction": "t3 t6 t7",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Degree_Programs Students Student_Enrolment",
        "real_label": "Degree_Programs Student_Enrolment",
        "topk_preds": [
            "Degree_Programs Students Student_Enrolment",
            "Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Student_Enrolment",
            "Departments Degree_Programs Students Student_Enrolment",
            "",
            "Courses Degree_Programs Student_Enrolment",
            "Courses Degree_Programs Students Student_Enrolment",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me which other information you know about the students in reverse alphabetical order., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me which other information you know about the students in reverse alphabetical order., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select t6.c11",
        "label": "select t6.c11",
        "score": true,
        "real_pred": "select Students.other_student_details",
        "real_label": "select Students.other_student_details",
        "topk_preds": [
            "select Students.other_student_details",
            "select Students.last_name, Students.first_name",
            "select Student_Enrolment_Courses.course_id, Students.permanent_address_id",
            "select Student_Enrolment_Courses.course_id, Students.first_name",
            "select Students.last_name, Students.cell_mobile_number",
            "select Students.other_student_details, Students.first_name",
            "select Students.date_first_registered, Students.date_left",
            "select Student_Enrolment_Courses.course_id, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me which other information you know about the students in reverse alphabetical order., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "Students Student_Enrolment",
            "Students Student_Enrolment_Courses",
            "",
            "",
            "Semesters Students",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What information do you have on the students that are in reverse alphabetical order please?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-NORMALIZED-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-NORMAL-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What information do you have on the students that are in reverse alphabetical order please?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c",
        "prediction": "select *",
        "label": "select t6.c11",
        "score": false,
        "real_pred": "select *",
        "real_label": "select Students.other_student_details",
        "topk_preds": [
            "select *",
            "select Students.current_address_id3, Students.current_address_id4",
            "select Students.last_name, Students.first_name",
            "select *, Students.first_name, Students.middle_name",
            "select Students.last_name, Students.first_name, Students.middle_name",
            "select Student_Enrolment_Courses.course_id, Students.first_name, Students.last_name",
            "select Student_Enrolment_Courses.course_id, Students.first_name, Students.middle_name",
            "select *, Students.first_name, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What information do you have on the students that are in reverse alphabetical order please?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "Students Student_Enrolment",
            "",
            "",
            "",
            "",
            "Students Student_Enrolment_Courses",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you give me some more information about the students in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_en",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you give me some more information about the students in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0",
        "prediction": "select *",
        "label": "select t6.c11",
        "score": false,
        "real_pred": "select *",
        "real_label": "select Students.other_student_details",
        "topk_preds": [
            "select *",
            "select Students.current_address_id3, Students.current_address_id4",
            "select Student_Enrolment_Courses.course_id, Students.first_name, Students.last_name",
            "select Student_Enrolment_Courses.course_id, Students.first_name, Students.middle_name",
            "select Students.last_name, Students.first_name",
            "select *, Students.first_name, Students.middle_name",
            "select Student_Enrolment_Courses.course_id, Students.first_name",
            "select Student_Enrolment_Courses.course_id, Students.permanent_address_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you give me some more information about the students in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "Students Student_Enrolment",
            "Students Student_Enrolment_Courses",
            "Semesters Students Student_Enrolment",
            "",
            "Semesters Students Student_Enrolment_Courses",
            "Semesters Students",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you provide more information on the students in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description (provident), c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY (SELECT-FROM-CHROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY(t6.c0)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you provide more information on the students in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description (provident), c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(",
        "prediction": "select *",
        "label": "select t6.c11",
        "score": false,
        "real_pred": "select *",
        "real_label": "select Students.other_student_details",
        "topk_preds": [
            "select *",
            "select Student_Enrolment_Courses.course_id, Students.first_name, Students.middle_name",
            "select Student_Enrolment_Courses.course_id, Students.first_name, Students.last_name",
            "select Students.current_address_id3, Students.current_address_id4",
            "select Student_Enrolment_Courses.course_id, Students.first_name",
            "select *, Students.first_name, Students.middle_name",
            "select Student_Enrolment_Courses.course_id, Students.permanent_address_id",
            "select Students.last_name, Students.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you provide more information on the students in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description (provident), c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "Students Student_Enrolment",
            "Students Student_Enrolment_Courses",
            "Semesters Students Student_Enrolment",
            "Semesters Students",
            "",
            "Semesters Students Student_Enrolment_Courses",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you tell me more information about students in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-CHROM-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you tell me more information about students in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student",
        "prediction": "select *",
        "label": "select t6.c11",
        "score": false,
        "real_pred": "select *",
        "real_label": "select Students.other_student_details",
        "topk_preds": [
            "select *",
            "select Students.last_name, Students.first_name",
            "select Students.current_address_id3, Students.current_address_id4",
            "select Student_Enrolment_Courses.course_id, Students.first_name, Students.last_name",
            "select Students.last_name, Students.first_name, Students.middle_name",
            "select Student_Enrolment_Courses.course_id, Students.first_name, Students.middle_name",
            "select *, Students.first_name, Students.middle_name",
            "select Students.current_address_id, Students.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you tell me more information about students in reverse alphabetical order?, database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Students",
        "real_label": "Students",
        "topk_preds": [
            "Students",
            "Students Student_Enrolment",
            "Students Student_Enrolment_Courses",
            "Semesters Students",
            "",
            "Courses Students",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Explain what the section h' means., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Explain what the section h' means., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment",
        "prediction": "select t4.c2",
        "label": "select t4.c3",
        "score": false,
        "real_pred": "select Sections.section_name",
        "real_label": "select Sections.section_description",
        "topk_preds": [
            "select Sections.section_name",
            "select Sections.course_id",
            "select Sections.section_description",
            "select Sections.section_id, Sections.section_description",
            "select Sections.other_details",
            "select t4.c5",
            "select Sections.section_id, Sections.section_name",
            "select t4.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Explain what the section h' means., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Sections",
        "real_label": "Sections",
        "topk_preds": [
            "Sections",
            "Student_Enrolment",
            "Degree_Programs Sections",
            "Degree_Programs Student_Enrolment",
            "Degree_Programs Transcripts",
            "Courses Student_Enrolment",
            "Student_Enrolment_Courses",
            "Transcripts"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give us information about section H., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give us information about section H., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "select *",
        "label": "select t4.c3",
        "score": false,
        "real_pred": "select *",
        "real_label": "select Sections.section_description",
        "topk_preds": [
            "select *",
            "select Sections.section_name",
            "select Sections.section_name, Sections.section_description",
            "select Sections.course_id, Sections.section_description",
            "select Sections.course_id, Sections.section_name",
            "select Sections.section_description, Sections.other_details",
            "select info(Sections.section_name)",
            "select Sections.section_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give us information about section H., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c1:",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Sections",
        "real_label": "Sections",
        "topk_preds": [
            "Sections",
            "Degree_Programs Sections",
            "Departments Sections",
            "Addresses Sections",
            "Courses Sections",
            "Courses Student_Enrolment",
            "Departments Student_Enrolment",
            "Degree_Programs Student_Enrolment"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Describe this section called h below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Describe this section called h below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "select t4.c3",
        "label": "select t4.c3",
        "score": true,
        "real_pred": "select Sections.section_description",
        "real_label": "select Sections.section_description",
        "topk_preds": [
            "select Sections.section_description",
            "select Sections.section_name, Sections.section_description",
            "select Sections.course_id, Sections.section_description",
            "select Sections.section_description, Sections.section_name",
            "select Sections.section_description, Sections.other_details",
            "select Sections.course_id, Sections.section_name",
            "select Sections.section_description, Sections.section_id",
            "select Sections.section_description, t4.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Describe this section called h below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Sections",
        "real_label": "Sections",
        "topk_preds": [
            "Sections",
            "Departments Sections",
            "Degree_Programs Sections",
            "Addresses Sections",
            "Addresses Courses Departments Sections",
            "Addresses Departments Sections",
            "Addresses Courses Sections",
            "Addresses Courses Degree_Programs Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please describe the section named h below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, ",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please describe the section named h below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_",
        "prediction": "select t4.c3",
        "label": "select t4.c3",
        "score": true,
        "real_pred": "select Sections.section_description",
        "real_label": "select Sections.section_description",
        "topk_preds": [
            "select Sections.section_description",
            "select Sections.section_name, Sections.section_description",
            "select Sections.course_id, Sections.section_description",
            "select Sections.section_description, Sections.section_name",
            "select Sections.section_description, Sections.other_details",
            "select Sections.course_id, Sections.section_name",
            "select t4.c6, t4.c7",
            "select Sections.section_description, Sections.section_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please describe the section named h below., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id, c",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Sections",
        "real_label": "Sections",
        "topk_preds": [
            "Sections",
            "",
            "Departments Sections",
            "Degree_Programs Sections",
            "Addresses Courses Departments Sections",
            "Addresses Departments Sections",
            "Addresses Sections",
            "Addresses Courses Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me an information about the section named h., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me an information about the section named h., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrol",
        "prediction": "select t4.c3",
        "label": "select t4.c3",
        "score": true,
        "real_pred": "select Sections.section_description",
        "real_label": "select Sections.section_description",
        "topk_preds": [
            "select Sections.section_description",
            "select Sections.section_description, Sections.other_details",
            "select Sections.section_name, Sections.section_description",
            "select Sections.section_description, Sections.section_name",
            "select Sections.course_id, Sections.section_description",
            "select Sections.section_name",
            "select Sections.course_id, Sections.section_name",
            "select Sections.section_description-, Sections.other_details"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me an information about the section named h., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country, c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student_enrolment(c0: student_enrolment_id,",
        "prediction": "t4",
        "label": "t4",
        "score": true,
        "real_pred": "Sections",
        "real_label": "Sections",
        "topk_preds": [
            "Sections",
            "Departments Sections",
            "Degree_Programs Sections",
            "Addresses Sections",
            "Addresses Departments Sections",
            "Addresses Courses Sections",
            "Addresses Courses Departments Sections",
            "Courses Sections"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the first names of students who reside in the country Haiti or have the mobile number 09700166582., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country (Haiti), c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7:",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the first names of students who reside in the country Haiti or have the mobile number 09700166582., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country (Haiti), c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details).",
        "prediction": "select t6.c3",
        "label": "select t6.c3",
        "score": true,
        "real_pred": "select Students.first_name",
        "real_label": "select Students.first_name",
        "topk_preds": [
            "select Students.first_name",
            "select Students.first_name, Students.last_name",
            "select Students.student_id, Students.first_name",
            "select Students.first_name, Students.middle_name, Students.cell_mobile_number",
            "select Students.first_name, Students.last_name, Students.cell_mobile_number",
            "select Students.first_name, Students.middle_name",
            "select Students.first_name, Students.middle_name, Students.last_name",
            "select Students.first_name, Students.cell_mobile_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the first names of students who reside in the country Haiti or have the mobile number 09700166582., database: Database: student_transcripts_tracking. t0: addresses(c0: address_id, c1: line_1, c2: line_2, c3: line_3, c4: city, c5: zip_postcode, c6: state_province_county, c7: country (Haiti), c8: other_address_details). t1: courses(c0: course_id, c1: course_name, c2: course_description, c3: other_details). t2: departments(c0: department_id, c1: department_name, c2: department_description, c3: other_details). t3: degree_programs(c0: degree_program_id, c1: department_id, c2: degree_summary_name, c3: degree_summary_description, c4: other_details). t4: sections(c0: section_id, c1: course_id, c2: section_name, c3: section_description, c4: other_details). t5: semesters(c0: semester_id, c1: semester_name, c2: semester_description, c3: other_details). t6: students(c0: student_id, c1: current_address_id, c2: permanent_address_id, c3: first_name, c4: middle_name, c5: last_name, c6: cell_mobile_number, c7: email_address, c8: ssn, c9: date_first_registered, c10: date_left, c11: other_student_details). t7: student",
        "prediction": "t0 t6",
        "label": "t0 t6",
        "score": true,
        "real_pred": "Addresses Students",
        "real_label": "Addresses Students",
        "topk_preds": [
            "Addresses Students",
            "Addresses Students Student_Enrolment",
            "",
            "Addresses Semesters Students",
            "",
            "Addresses Students Student_Enrolment_Courses",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you help me to find the package options and the name of the series of the channel which supports HDTV?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you help me to find the package options and the name of the series of the channel which supports HDTV?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8, t0.c1",
        "label": "select t0.c8, t0.c1",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "real_label": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.series_name",
            "select TV_Channel.Pay_per_view_PPV, TV_Channel.series_name",
            "select t2.c8, TV_Channel.series_name",
            "select t3.c8, TV_Channel.series_name",
            "select TV_Channel.Package_Option, TV_Channel.series_name,",
            "select TV_Channel.Package_Option, TV_Channel.series_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you help me to find the package options and the name of the series of the channel which supports HDTV?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "TV_Channel TV_series",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me the name of the series supported by high-definition television channel, together with its package options., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me the name of the series supported by high-definition television channel, together with its package options., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c1, t0.c8",
        "label": "select t0.c8, t0.c1",
        "score": false,
        "real_pred": "select TV_Channel.series_name, TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.id, TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.series_name.c1, TV_Channel.Package_Option",
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.series_name, TV_Channel.Hight_definition_TV, TV_Channel.Package_Option",
            "select TV_series.Episode, TV_Channel.Package_Option",
            "select Cartoon.Title, TV_Channel.Package_Option",
            "select TV_Channel.series_name, TV_Channel.Package_Option, TV_series.Episode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me the name of the series supported by high-definition television channel, together with its package options., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t1",
        "label": "t0",
        "score": false,
        "real_pred": "TV_Channel TV_series",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel TV_series",
            "",
            "",
            "",
            "",
            "TV_Channel",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the release date for the TV Series with episode \"A love of a lifetime?\", database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the release date for the TV Series with episode \"A love of a lifetime?\", database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select TV_series.Air_Date",
        "real_label": "select TV_series.Air_Date",
        "topk_preds": [
            "select TV_series.Air_Date",
            "select TV_series.id, TV_series.Air_Date",
            "select TV_series.Rating",
            "select TV_series.18_49_Rating_Share",
            "select TV_series.Air_Date (or TV_series.Rating)",
            "select TV_series.Air_Date-",
            "select TV_series.Air_Date, TV_series.Rating",
            "select TV_series.id, TV_series.Rating"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the release date for the TV Series with episode \"A love of a lifetime?\", database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which is the release date of the TV series with with episode title A Love of a Lifetime?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (t1.c2)",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which is the release date of the TV series with with episode title A Love of a Lifetime?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select TV_series.Air_Date",
        "real_label": "select TV_series.Air_Date",
        "topk_preds": [
            "select TV_series.Air_Date",
            "select TV_series.id, TV_series.Air_Date",
            "select TV_series.Air_Date (or TV_series.Rating)",
            "select TV_series.Air_Date, TV_series.Rating",
            "select TV_series.id, TV_series.Episode",
            "select TV_series.Air_Date-",
            "select TV_series.id, TV_series.Air_Date2",
            "select TV_series.id, TV_series.Rating"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which is the release date of the TV series with with episode title A Love of a Lifetime?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode (A Love of a Lifetime), c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What kind of program are there on Sky Radio?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What kind of program are there on Sky Radio?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select TV_Channel.Content",
        "real_label": "select TV_Channel.Content",
        "topk_preds": [
            "select TV_Channel.Content",
            "select TV_series.Share",
            "select TV_series.Episode",
            "select Cartoon.Title",
            "select Cartoon.Title, TV_Channel.Country",
            "select Cartoon.Title, TV_Channel.Content",
            "select TV_series.Episode, TV_Channel.Country",
            "select TV_series.Episode, TV_series.Air_Date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What kind of program are there on Sky Radio?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "TV_Channel TV_series Cartoon",
            "",
            "TV_Channel Cartoon",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What can be found on Sky Radio?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What can be found on Sky Radio?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1",
        "label": "select t0.c4",
        "score": false,
        "real_pred": "select TV_series.Episode",
        "real_label": "select TV_Channel.Content",
        "topk_preds": [
            "select TV_series.Episode",
            "select Cartoon.Title",
            "select TV_series.Episode, TV_series.Air_Date",
            "select Cartoon.Title, TV_Channel.Country",
            "select TV_series.Episode, TV_Channel.Country",
            "select Cartoon.Title, Cartoon.Directed_by",
            "select Cartoon.Title, TV_series.Air_Date",
            "select TV_series.Episode, TV_series.Rating"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What can be found on Sky Radio?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which channel has Sky Radio in its name, and what programme do they broadcast there?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which channel has Sky Radio in its name, and what programme do they broadcast there?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c0, t0.c4",
        "label": "select t0.c4",
        "score": false,
        "real_pred": "select TV_Channel.id, TV_Channel.Content",
        "real_label": "select TV_Channel.Content",
        "topk_preds": [
            "select TV_Channel.id, TV_Channel.Content",
            "select TV_Channel.series_name, TV_Channel.Content",
            "select TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.Content, TV_Channel.id",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Hight_definition_TV",
            "select TV_Channel.id, TV_Channel.series_name",
            "select TV_Channel.Content, TV_series.Channel",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which channel has Sky Radio in its name, and what programme do they broadcast there?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Provide me with programs of the television channel called Sky Radio., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Provide me with programs of the television channel called Sky Radio., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t1.c1",
        "label": "select t0.c4",
        "score": false,
        "real_pred": "select TV_series.Episode",
        "real_label": "select TV_Channel.Content",
        "topk_preds": [
            "select TV_series.Episode",
            "select TV_series.Episode, TV_series.Air_Date",
            "select TV_series.Episode, TV_Channel.Country",
            "select TV_series.Episode, TV_series.Rating",
            "select TV_series.Episode, TV_Channel.Language",
            "select TV_series.Episode, Cartoon.Directed_by",
            "select TV_series.Episode, TV_series.Share",
            "select TV_series.Episode, TV_series.Viewers_m"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Provide me with programs of the television channel called Sky Radio., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t1",
        "label": "t0",
        "score": false,
        "real_pred": "TV_Channel TV_series",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel TV_series",
            "",
            "",
            "",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the names of all cartoons in alphabetical order., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM-ORDER BY",
            "SELECT-FROM-ALPHABETICAL-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the names of all cartoons in alphabetical order., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.Channel",
            "select Cartoon.Title, Cartoon.Directed_by",
            "select Cartoon.Title, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.Production_code",
            "select Cartoon.Title, t2.c8",
            "select Cartoon.Title, t2.c7",
            "select Cartoon.Title, Cartoon.Original_air_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the names of all cartoons in alphabetical order., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me a list of the titles and the directors of cartoons ordered by their original airing dates., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t2.c1, t2.c2",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY TI2.C1, t2.c2",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY (t2.c1), SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me a list of the titles and the directors of cartoons ordered by their original airing dates., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c1, t2.c2",
        "label": "select t2.c1, t2.c2",
        "score": true,
        "real_pred": "select Cartoon.Title, Cartoon.Directed_by",
        "real_label": "select Cartoon.Title, Cartoon.Directed_by",
        "topk_preds": [
            "select Cartoon.Title, Cartoon.Directed_by",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.Original_air_date",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.id",
            "select Cartoon.Title, Cartoon.Directed_by - Cartoon.Original_air_date",
            "select Cartoon.Title.c1, Cartoon.Directed_by",
            "select Cartoon.Title, Cartoon.Directed_by (ordered by",
            "select Cartoon.Title, Cartoon.Directed_by, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.Directed_by (ORDER BY"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me a list of the titles and the directors of cartoons ordered by their original airing dates., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the names of the cartoons sorted alphabetically., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM -ORDER BY",
            "SELECT-FROM\u2013ORDER BY",
            "SELECT-FROM- ORDER BY",
            "SELECTFROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the names of the cartoons sorted alphabetically., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.Channel",
            "select Cartoon.Title, Cartoon.Production_code",
            "select Cartoon.Title, t2.c8",
            "select Cartoon.Title, t2.c7",
            "select Cartoon.Title, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.Directed_by",
            "select Cartoon.Title, Cartoon.Original_air_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the names of the cartoons sorted alphabetically., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many comics did Joseph Kuhr write during his career?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by (Joseph Kuhr), c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE.GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many comics did Joseph Kuhr write during his career?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by (Joseph Kuhr), c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Cartoon.Written_by",
            "select count(*), Cartoon.id",
            "select count(*), Cartoon.Title",
            "select Cartoon.Written_by, count(*)",
            "select count(*) during Cartoon.Written_by",
            "select count(*), Cartoon.Production_code",
            "select count(*), Cartoon.Original_air_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many comics did Joseph Kuhr write during his career?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by (Joseph Kuhr), c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "TV_series Cartoon",
            "",
            "TV_Channel Cartoon",
            "",
            "TV_Channel TV_series Cartoon",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many cartoons did Joseph Kuhr write?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by (Joseph Kuhr), c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many cartoons did Joseph Kuhr write?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by (Joseph Kuhr), c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), Cartoon.Written_by",
            "select count(*), Cartoon.id",
            "select count(*), Cartoon.Title",
            "select count(*), Cartoon.Original_air_date",
            "select count(*), Cartoon.Production_code",
            "select count(*), Cartoon.Directed_by",
            "select count(*), Cartoon.Channel"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many cartoons did Joseph Kuhr write?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by (Joseph Kuhr), c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "TV_series Cartoon",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Here's the list of all the cartoons made under the direction of Ben Jones or Brandon Vietti., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Brandon Vietti, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Here's the list of all the cartoons made under the direction of Ben Jones or Brandon Vietti., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Brandon Vietti, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.Directed_by",
            "select Cartoon.Title de, Cartoon.Directed_by",
            "select Cartoon.id, Cartoon.Title",
            "select Cartoon.Title, Cartoon.Channel",
            "select Cartoon.Title, Cartoon.id",
            "select Cartoon.Title, t2.c8",
            "select Cartoon.Title, Cartoon.Written_by"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Here's the list of all the cartoons made under the direction of Ben Jones or Brandon Vietti., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Brandon Vietti, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the names of all the cartoons made by Ben Jones and Brandon Vietti?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Brandon Vietti, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WITH-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE-",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE ",
            "SELECT-FROM-WHERE\u2013INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-2-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the names of all the cartoons made by Ben Jones and Brandon Vietti?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Brandon Vietti, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.Directed_by",
            "select Cartoon.Title, Cartoon.Channel",
            "select Cartoon.Title, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.Production_code",
            "select Cartoon.Title, Cartoon.Original_air_date",
            "select Cartoon.Title, Cartoon.id",
            "select Cartoon.Title (http://Cartoon.Title)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the names of all the cartoons made by Ben Jones and Brandon Vietti?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Brandon Vietti, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the full titles of all the cartoons by directors Brandon Nguyen or Benjamin Jones., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the full titles of all the cartoons by directors Brandon Nguyen or Benjamin Jones., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c1, t2.c3",
        "label": "select t2.c1",
        "score": false,
        "real_pred": "select Cartoon.Title, Cartoon.Written_by",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.Directed_by",
            "select Cartoon.Title, Cartoon.Channel",
            "select Cartoon.Title, Cartoon.Original_air_date",
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.Production_code",
            "select Cartoon.Title, Cartoon.Title",
            "select Cartoon.Title+, Cartoon.Written_by"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the full titles of all the cartoons by directors Brandon Nguyen or Benjamin Jones., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the title of each cartoon made either by director named either Ben Jones or Brandon Vietti., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Brandon Vietti, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the title of each cartoon made either by director named either Ben Jones or Brandon Vietti., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Brandon Vietti, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select Cartoon.Title",
        "real_label": "select Cartoon.Title",
        "topk_preds": [
            "select Cartoon.Title",
            "select Cartoon.Title, Cartoon.Directed_by",
            "select Cartoon.Title, Cartoon.Channel",
            "select Cartoon.Title, Cartoon.id",
            "select Cartoon.Title, t2.c8",
            "select Cartoon.Title, Cartoon.Production_code",
            "select Cartoon.Title, Cartoon.Written_by",
            "select Cartoon.Title, Cartoon.Original_air_date"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the title of each cartoon made either by director named either Ben Jones or Brandon Vietti., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Brandon Vietti, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "Cartoon",
        "real_label": "Cartoon",
        "topk_preds": [
            "Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the package selection for Sky Radio?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the package selection for Sky Radio?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.Package_Option, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Package_Option, t0.c9",
            "select TV_Channel.Package_Option, TV_Channel.Language",
            "select TV_Channel.Package_Option, TV_Channel.Content"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the package selection for Sky Radio?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What kind of package does 'Sky Radio' come under?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SQL-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SQL-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What kind of package does 'Sky Radio' come under?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select distinct TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.Package_Option, t0.c9",
            "select TV_Channel.Package_Option, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.Package_Option, TV_Channel.Language",
            "select TV_Channel.Package_Option, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Package_Option, TV_Channel.series_name3"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What kind of package does 'Sky Radio' come under?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which package does the TV channel Sky Radio come under?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which package does the TV channel Sky Radio come under?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.Package_Option, TV_Channel.Pay_per_view_PPV",
            "select TV_Channel.Package_Option, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Package_Option, t0.c9",
            "select TV_Channel.Package_Option, TV_Channel.Language",
            "select TV_Channel.Package_Option, TV_Channel.Content",
            "select TV_Channel.Package_Option, TV_Channel.Hight_definition_TV"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which package does the TV channel Sky Radio come under?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "TV_Channel TV_series Cartoon",
            "",
            "TV_Channel TV_series",
            "",
            "",
            "TV_Channel Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which channel has this series called Sky Radio? Explain which packages they offer., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which channel has this series called Sky Radio? Explain which packages they offer., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, TV_series.Channel",
            "select TV_Channel.id, TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, TV_Channel.id",
            "select TV_Channel.Country, TV_Channel.Package_Option",
            "select TV_Channel.Hight_definition_TV, TV_Channel.Package_Option"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which channel has this series called Sky Radio? Explain which packages they offer., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name (Sky Radio), c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t1",
        "label": "t0",
        "score": false,
        "real_pred": "TV_Channel TV_series",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel TV_series",
            "TV_Channel",
            "",
            "",
            "TV_Channel Cartoon",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The maximum and minimum percentage for the TV series, please tell me., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM t1.c3, SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-T1.C3, SELECT-FROM",
            "SELECT-FROM (t1.c3), min(t1.c4)",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The maximum and minimum percentage for the TV series, please tell me., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select max(t1.c4), min(t1.c4)",
        "label": "select max(t1.c4), min(t1.c4)",
        "score": true,
        "real_pred": "select max(TV_series.Share), min(TV_series.Share)",
        "real_label": "select max(TV_series.Share), min(TV_series.Share)",
        "topk_preds": [
            "select max(TV_series.Share), min(TV_series.Share)",
            "select max(TV_series.Rating), min(TV_series.Rating)",
            "select max(TV_series.Rating), min(TV_series.Share)",
            "select max(TV_series.18_49_Rating_Share), min(TV_series.18_49_Rating_Share)",
            "select max(TV_series.Viewers_m), min(TV_series.Viewers_m)",
            "select max(TV_series.Channel), min(TV_series.Channel)",
            "select max(TV_series.Weekly_Rank), min(TV_series.Weekly_Rank)",
            "select max(Cartoon.Original_air_date), min(Cartoon.Original_air_date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The maximum and minimum percentage for the TV series, please tell me., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you list the highest and lowest percentage achieved for TV show?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-T1.C3, max(t1.c4), min(t1.c4)",
            "SELECT-FROM t1.c3, max(t1.c4), min(t1.c4)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-T1.C3, max(t1.c4), min(t1.c3)",
            "SELECT-FROM t1.c3, max(t1.c4), min(t1.c3)",
            "SELECT-FROM (t1.c3), max(t1.c3), min(t1.c3)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you list the highest and lowest percentage achieved for TV show?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select max(t1.c3), min(t1.c3)",
        "label": "select max(t1.c4), min(t1.c4)",
        "score": false,
        "real_pred": "select max(TV_series.Rating), min(TV_series.Rating)",
        "real_label": "select max(TV_series.Share), min(TV_series.Share)",
        "topk_preds": [
            "select max(TV_series.Rating), min(TV_series.Rating)",
            "select max(TV_series.Share), min(TV_series.Share)",
            "select max(TV_series.Rating), min(TV_series.Share)",
            "select max(TV_series.18_49_Rating_Share), min(TV_series.18_49_Rating_Share)",
            "select max(TV_series.Viewers_m), min(TV_series.Viewers_m)",
            "select max(Cartoon.Written_by), min(Cartoon.Written_by)",
            "select max(TV_series.Channel), min(TV_series.Channel)",
            "select max(TV_series.Air_Date), min(TV_series.Air_Date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you list the highest and lowest percentage achieved for TV show?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the highest and lowest percentage that could be for TV show?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the highest and lowest percentage that could be for TV show?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select max(t1.c4), min(t1.c4)",
        "label": "select max(t1.c4), min(t1.c4)",
        "score": true,
        "real_pred": "select max(TV_series.Share), min(TV_series.Share)",
        "real_label": "select max(TV_series.Share), min(TV_series.Share)",
        "topk_preds": [
            "select max(TV_series.Share), min(TV_series.Share)",
            "select max(TV_series.Rating), min(TV_series.Rating)",
            "select max(TV_series.Rating), min(TV_series.Share)",
            "select max(TV_series.18_49_Rating_Share), min(TV_series.18_49_Rating_Share)",
            "select max(TV_series.Viewers_m), min(TV_series.Viewers_m)",
            "select max(Cartoon.Original_air_date), min(Cartoon.Original_air_date)",
            "select max(TV_series.Channel), min(TV_series.Channel)",
            "select max(TV_series.18_49_Rating_Share), min(TV_series.Share)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the highest and lowest percentage that could be for TV show?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the highest and lowest percentage for the TV show?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM t1.c3, max(t1.c4), min(t1.c4)",
            "SELECT-FROM-T1.C3, max(t1.c4), min(t1.c4)",
            "SELECT-FROM-T1.c3, max(t1.c4), min(t1.c4)",
            "SELECT-FROM t1.c3, max(t1.c4), min(t1.c3)",
            "SELECT-FROM-T1.C3, max(t1.c4), min(t1.c3)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the highest and lowest percentage for the TV show?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select max(t1.c3), min(t1.c3)",
        "label": "select max(t1.c4), min(t1.c4)",
        "score": false,
        "real_pred": "select max(TV_series.Rating), min(TV_series.Rating)",
        "real_label": "select max(TV_series.Share), min(TV_series.Share)",
        "topk_preds": [
            "select max(TV_series.Rating), min(TV_series.Rating)",
            "select max(TV_series.Share), min(TV_series.Share)",
            "select max(TV_series.Rating), min(TV_series.Share)",
            "select max(TV_series.18_49_Rating_Share), min(TV_series.18_49_Rating_Share)",
            "select max(TV_series.Viewers_m), min(TV_series.Viewers_m)",
            "select max(TV_series.Channel), min(TV_series.Channel)",
            "select max(Cartoon.Written_by), min(Cartoon.Written_by)",
            "select max(TV_series.Air_Date), min(TV_series.Air_Date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the highest and lowest percentage for the TV show?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "TV_series",
        "real_label": "TV_series",
        "topk_preds": [
            "TV_series",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Choose the package choice together with the series name of the television channel which broadcasts HDTV., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Choose the package choice together with the series name of the television channel which broadcasts HDTV., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8, t0.c1",
        "label": "select t0.c8, t0.c1",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "real_label": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.series_name",
            "select TV_Channel.Pay_per_view_PPV, TV_Channel.series_name",
            "select TV_Channel.Hight_definition_TV, TV_Channel.series_name",
            "select TV_Channel.Package_Option, TV_Channel.series_name,",
            "select TV_Channel.id, TV_Channel.series_name",
            "select t2.c8, TV_Channel.series_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Choose the package choice together with the series name of the television channel which broadcasts HDTV., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Let us look for the package selection and series name for the HD TV channel., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Let us look for the package selection and series name for the HD TV channel., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8, t0.c1",
        "label": "select t0.c8, t0.c1",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "real_label": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.series_name",
            "select TV_Channel.Pay_per_view_PPV, TV_Channel.series_name",
            "select TV_Channel.Hight_definition_TV, TV_Channel.series_name",
            "select t0.c9, TV_Channel.series_name",
            "select t2.c8, TV_Channel.series_name",
            "select TV_Channel.Package_Option, TV_Channel.series_name,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Let us look for the package selection and series name for the HD TV channel., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the package name and series of TV channel which uses high definition video format?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the package name and series of TV channel which uses high definition video format?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8, t0.c1",
        "label": "select t0.c8, t0.c1",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "real_label": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.Pay_per_view_PPV, TV_Channel.series_name",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.series_name",
            "select TV_Channel.Hight_definition_TV, TV_Channel.series_name",
            "select t0.c series, TV_Channel.Package_Option"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the package name and series of TV channel which uses high definition video format?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which TV channel has high-definition TVs? Please find the package option and the series name of this channel., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which TV channel has high-definition TVs? Please find the package option and the series name of this channel., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8, t0.c1",
        "label": "select t0.c8, t0.c1",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "real_label": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.id, TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.series_name",
            "select TV_Channel.Pay_per_view_PPV, TV_Channel.series_name",
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.Hight_definition_TV, TV_Channel.series_name",
            "select TV_Channel.Package_Option, TV_Channel.series_name, TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which TV channel has high-definition TVs? Please find the package option and the series name of this channel., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option (Option)). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the package selection and television name of the TV channel that is high definition., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the package selection and television name of the TV channel that is high definition., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8, t0.c1",
        "label": "select t0.c8, t0.c1",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "real_label": "select TV_Channel.Package_Option, TV_Channel.series_name",
        "topk_preds": [
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.Package_Option, TV_Channel.Hight_definition_TV",
            "select TV_Channel.Package_Option, TV_Channel.Country",
            "select TV_Channel.Package_Option, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Package_Option, TV_Channel.Content",
            "select TV_Channel.series_name, TV_Channel.Package_Option",
            "select TV_Channel.Hight_definition_TV, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, TV_Channel.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the package selection and television name of the TV channel that is high definition., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the name and country of the television channel showing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Michael Chang, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COLLECTION-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COLLECTION-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-JOINT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-JOINT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the name and country of the television channel showing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Michael Chang, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c1, t0.c2",
        "label": "select t0.c1, t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.series_name, TV_Channel.Country",
        "real_label": "select TV_Channel.series_name, TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.series_name, TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.series_name",
            "select TV_Channel.series_name, TV_Channel.Country, Cartoon.Channel",
            "select TV_Channel.series_name/series, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Country, TV_Channel.Language",
            "select t0.c series_name, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Country",
            "select Cartoon.Channel, TV_Channel.Country"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the name and country of the television channel showing some cartoons directed by Ben Jones and Michael Chang?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Michael Chang, Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For tv channels that don't use English, please tell me their pixel aspect ratio and country., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language (English), c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For tv channels that don't use English, please tell me their pixel aspect ratio and country., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language (English), c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c5, t0.c2",
        "label": "select t0.c5, t0.c2",
        "score": true,
        "real_pred": "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country",
        "real_label": "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country",
            "select TV_Channel.Language, TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country",
            "select TV_Channel.Country, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Pixel_aspect_ratio_PAR.c5, TV_Channel.Country",
            "select TV_Channel.series_name, TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country, TV_Channel.Language",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For tv channels that don't use English, please tell me their pixel aspect ratio and country., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language (English), c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like you to search for the country and the pixel aspect ratio of the channels which are not using the English language., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language (English), c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like you to search for the country and the pixel aspect ratio of the channels which are not using the English language., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language (English), c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c2, t0.c5",
        "label": "select t0.c5, t0.c2",
        "score": false,
        "real_pred": "select TV_Channel.Country, TV_Channel.Pixel_aspect_ratio_PAR",
        "real_label": "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Country, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Country.c3, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Language, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Country, TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Language",
            "select TV_Channel.series_name, TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Country, TV_Channel.Pixel_aspect_ratio_PAR - TV_Channel.Language",
            "select TV_Channel.Country, TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Hight_definition_TV",
            "select TV_Channel.Country.c3, TV_Channel.Pixel_aspect_ratio_PAR."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like you to search for the country and the pixel aspect ratio of the channels which are not using the English language., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language (English), c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the image ratio of all television stations which does not speak English, and its country of origin is located?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language (English), c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the image ratio of all television stations which does not speak English, and its country of origin is located?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language (English), c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c5",
        "label": "select t0.c5, t0.c2",
        "score": false,
        "real_pred": "select TV_Channel.Pixel_aspect_ratio_PAR",
        "real_label": "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country",
        "topk_preds": [
            "select TV_Channel.Pixel_aspect_ratio_PAR",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country",
            "select TV_Channel.id, TV_Channel.Pixel_aspect_ratio_PAR",
            "select avg(TV_Channel.Pixel_aspect_ratio_PAR)",
            "select TV_Channel.Pixel_aspect_ratio_PAR-par",
            "select TV_Channel.Pixel_aspect_ratio_PAR.c5",
            "select TV_Channel.id, TV_Channel.Country",
            "select TV_Channel.Pixel_aspect_ratio_PAR-aspect_ratio_par"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the image ratio of all television stations which does not speak English, and its country of origin is located?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language (English), c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by, c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "TV_Channel",
        "real_label": "TV_Channel",
        "topk_preds": [
            "TV_Channel",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For The TV Channel That Do Not Have Any Cartoon Directed By Ben Jones Please Enter Packages Below., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For The TV Channel That Do Not Have Any Cartoon Directed By Ben Jones Please Enter Packages Below., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.id, TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.Channel",
            "select TV_Channel.Package_Option, Cartoon.Title",
            "select TV_Channel.Package_Option, Cartoon.id",
            "select TV_Channel.Package_Option, t2.c8",
            "select TV_Channel.Package_Option, TV_Channel.series_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For The TV Channel That Do Not Have Any Cartoon Directed By Ben Jones Please Enter Packages Below., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "TV_Channel TV_series Cartoon",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the package types of all TV channels which are not showing cartoons by director Ben Jones., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-ESE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM_EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the package types of all TV channels which are not showing cartoons by director Ben Jones., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select distinct TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.Hight_definition_TV, TV_Channel.Package_Option",
            "select TV_Channel.Pay_per_view_PPV, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.Channel",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Hight_definition_TV",
            "select TV_Channel.Package_Option, TV_Channel.Pay_per_view_PPV"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the package types of all TV channels which are not showing cartoons by director Ben Jones., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "TV_Channel TV_series Cartoon",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the packages for all the channels of those that do not play cartoons directed by Ben Jones?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM\u2013EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the packages for all the channels of those that do not play cartoons directed by Ben Jones?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.Channel",
            "select TV_Channel.Pay_per_view_PPV, TV_Channel.Package_Option",
            "select TV_Channel.Hight_definition_TV, TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Hight_definition_TV",
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select TV_Channel.Package_Option, TV_Channel.Pixel_aspect_ratio_PAR"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the packages for all the channels of those that do not play cartoons directed by Ben Jones?, database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The following tv channels don't play any cartoon directed by Ben Jones. Enter the packages., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE.",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE (t0.c8)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The following tv channels don't play any cartoon directed by Ben Jones. Enter the packages., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Pay_per_view_PPV, TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.id, TV_Channel.Package_Option",
            "select TV_Channel.Hight_definition_TV, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.Channel",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Hight_definition_TV",
            "select TV_Channel.Package_Option, t2.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The following tv channels don't play any cartoon directed by Ben Jones. Enter the packages., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the available packages for TV channels that do not show cartoons directed by Ben Jones., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-AVOID-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM- EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROME-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-SEE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the available packages for TV channels that do not show cartoons directed by Ben Jones., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "select t0.c8",
        "label": "select t0.c8",
        "score": true,
        "real_pred": "select TV_Channel.Package_Option",
        "real_label": "select TV_Channel.Package_Option",
        "topk_preds": [
            "select TV_Channel.Package_Option",
            "select TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.Channel",
            "select TV_Channel.Pay_per_view_PPV, TV_Channel.Package_Option",
            "select available TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, TV_Channel.series_name",
            "select distinct TV_Channel.Package_Option",
            "select TV_Channel.Package_Option, Cartoon.Title"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the available packages for TV channels that do not show cartoons directed by Ben Jones., database: Database: tvshow. t0: tv_channel(c0: id, c1: series_name, c2: country, c3: language, c4: content, c5: pixel_aspect_ratio_par, c6: hight_definition_tv, c7: pay_per_view_ppv, c8: package_option). t1: tv_series(c0: id, c1: episode, c2: air_date, c3: rating, c4: share, c5: 18_49_rating_share, c6: viewers_m, c7: weekly_rank, c8: channel). t2: cartoon(c0: id, c1: title, c2: directed_by (Ben Jones), c3: written_by, c4: original_air_date, c5: production_code, c6: channel).",
        "prediction": "t0 t2",
        "label": "t0 t2",
        "score": true,
        "real_pred": "TV_Channel Cartoon",
        "real_label": "TV_Channel Cartoon",
        "topk_preds": [
            "TV_Channel Cartoon",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to see the names of poker players who've earned more than \u00a3300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to see the names of poker players who've earned more than \u00a3300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, people.Nationality",
            "select people.Name, t1.c5",
            "select people.Name, people.People_ID",
            "select people.Name, poker_player.Best_Finish"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to see the names of poker players who've earned more than \u00a3300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list poker players whose total winnings amount to more than 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list poker players whose total winnings amount to more than 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.Poker_Player_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, sum(poker_player.Earnings)",
            "select poker_player.People_ID",
            "select poker_player.Poker_Player_ID, poker_player.People_ID",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Poker_Player_ID, poker_player.Earnings",
            "select poker_player.People_ID, poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, poker_player.Final_Table_Made"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list poker players whose total winnings amount to more than 300000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which poker player's total winnings amount to more than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAMMA-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-GAMMA-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which poker player's total winnings amount to more than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.Poker_Player_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, sum(poker_player.Earnings)",
            "select poker_player.Poker_Player_ID, poker_player.Earnings",
            "select poker_player.People_ID",
            "select poker_player.Poker_Player_ID If sum(poker_player.Earnings)",
            "select poker_player.Poker_Player_ID, poker_player.Earnings",
            "select poker_player.Poker_Player_ID, sum(poker_player.Earnings)",
            "select poker_player.Poker_Player_ID If poker_player.Earnings"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which poker player's total winnings amount to more than 300000?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list down the amount of money that poker players earned in descending order., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (SELECT-FROM-GROUP BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM\u2013ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list down the amount of money that poker players earned in descending order., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select poker_player.Earnings",
        "real_label": "select poker_player.Earnings",
        "topk_preds": [
            "select poker_player.Earnings",
            "select sum(poker_player.Earnings), poker_player.Poker_Player_ID",
            "select sum(poker_player.Earnings), t0.c6",
            "select sum(poker_player.Earnings), poker_player.Money_Rank",
            "select sum(poker_player.Earnings), poker_player.People_ID",
            "select sum(poker_player.Earnings), t0.c7",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select sum(poker_player.Earnings), poker_player.Final_Table_Made"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list down the amount of money that poker players earned in descending order., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the income of poker players, ranked descending by amount., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (t0.c5)",
            "SELECT-FROM-ORDER BY t0.c5",
            "SELECT-FROM-ORDER BY t0",
            "SELECT-FROM-ORDER BY (TI0.c5)",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the income of poker players, ranked descending by amount., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select poker_player.Earnings",
        "real_label": "select poker_player.Earnings",
        "topk_preds": [
            "select poker_player.Earnings",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Earnings-ORDER BY",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Earnings--ORDER BY",
            "select poker_player.Earnings-ordered",
            "select poker_player.Earnings, t0.c6",
            "select poker_player.Earnings-ordered"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the income of poker players, ranked descending by amount., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the common nations of at least two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHERING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the common nations of at least two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, people.Name",
            "select people.Nationality, min(people.Nationality)",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, at least-people.Name",
            "select people.Nationality, people.People_ID",
            "select people.Nationality, min(people.Name)",
            "select people.Nationality, min(people.Height)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the common nations of at least two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are countries which exist at least two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSIST-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSERT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are countries which exist at least two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, count(*)",
            "select people.Nationality, min(people.Name)",
            "select people.Nationality, people.Name",
            "select people.Nationality, min(people.Height)",
            "select people.Nationality, at least two people.Name",
            "select count(*), people.Nationality",
            "select people.Nationality, at least two people.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are countries which exist at least two people?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the country where the largest group is from?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the country where the largest group is from?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1",
        "label": "select t1.c1",
        "score": true,
        "real_pred": "select people.Nationality",
        "real_label": "select people.Nationality",
        "topk_preds": [
            "select people.Nationality",
            "select people.Nationality, people.Name",
            "select people.Nationality, people.Birth_Date",
            "select people.Nationality, people.Name, people.Birth_Date",
            "select people.Nationality, people.Height",
            "select people.Nationality, people.Birth_Date, people.Height",
            "select people.Nationality, people.Name, max(people.Height)",
            "select people.Nationality, people.Name, min(people.Height)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the country where the largest group is from?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the poker players winnings in descending order., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY (SELECT-FROM\u2013ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the poker players winnings in descending order., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select poker_player.Earnings",
        "real_label": "select poker_player.Earnings",
        "topk_preds": [
            "select poker_player.Earnings",
            "select poker_player.Earnings, t0.c6",
            "select poker_player.Earnings, poker_player.Poker_Player_ID",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Earnings, t0.c6",
            "select poker_player.Earnings, t0.c8",
            "select poker_player.Earnings-ORDER BY",
            "select poker_player.Earnings, poker_player.Final_Table_Made"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the poker players winnings in descending order., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want to see the amount of money that was earned by the poker players listed in descending order., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (SELECT-FROM -ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM\u2013ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want to see the amount of money that was earned by the poker players listed in descending order., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c5",
        "label": "select t0.c5",
        "score": true,
        "real_pred": "select poker_player.Earnings",
        "real_label": "select poker_player.Earnings",
        "topk_preds": [
            "select poker_player.Earnings",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select sum(poker_player.Earnings), poker_player.Poker_Player_ID",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.Earnings, t0.c6",
            "select poker_player.Earnings, t0.c6",
            "select sum(poker_player.Earnings), t0.c6",
            "select poker_player.Earnings, t0.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want to see the amount of money that was earned by the poker players listed in descending order., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Return the average payout for each poker player., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY (t0.c0)",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM for-GROUP BY",
            "SELECT-FROM-GROUP BY (t0.c1)",
            "SELECT-FROM-GROUP BY."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Return the average payout for each poker player., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c1, avg(t0.c5)",
        "label": "select avg(t0.c5)",
        "score": false,
        "real_pred": "select poker_player.People_ID, avg(poker_player.Earnings)",
        "real_label": "select avg(poker_player.Earnings)",
        "topk_preds": [
            "select poker_player.People_ID, avg(poker_player.Earnings)",
            "select poker_player.Poker_Player_ID, avg(poker_player.Earnings)",
            "select poker_player.Final_Table_Made, avg(poker_player.Earnings)",
            "select poker_player.Poker_Player_ID0, avg(poker_player.Earnings)",
            "select poker_player.People_ID., avg(poker_player.Earnings)",
            "select poker_player.Earnings, avg(poker_player.Earnings)",
            "select poker_player.People_ID, avg(poker_player.Earnings)",
            "select t2.c1, avg(poker_player.Earnings)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Return the average payout for each poker player., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me average income for all poker players, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM (GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me average income for all poker players, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select avg(t0.c5)",
        "label": "select avg(t0.c5)",
        "score": true,
        "real_pred": "select avg(poker_player.Earnings)",
        "real_label": "select avg(poker_player.Earnings)",
        "topk_preds": [
            "select avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), poker_player.Poker_Player_ID",
            "select avg(poker_player.Earnings), t0.c6",
            "select an avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), poker_player.Money_Rank",
            "select avg(poker_player.Earnings), poker_player.Final_Table_Made",
            "select avg(poker_player.Earnings), t0.c7",
            "select avg(poker_player.Earnings), poker_player.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me average income for all poker players, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the money rank of the player who has won the most amount of money during his poker career?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the money rank of the player who has won the most amount of money during his poker career?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select poker_player.Money_Rank",
        "real_label": "select poker_player.Money_Rank",
        "topk_preds": [
            "select poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Money_Rank",
            "select poker_player.Money_Rank, poker_player.Earnings",
            "select poker_player.People_ID, poker_player.Money_Rank",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Money_Rank, max(poker_player.Earnings)",
            "select poker_player.Money_Rank (poker_poker_player.Earnings)",
            "select poker_player.Money_Rank (or whatever poker_player.Money_Rank)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the money rank of the player who has won the most amount of money during his poker career?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please return the rank of the players with the largest income., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SCHEMPT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please return the rank of the players with the largest income., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select poker_player.Money_Rank",
        "real_label": "select poker_player.Money_Rank",
        "topk_preds": [
            "select poker_player.Money_Rank",
            "select poker_player.Poker_Player_ID, poker_player.Money_Rank",
            "select poker_player.Earnings, poker_player.Money_Rank",
            "select poker_player.People_ID, poker_player.Money_Rank",
            "select poker_player.Money_Rank, poker_player.Earnings",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.Money_Rank, max(poker_player.Earnings)",
            "select poker_player.People_ID, poker_player.Best_Finish"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please return the rank of the players with the largest income., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need the highest amount of money that was won at the final table among those players which had an income under 200000 and played poker., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need the highest amount of money that was won at the final table among those players which had an income under 200000 and played poker., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select max(t0.c4)",
        "label": "select max(t0.c2)",
        "score": false,
        "real_pred": "select max(poker_player.Money_Rank)",
        "real_label": "select max(poker_player.Final_Table_Made)",
        "topk_preds": [
            "select max(poker_player.Money_Rank)",
            "select max(poker_player.Earnings)",
            "select max(t0.c6)",
            "select max(poker_player.Money_Rank), poker_player.Earnings",
            "select max(poker_player.Best_Finish)",
            "select max(poker_player.Money_Rank) at the poker_player.Final_Table_Made",
            "select max(poker_player.Earnings), poker_player.Poker_Player_ID",
            "select max(poker_player.Money_Rank) at poker_player.Final_Table_Made"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need the highest amount of money that was won at the final table among those players which had an income under 200000 and played poker., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "poker_player",
        "real_label": "poker_player",
        "topk_preds": [
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List all people who have won over $300000 while playing poker as their occupation., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List all people who have won over $300000 while playing poker as their occupation., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Nationality, people.Name",
            "select people.Nationality",
            "select people.Name, people.Nationality",
            "select poker_player.People_ID",
            "select people.Name, people.Height",
            "select people.People_ID, people.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List all people who have won over $300000 while playing poker as their occupation., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Name the poker players who had winnings of more than $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Name the poker players who had winnings of more than $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t0.c1",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select poker_player.People_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select poker_player.People_ID",
            "select poker_player.Poker_Player_ID",
            "select poker_player.People_ID, poker_player.Final_Table_Made",
            "select poker_player.People_ID, people.Name",
            "select poker_player.People_ID, poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, people.Name",
            "select poker_player.People_ID, poker_player.Best_Finish",
            "select poker_player.People_ID, poker_player.Earnings"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Name the poker players who had winnings of more than $300,000., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "poker_player",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who amongst the people making more than 300,000' are poker professionals?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE - INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who amongst the people making more than 300,000' are poker professionals?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select distinct t1.c2",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select distinct people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select distinct people.Name",
            "select poker_player.Poker_Player_ID",
            "select people.Name",
            "select distinct people.Name, people.Birth_Date",
            "select poker_player.People_ID",
            "select distinct poker_player.Poker_Player_ID",
            "select poker_player.Poker_Player_ID, people.Name",
            "select distinct poker_player.People_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who amongst the people making more than 300,000' are poker professionals?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0",
        "label": "t0 t1",
        "score": false,
        "real_pred": "poker_player",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player",
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me names of poker players who had more than $300000 in their bankrolls., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me names of poker players who had more than $300000 in their bankrolls., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, poker_player.People_ID",
            "select people.Name, people.Nationality",
            "select people.Name, poker_player.Poker_Player_ID",
            "select people.Name, people.People_ID",
            "select people.Nationality, people.Name",
            "select people.Name, people.Height"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me names of poker players who had more than $300000 in their bankrolls., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need the birth date of the poker player who has made the lowest amount of money., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-orDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need the birth date of the poker player who has made the lowest amount of money., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select people.Birth_Date",
        "real_label": "select people.Birth_Date",
        "topk_preds": [
            "select people.Birth_Date",
            "select people.Birth_Date, people.Height",
            "select people.Birth_Date, poker_player.Money_Rank",
            "select people.Birth_Date, people.Name",
            "select people.Birth_Date, poker_player.Final_Table_Made",
            "select people.Nationality, people.Birth_Date",
            "select people.Birth_Date, poker_player.Earnings",
            "select people.Birth_Date, t2.c4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need the birth date of the poker player who has made the lowest amount of money., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The average income of a player of poker who is over 200 cm tall is what?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The average income of a player of poker who is over 200 cm tall is what?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select avg(t0.c5)",
        "label": "select avg(t0.c5)",
        "score": true,
        "real_pred": "select avg(poker_player.Earnings)",
        "real_label": "select avg(poker_player.Earnings)",
        "topk_preds": [
            "select avg(poker_player.Earnings)",
            "select avg(poker_player.Earnings), people.Height",
            "select an avg(poker_player.Earnings)",
            "select  avg(poker_player.Earnings)",
            "select the avg(poker_player.Earnings)",
            "select avg(t0-poker_player.Earnings)",
            "select avg(t0.c6)",
            "select avg(poker_player.Earnings), t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The average income of a player of poker who is over 200 cm tall is what?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "poker_player people",
        "real_label": "poker_player people",
        "topk_preds": [
            "poker_player people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different countries that people originate from and the corresponding number of people from each country?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY, UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY t1.c1, count(*)",
            "SELECT-FROM-GROUP BY, ESTIMATE-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY, ESTIMATE-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different countries that people originate from and the corresponding number of people from each country?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c1, count(*)",
        "label": "select t1.c1, count(*)",
        "score": true,
        "real_pred": "select people.Nationality, count(*)",
        "real_label": "select people.Nationality, count(*)",
        "topk_preds": [
            "select people.Nationality, count(*)",
            "select people.Nationality, count(*), people.Name",
            "select people.Nationality, count(*), people.Birth_Date",
            "select people.Nationality, count(*), people.Nationality",
            "select people.Nationality, count(*),",
            "select people.Nationality, count(*), people.People_ID",
            "select people.Nationality., count(*)",
            "select people.Nationality, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different countries that people originate from and the corresponding number of people from each country?, database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality, c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the names of people whose country is not Russia., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the names of people whose country is not Russia., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Nationality",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Height",
            "select people.Name, t1.c5",
            "select people.Name (or people.Birth_Date)",
            "select people.Name, t1.c6",
            "select people.Name (if people.Name)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the names of people whose country is not Russia., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the names of individuals who do not come from Russia., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the names of individuals who do not come from Russia., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c2",
        "label": "select t1.c2",
        "score": true,
        "real_pred": "select people.Name",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.Name",
            "select people.Name, people.Nationality",
            "select distinct people.Name",
            "select people.Name, people.Birth_Date",
            "select people.Name, people.Height",
            "select people.Name (except people.Birth_Date)",
            "select people.Name (or people.Birth_Date)",
            "select people.Name (not people.Birth_Date)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the names of individuals who do not come from Russia., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show all those who do not come from Russia below., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show all those who do not come from Russia below., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "select t1.c0",
        "label": "select t1.c2",
        "score": false,
        "real_pred": "select people.People_ID",
        "real_label": "select people.Name",
        "topk_preds": [
            "select people.People_ID",
            "select people.Name",
            "select people.Nationality",
            "select people.People_ID, people.Name",
            "select people.Name, people.Birth_Date",
            "select people.People_ID, people.Nationality",
            "select people.Name, people.Height",
            "select people.Nationality, people.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show all those who do not come from Russia below., database: Database: poker_player. t0: poker_player(c0: poker_player_id, c1: people_id, c2: final_table_made, c3: best_finish, c4: money_rank, c5: earnings) (c1) refers to t1(c0). t1: people(c0: people_id, c1: nationality (Russia), c2: name, c3: birth_date, c4: height).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "people",
        "real_label": "people",
        "topk_preds": [
            "people",
            "",
            "",
            "",
            "",
            "",
            "",
            "poker_player people"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me the last date that new votes for CA were added., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE -ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me the last date that new votes for CA were added., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "select max(t2.c4)",
        "label": "select max(t2.c4)",
        "score": true,
        "real_pred": "select max(VOTES.created)",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select max(VOTES.created)",
            "select VOTES.created",
            "select VOTES.vote_id, max(VOTES.created)",
            "select VOTES.vote_id, VOTES.created",
            "select t2.c5",
            "select max(VOTES.created), VOTES.state",
            "select max(t2.c5)",
            "select max(VOTES.created), t2.c5"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me the last date that new votes for CA were added., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "AREA_CODE_STATE VOTES",
            "",
            "CONTESTANTS VOTES",
            "",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What was the latest day that CA votes were counted on?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What was the latest day that CA votes were counted on?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "select max(t2.c4)",
        "label": "select max(t2.c4)",
        "score": true,
        "real_pred": "select max(VOTES.created)",
        "real_label": "select max(VOTES.created)",
        "topk_preds": [
            "select max(VOTES.created)",
            "select max(t2.c5)",
            "select max(VOTES.contestant_number)",
            "select max(t2.c6)",
            "select max(t2.c8)",
            "select max(t2.c9)",
            "select max(t2.c7)",
            "select max(VOTES.state)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What was the latest day that CA votes were counted on?, database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state (CA)). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state (CA), c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "AREA_CODE_STATE VOTES",
            "",
            "",
            "CONTESTANTS VOTES",
            "AREA_CODE_STATE CONTESTANTS VOTES",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter the vote ids, telephone numbers and states of all votes below., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM INVEST-SELECT-FROM",
            "SELECT-FROM (SELECT-FROM",
            "SELECT SELECT-FROM",
            "SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter the vote ids, telephone numbers and states of all votes below., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select t2.c0, t2.c1, t2.c2",
        "label": "select t2.c0, t2.c1, t2.c2",
        "score": true,
        "real_pred": "select VOTES.vote_id, VOTES.phone_number, VOTES.state",
        "real_label": "select VOTES.vote_id, VOTES.phone_number, VOTES.state",
        "topk_preds": [
            "select VOTES.vote_id, VOTES.phone_number, VOTES.state",
            "select VOTES.vote_id, VOTES.phone_number, VOTES.state",
            "select VOTES.vote_id, VOTES.phone_number.c1, VOTES.state",
            "select VOTES.vote_id, VOTES.phone_number, VOTES.state.",
            "select VOTES.vote_id-, VOTES.phone_number, VOTES.state",
            "select VOTES.vote_id, VOTES.phone_number, t2.c 2",
            "select VOTES.vote_id, VOTES.phone_number., VOTES.state",
            "select t2.co, VOTES.phone_number, VOTES.state"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter the vote ids, telephone numbers and states of all votes below., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the distinct states and their times for each vote., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM distinct t2.c2, t2.c4",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM distinct t2.c2, max(t2.c4)",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM, t2.c2, t2.c4",
            "SELECT-FROM distinct t2.c2, t2.c3"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the distinct states and their times for each vote., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select distinct t2.c2, t2.c4",
        "label": "select distinct t2.c2, t2.c4",
        "score": true,
        "real_pred": "select distinct VOTES.state, VOTES.created",
        "real_label": "select distinct VOTES.state, VOTES.created",
        "topk_preds": [
            "select distinct VOTES.state, VOTES.created",
            "select VOTES.state, VOTES.created",
            "select distinct VOTES.state, VOTES.contestant_number",
            "select VOTES.state, VOTES.contestant_number",
            "select distinct VOTES.state, max(VOTES.created)",
            "select VOTES.state, max(VOTES.created)",
            "select distinct VOTES.state, t2.c5",
            "select distinct VOTES.state, min(VOTES.created)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the distinct states and their times for each vote., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me the distinct states and the exact times at which the votes were cast., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM distinct t2.c2, t2.c4",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM in distinct t2.c2, t2.c4",
            "SELECT-FROM distinct t2.c2, exact(t2.c4)",
            "SELECT-FROM distinct t2.c2, t2.c3",
            "SELECT-FROM distinct t2.c2, max(t2.c4)",
            "SELECT-FROM in distinct t2.c2, exact(t2.c4)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me the distinct states and the exact times at which the votes were cast., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select distinct t2.c2, t2.c4",
        "label": "select distinct t2.c2, t2.c4",
        "score": true,
        "real_pred": "select distinct VOTES.state, VOTES.created",
        "real_label": "select distinct VOTES.state, VOTES.created",
        "topk_preds": [
            "select distinct VOTES.state, VOTES.created",
            "select distinct VOTES.state, VOTES.contestant_number",
            "select distinct VOTES.state, exact(VOTES.created)",
            "select distinct VOTES.state, max(VOTES.created)",
            "select distinct VOTES.state, t2.c5",
            "select VOTES.state, VOTES.created",
            "select distinct VOTES.state, t0.c3",
            "select distinct VOTES.state, precise(VOTES.created)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me the distinct states and the exact times at which the votes were cast., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the distinct states and times on which each vote was cast in., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM distinct t2.c2, t2.c4",
            "SELECT-FROM each distinct t2.c2, t2.c4",
            "SELECT-FROM distinct t2.c2, t2.c3",
            "SELECT-FROM each distinct t2.c2, t2.c3",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM (Vot2.c2), SELECT-FROM",
            "SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the distinct states and times on which each vote was cast in., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "select distinct t2.c2, t2.c4",
        "label": "select distinct t2.c2, t2.c4",
        "score": true,
        "real_pred": "select distinct VOTES.state, VOTES.created",
        "real_label": "select distinct VOTES.state, VOTES.created",
        "topk_preds": [
            "select distinct VOTES.state, VOTES.created",
            "select distinct VOTES.state, VOTES.contestant_number",
            "select distinct VOTES.state, t2.c5",
            "select distinct VOTES.state, VOTES.contestant_number, VOTES.created",
            "select distinct VOTES.state, VOTES.created, VOTES.vote_id",
            "select distinct VOTES.state, t0.c3",
            "select distinct VOTES.state, VOTES.created,",
            "select distinct VOTES.state, VOTES.contestant_number:30"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the distinct states and times on which each vote was cast in., database: Database: voter_1. t0: area_code_state(c0: area_code, c1: state). t1: contestants(c0: contestant_number, c1: contestant_name). t2: votes(c0: vote_id, c1: phone_number, c2: state, c3: contestant_number, c4: created).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "VOTES",
        "real_label": "VOTES",
        "topk_preds": [
            "VOTES",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: list down the names of nations where either English or Dutch is their preferred national language, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: list down the names of nations where either English or Dutch is their preferred national language, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.Language",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Capital",
            "select country.Name, countrylanguage.IsOfficial",
            "select country.Name, country.LocalName",
            "select country.Name, countrylanguage.Percentage",
            "select country.Name (countrylanguage.CountryCode)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: list down the names of nations where either English or Dutch is their preferred national language, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to learn about all the nations that speak either English or Dutch as an official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to learn about all the nations that speak either English or Dutch as an official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select countrylanguage.CountryCode",
            "select country.Name, country.Capital",
            "select country.Name, country.Region",
            "select country.Name, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to learn about all the nations that speak either English or Dutch as an official language., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t2 t3",
        "score": false,
        "real_pred": "countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the country that has the most land, show name, the head of state and the population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, t2.c1, t2.c12, t2.c6",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the country that has the most land, show name, the head of state and the population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c12, t2.c6",
        "label": "select t2.c1, t2.c6, t2.c12",
        "score": false,
        "real_pred": "select country.Name, country.HeadOfState, country.Population",
        "real_label": "select country.Name, country.Population, country.HeadOfState",
        "topk_preds": [
            "select country.Name, country.HeadOfState, country.Population",
            "select country.Name, country.HeadOfState, country.Population",
            "select country.Name, t2.c 12, country.Population",
            "select country.Name, country.Capital, country.Population",
            "select country.Name, country.HeadOfState.c12, country.Population",
            "select country.Name, country.GovernmentForm, country.Population",
            "select country.Name, country.HeadOfState und country.Population",
            "select country.Name, country.HeadOfState, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the country that has the most land, show name, the head of state and the population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find out average Gross National Product and Total Population for all nations that are considered territories of U.S., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-INCLUS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-INCLUS-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-INCLUS-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-INCLUS-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find out average Gross National Product and Total Population for all nations that are considered territories of U.S., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), avg(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": false,
        "real_pred": "select avg(country.GNP), avg(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), avg(country.Population)",
            "select avg(country.Population), avg(country.GNP)",
            "select avg(country.LifeExpectancy), avg(country.Population)",
            "select avg(country.SurfaceArea), avg(country.GNP)",
            "select avg(country.IndepYear), avg(country.Population)",
            "select avg(country.GNP, avg(country.Population)",
            "select avg(t2.c), avg(country.Population)",
            "select avg(country.IndepYear), avg(country.GNP)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find out average Gross National Product and Total Population for all nations that are considered territories of U.S., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "sqlite_sequence country",
            "city country",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For nations belonging to the United States, show their mean GDP and their total population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For nations belonging to the United States, show their mean GDP and their total population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": true,
        "real_pred": "select avg(country.GNP), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.SurfaceArea), sum(country.Population)",
            "select avg(country.Population), sum(country.Population)",
            "select avg(country.IndepYear), sum(country.Population)",
            "select avg(country.LifeExpectancy), sum(country.Population)",
            "select avg(country.GNPOld), sum(country.Population)",
            "select country.GNP, country.Population",
            "select avg(country.GNP), sum(country.Population)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For nations belonging to the United States, show their mean GDP and their total population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need you to provide the population of all the countries that are considered U.S. territory as well as their respective mean gross national products., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need you to provide the population of all the countries that are considered U.S. territory as well as their respective mean gross national products., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c6, avg(t2.c8)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": false,
        "real_pred": "select country.Population, avg(country.GNP)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select country.Population, avg(country.GNP)",
            "select country.Code, country.Population, avg(country.GNP)",
            "select country.Name, avg(country.GNP)",
            "select country.Code, country.Name, avg(country.Population)",
            "select country.Code, country.Name, avg(country.GNP)",
            "select count(*), avg(country.Population)",
            "select country.IndepYear, avg(country.GNP)",
            "select country.Population), avg(country.GNP)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need you to provide the population of all the countries that are considered U.S. territory as well as their respective mean gross national products., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "country countrylanguage",
            "",
            "",
            "city country",
            "sqlite_sequence country"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me the average GDP per capita and the total population for each of the countries that are considered US territory., database: Database: world_1. t0: city(c0: id, c1: name (Perm), c2: countrycode (PER), c3: district (Perm), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code (PER), c1: name (Peru), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode (PER), c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY.",
            "SELECT-FROM-WHERE-GEOGRAPHY-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY",
            "SELECT-FROM-WHERE-DISPLAY-GROUP BY",
            "SELECT-FROM-WHERE-DECLARATION-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me the average GDP per capita and the total population for each of the countries that are considered US territory., database: Database: world_1. t0: city(c0: id, c1: name (Perm), c2: countrycode (PER), c3: district (Perm), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code (PER), c1: name (Peru), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode (PER), c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": true,
        "real_pred": "select avg(country.GNP), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), sum(country.Population)",
            "select avg(t3.c8), sum(country.Population)",
            "select country.GNP, sum(country.Population)",
            "select avg(country.GNP), avg(country.Population)",
            "select country.GovernmentForm, avg(country.GNP), sum(country.Population)",
            "select country.GovernmentForm, avg(t3.c8), sum(country.Population)",
            "select avg(country.Population), sum(country.Population)",
            "select avg(t4.c8), sum(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me the average GDP per capita and the total population for each of the countries that are considered US territory., database: Database: world_1. t0: city(c0: id, c1: name (Perm), c2: countrycode (PER), c3: district (Perm), c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code (PER), c1: name (Peru), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode (PER), c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the average Gross National Product and the total population of those countries that are considered U.S. territories., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-AVERAGE(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE, AVG(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-INCLUDE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the average Gross National Product and the total population of those countries that are considered U.S. territories., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": true,
        "real_pred": "select avg(country.GNP), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.Population), avg(country.GNP)",
            "select sum(country.Population), avg(country.GNP)",
            "select sum(country.GNP), avg(country.GNP)",
            "select avg(country.LifeExpectancy), sum(country.Population)",
            "select avg(country.Population), sum(country.Population)",
            "select avg(country.IndepYear), sum(country.Population)",
            "select avg(country.GNP, sum(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the average Gross National Product and the total population of those countries that are considered U.S. territories., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "sqlite_sequence country",
            "city country",
            "",
            "",
            "",
            "country countrylanguage"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me about each individual country that was founded prior to 1930 in terms of its total number of official languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY (GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY (GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY (GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me about each individual country that was founded prior to 1930 in terms of its total number of official languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, sum(t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select country.Name, sum(countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select country.Name, sum(countrylanguage.IsOfficial)",
            "select country.Code, sum(countrylanguage.IsOfficial)",
            "select country.Name, sum(country.Continent)",
            "select country.Name, sum(countrylanguage.Percentage)",
            "select country.Name, sum(t3.c5)",
            "select country.Name, count(*)",
            "select country.Name, sum(countrylanguage.Language)",
            "select country.Name, sum(t3.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me about each individual country that was founded prior to 1930 in terms of its total number of official languages., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For countries founded before 1930, what is the total number of official language s?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE GROSS(t3.c2)",
            "SELECT-FROM-WHERE (sum(t3.c2)",
            "SELECT-FROM-WHERE.GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For countries founded before 1930, what is the total number of official language s?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select sum(countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select sum(countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select count(distinct countrylanguage.Language, count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language, countrylanguage.IsOfficial)",
            "select count(count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language, sum(countrylanguage.IsOfficial)",
            "select count(count(distinct countrylanguage.Language)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For countries founded before 1930, what is the total number of official language s?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total number of official languages that were in use for each country that was founded before 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY (ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY -ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total number of official languages that were in use for each country that was founded before 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, sum(t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select country.Name, sum(countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select country.Name, sum(countrylanguage.IsOfficial)",
            "select count(*), country.Name",
            "select sum(countrylanguage.IsOfficial), country.Name",
            "select country.Code, sum(countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.IsOfficial), country.Name",
            "select count(*), country.Code",
            "select for country.Name, sum(countrylanguage.IsOfficial)",
            "select country.Name, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total number of official languages that were in use for each country that was founded before 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "city country countrylanguage"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total number of different official languages for the countries that existed from 1890 to 1929?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(distinct t3.c1)",
            "SELECT-FROM-WHERE (count(distinct t3.c2)",
            "SELECT-FROM-WHERE(count(distinct t3.c1)",
            "SELECT-FROM-WHERE(count(distinct t3.c2)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE(distinct t3.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total number of different official languages for the countries that existed from 1890 to 1929?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c1)",
        "label": "select count(distinct t3.c1)",
        "score": true,
        "real_pred": "select count(distinct countrylanguage.Language)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.Language)",
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.CountryCode)",
            "select count(distinct countrylanguage.Language).",
            "select count(distinct countrylanguage.Language",
            "select count(distinct t3.c6)",
            "select count(distinct t3.c5)",
            "select count(distinct t3.c)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total number of different official languages for the countries that existed from 1890 to 1929?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: There are some countries which were found before 1930. The total number of all official languages spoken there is equal to?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: There are some countries which were found before 1930. The total number of all official languages spoken there is equal to?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select sum(countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select sum(countrylanguage.IsOfficial)",
            "select countrylanguage.CountryCode, sum(countrylanguage.IsOfficial)",
            "select sum(countrylanguage.IsOfficial), country.Name",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select countrylanguage.Language, sum(countrylanguage.IsOfficial)",
            "select sum(countrylanguage.Percentage)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: There are some countries which were found before 1930. The total number of all official languages spoken there is equal to?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For the countries that existed before 1930, what is the total number of unique official languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(distinct t3.c2)",
            "SELECT-FROM-WHERE, count(distinct t3.c2)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(distinct t3.c1)",
            "SELECT-FROM-WHERE - COUNT(distinct t3.c2)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(distinct t3.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For the countries that existed before 1930, what is the total number of unique official languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(distinct countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select sum(countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.CountryCode)",
            "select sum(distinct countrylanguage.IsOfficial)",
            "select count(distinct t3.c6)",
            "select count(distinct t3.c)",
            "select count(distinct t3.c5)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For the countries that existed before 1930, what is the total number of unique official languages?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many countries were founded before 1930 that had an official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE-COUNT(*)",
            "SELECT-FROM-WITH-WHERE",
            "SELECT-FROM-WHERE-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many countries were founded before 1930 that had an official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(*)",
            "select count(*), countrylanguage.CountryCode",
            "select count(*), countrylanguage.Language, country.Name",
            "select count(*), country.Name",
            "select count(*), countrylanguage.Language",
            "select count(*), countrylanguage.Language, country.Capital",
            "select count(*), countrylanguage.Language, countrylanguage.IsOfficial",
            "select count(*), countrylanguage.CountryCode, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many countries were founded before 1930 that had an official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "country",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total number of official languages for all countries that were established before 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(distinct t3.c2)",
            "SELECT-FROM-WHERE (sum(t3.c2)",
            "SELECT-FROM-WHERE.GROUP BY-HAVING",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE - GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total number of official languages for all countries that were established before 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(distinct countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.IsOfficial)",
            "select sum(countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select count(count(distinct countrylanguage.IsOfficial)",
            "select count(*)",
            "select count(countrylanguage.IsOfficial)",
            "select count(1, countrylanguage.IsOfficial)",
            "select count(count(distinct countrylanguage.Language)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total number of official languages for all countries that were established before 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want to know the total number of distinct official languages for the countries founded before 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(distinct t3.c2)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE THUMULTI-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(distinct t3.c1)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want to know the total number of distinct official languages for the countries founded before 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(distinct countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select sum(countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.IsOfficial).",
            "select count(distinct t3.c6)",
            "select count(distinct t3.c5)",
            "select count(distinct country.Name)",
            "select count(distinct countrylanguage.IsOfficial"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want to know the total number of distinct official languages for the countries founded before 1930., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "city country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The countries existing prior to 1930, how many official languages did they have?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The countries existing prior to 1930, how many official languages did they have?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(distinct countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.IsOfficial)",
            "select country.Name, count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select countrylanguage.CountryCode, count(distinct countrylanguage.IsOfficial)",
            "select countrylanguage.Language, count(distinct countrylanguage.IsOfficial)",
            "select country.Code, count(distinct countrylanguage.IsOfficial)",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select count(distinct countrylanguage.IsOfficial), country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The countries existing prior to 1930, how many official languages did they have?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "sqlite_sequence countrylanguage",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the total number of official languages spoken in the countries which were independent in the year 1930 or earlier., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (GROUP BY-HAVING",
            "SELECT-FROM-WHERE (GROUP BY-HAVING)",
            "SELECT-FROM-WHERE GROSS(t3.c2)",
            "SELECT-FROM-WHERE/GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the total number of official languages spoken in the countries which were independent in the year 1930 or earlier., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(distinct countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.IsOfficial)",
            "select sum(countrylanguage.IsOfficial)",
            "select count(*)",
            "select count(countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select count(count(distinct countrylanguage.IsOfficial)",
            "select count(1, countrylanguage.IsOfficial)",
            "select count(distinct t3.c6)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the total number of official languages spoken in the countries which were independent in the year 1930 or earlier., database: Database: world_1. t0: city(c0: id, c1: name (Independence), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the number of official languages spoken in the countries which are founded before 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (count(distinct t3.c2)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE/GROUP BY-HAVING",
            "SELECT-FROM-WHERE (GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the number of official languages spoken in the countries which are founded before 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t3.c2)",
        "label": "select count(distinct t3.c1)",
        "score": false,
        "real_pred": "select count(distinct countrylanguage.IsOfficial)",
        "real_label": "select count(distinct countrylanguage.Language)",
        "topk_preds": [
            "select count(distinct countrylanguage.IsOfficial)",
            "select count(distinct countrylanguage.Language)",
            "select count(countrylanguage.IsOfficial)",
            "select count(count(distinct countrylanguage.IsOfficial)",
            "select count(1, countrylanguage.IsOfficial)",
            "select count(*)",
            "select count(distinct t3.c6)",
            "select count(distinct t3.c5)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the number of official languages spoken in the countries which are founded before 1930?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Is there more than one continent where Chinese is spoken?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-SECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Is there more than one continent where Chinese is spoken?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c2",
        "label": "select count( distinct t2.c2)",
        "score": false,
        "real_pred": "select country.Continent",
        "real_label": "select count( distinct country.Continent)",
        "topk_preds": [
            "select country.Continent",
            "select count(distinct country.Continent)",
            "select count(country.Continent)",
            "select distinct country.Continent",
            "select multi-country.Continent",
            "select country.Continent, countrylanguage.Language",
            "select multiple country.Continent",
            "select more than country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Is there more than one continent where Chinese is spoken?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: In the continents where Chinese is the local dialect, just what is the number of them?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: In the continents where Chinese is the local dialect, just what is the number of them?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count( distinct t2.c2)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count( distinct country.Continent)",
        "topk_preds": [
            "select count(*)",
            "select count(*), country.Continent",
            "select count(*) in country.Continent",
            "select count(*), country.Code",
            "select count(*) on country.Continent",
            "select count(*), country.Name",
            "select count(*) dans country.Continent",
            "select count(*) In country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: In the continents where Chinese is the local dialect, just what is the number of them?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The number of distinct continents where Chinese is spoken is how many?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(distinct t2.c2)",
            "SELECT-FROM-WHERE count(distinct t2.c2)",
            "SELECT-FROM-WHERE-NUM(distinct t2.c2)",
            "SELECT-FROM-WHERE-COUNT(distinct t2.c2)",
            "SELECT-FROM-WHERE (distinct t2.c2)",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The number of distinct continents where Chinese is spoken is how many?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(distinct t2.c2)",
        "label": "select count( distinct t2.c2)",
        "score": false,
        "real_pred": "select count(distinct country.Continent)",
        "real_label": "select count( distinct country.Continent)",
        "topk_preds": [
            "select count(distinct country.Continent)",
            "select count(country.Continent)",
            "select count(distinct country.Population)",
            "select count(separate country.Continent)",
            "select count(distinct t2).c2",
            "select count(distinct country.Name)",
            "select count(distant country.Continent)",
            "select count( distinct country.Continent)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The number of distinct continents where Chinese is spoken is how many?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "",
            "",
            "sqlite_sequence country countrylanguage",
            "",
            "city country countrylanguage",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the numbers of the continents where Chinese is spoken?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INSERT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the numbers of the continents where Chinese is spoken?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count( distinct t2.c2)",
        "score": false,
        "real_pred": "select count(*)",
        "real_label": "select count( distinct country.Continent)",
        "topk_preds": [
            "select count(*)",
            "select count(country.Continent)",
            "select count(distinct country.Continent)",
            "select count(*), country.Continent",
            "select count(continents)",
            "select count(count(distinct country.Continent)",
            "select count(count(country.Continent)",
            "select count(count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the numbers of the continents where Chinese is spoken?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Chinese), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "city country countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which is the largest nation in Asia by surface area, and what is its population, and average life span?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT, avg(t2.c6)",
            "SELECT-FROM-WHERE, avg(t2.c6), t2.c7",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT, AVERAGE(t2.c6)",
            "SELECT-FROM-WHERE (t2.c6), avg(t2.c7)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which is the largest nation in Asia by surface area, and what is its population, and average life span?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, avg(t2.c7)",
        "label": "select t2.c1, t2.c6, t2.c7",
        "score": false,
        "real_pred": "select country.Name, country.Population, avg(country.LifeExpectancy)",
        "real_label": "select country.Name, country.Population, country.LifeExpectancy",
        "topk_preds": [
            "select country.Name, country.Population, avg(country.LifeExpectancy)",
            "select country.Name, country.SurfaceArea, country.Population, avg(country.LifeExpectancy)",
            "select country.Name, country.Population, avg(country.LifeExpectancy)",
            "select country.Name, country.Population, avg(country.Population)",
            "select spanish country.Name, country.Population, avg(country.LifeExpectancy)",
            "select country.Name, country.Population), avg(country.LifeExpectancy)",
            "select country.Name, country.IndepYear, avg(country.Population)",
            "select country.Name, country.Code, avg(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which is the largest nation in Asia by surface area, and what is its population, and average life span?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which of the Asian countries has the biggest territory, show the name, population, and life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which of the Asian countries has the biggest territory, show the name, population, and life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c7",
        "label": "select t2.c1, t2.c6, t2.c7",
        "score": true,
        "real_pred": "select country.Name, country.Population, country.LifeExpectancy",
        "real_label": "select country.Name, country.Population, country.LifeExpectancy",
        "topk_preds": [
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.IndepYear, country.Population, country.LifeExpectancy",
            "select country.Name, country.Code, country.Population, country.LifeExpectancy",
            "select country.Name, country.Continent, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.LifeExpectancy, country.Population",
            "select country.Name, country.Population), country.LifeExpectancy"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which of the Asian countries has the biggest territory, show the name, population, and life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the largest country in Asia by land surface area, and what is its population, and life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, t2.c1, t2.c6, t2.c7",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the largest country in Asia by land surface area, and what is its population, and life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c7",
        "label": "select t2.c1, t2.c6, t2.c7",
        "score": true,
        "real_pred": "select country.Name, country.Population, country.LifeExpectancy",
        "real_label": "select country.Name, country.Population, country.LifeExpectancy",
        "topk_preds": [
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.IndepYear, country.Population, country.LifeExpectancy",
            "select country.Name, country.SurfaceArea, country.Population, country.LifeExpectancy",
            "select country.Name, country.Code, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population), country.LifeExpectancy",
            "select country.Name, country.LifeExpectancy, country.Population",
            "select country.Name, country.Population, country.LifeExpectancy, country.Capital"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the largest country in Asia by land surface area, and what is its population, and life expectancy?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter the name, population and head of state for the country that has the largest surface area below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter the name, population and head of state for the country that has the largest surface area below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c12",
        "label": "select t2.c1, t2.c6, t2.c12",
        "score": true,
        "real_pred": "select country.Name, country.Population, country.HeadOfState",
        "real_label": "select country.Name, country.Population, country.HeadOfState",
        "topk_preds": [
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Name, country.IndepYear, country.Population, country.HeadOfState",
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Name, country.Code6, country.HeadOfState",
            "select country.Name, country.Population, country.HeadOfState, country.Capital",
            "select country.Name), country.Population, country.HeadOfState",
            "select country.Name, t2.c 6, country.HeadOfState",
            "select country.Name, country.Population), country.HeadOfState"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter the name, population and head of state for the country that has the largest surface area below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter the name of the country which has the largest surface area, with its population, head of state and name below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, t2.c6, t2.c12",
            "SELECT-FROM-ORDER BY-LIMIT, t2.c12, t2.c1"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter the name of the country which has the largest surface area, with its population, head of state and name below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c6, t2.c12, t2.c1",
        "label": "select t2.c1, t2.c6, t2.c12",
        "score": false,
        "real_pred": "select country.Population, country.HeadOfState, country.Name",
        "real_label": "select country.Name, country.Population, country.HeadOfState",
        "topk_preds": [
            "select country.Population, country.HeadOfState, country.Name",
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Name, country.HeadOfState, country.Capital",
            "select country.HeadOfState, country.Population, country.Name",
            "select country.Code, country.Name, country.HeadOfState",
            "select country.Code, country.Population, country.HeadOfState",
            "select country.Name, country.HeadOfState, country.Population",
            "select country.LifeExpectancy, country.HeadOfState, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter the name of the country which has the largest surface area, with its population, head of state and name below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give the name of the country which has the largest surface area as well as its population, and head of state., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, t2.c6, t2.c12",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give the name of the country which has the largest surface area as well as its population, and head of state., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c12",
        "label": "select t2.c1, t2.c6, t2.c12",
        "score": true,
        "real_pred": "select country.Name, country.Population, country.HeadOfState",
        "real_label": "select country.Name, country.Population, country.HeadOfState",
        "topk_preds": [
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Name, country.IndepYear, country.Population, country.HeadOfState",
            "select country.Name, country.Code6, country.HeadOfState",
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Name, country.HeadOfState, country.Capital",
            "select country.Name, country.HeadOfState, country.Population",
            "select country.Name, country.Population), country.HeadOfState",
            "select country.Name, country.Population, country.HeadOfState, country.Capital"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give the name of the country which has the largest surface area as well as its population, and head of state., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the name, population, and head of state for the country that has the most land., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the name, population, and head of state for the country that has the most land., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c12",
        "label": "select t2.c1, t2.c6, t2.c12",
        "score": true,
        "real_pred": "select country.Name, country.Population, country.HeadOfState",
        "real_label": "select country.Name, country.Population, country.HeadOfState",
        "topk_preds": [
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Name, country.IndepYear, country.Population, country.HeadOfState",
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Name, country.Population, country.HeadOfState, country.Capital",
            "select country.Name, country.Code6, country.HeadOfState",
            "select country.Name), country.Population, country.HeadOfState",
            "select country.Name, country.Population), country.HeadOfState",
            "select country.Name., country.Population, country.HeadOfState"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the name, population, and head of state for the country that has the most land., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want to find out the country that has the greatest land area, it's population, and the president of this country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, t2.c6, t2.c12",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want to find out the country that has the greatest land area, it's population, and the president of this country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c12",
        "label": "select t2.c1, t2.c6, t2.c12",
        "score": true,
        "real_pred": "select country.Name, country.Population, country.HeadOfState",
        "real_label": "select country.Name, country.Population, country.HeadOfState",
        "topk_preds": [
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Name, country.Code6, country.HeadOfState",
            "select country.Code, country.Name, country.Population",
            "select country.Name, country.IndepYear, country.HeadOfState",
            "select country.Name, country.Population), country.HeadOfState",
            "select country.Name, country.Population, country.HeadOfState",
            "select country.Code, country.Name, country.HeadOfState"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want to find out the country that has the greatest land area, it's population, and the president of this country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many nations have a republic form?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE(count(*)",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many nations have a republic form?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), country.Code",
            "select count(*), country.Name",
            "select count(*), country.GovernmentForm",
            "select count(*), country.Capital",
            "select count(*), country.LocalName",
            "select count(*), country.Code1",
            "select count(*), country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many nations have a republic form?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "sqlite_sequence country",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total area of land that comprises the Caribbean countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, sum(t2.c4)",
            "SELECT-FROM-WHERE (sum(t2.c4)",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total area of land that comprises the Caribbean countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Name",
            "select sum(country.SurfaceArea), country.Region",
            "select sum(country.SurfaceArea), country.Code",
            "select sum(country.SurfaceArea), country.IndepYear",
            "select sum(country.SurfaceArea), country.LifeExpectancy",
            "select sum(country.SurfaceArea), country.Name5",
            "select sum(country.SurfaceArea), country.Capital"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total area of land that comprises the Caribbean countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "sqlite_sequence country",
            "",
            "",
            "city country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total area of all countries in the Caribbean together?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COMBINAT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total area of all countries in the Caribbean together?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Name",
            "select sum(country.SurfaceArea), country.Code",
            "select sum(country.SurfaceArea), country.Region",
            "select sum(country.SurfaceArea) delimited by country.Name",
            "select sum(country.SurfaceArea), country.IndepYear",
            "select sum(country.SurfaceArea), country.LifeExpectancy",
            "select sum(country.SurfaceArea), country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total area of all countries in the Caribbean together?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            "sqlite_sequence country"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find total amount of surface that countries in the Caribbean cover., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, sum(t2.c4)",
            "SELECT-FROM-WHERE (sum(t2.c4)",
            "SELECT-FROM-WHERE total(t2.c4)",
            "SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE.GROUP BY",
            "SELECT-FROM-WHERE-GEOGRAPHY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find total amount of surface that countries in the Caribbean cover., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Name",
            "select sum(country.SurfaceArea), country.Code",
            "select sum(country.SurfaceArea) descripted in country.SurfaceArea",
            "select sum(country.SurfaceArea) descripted in country.Name",
            "select sum(country.SurfaceArea) dependant on country.Name",
            "select sum(country.SurfaceArea) dependant on country.SurfaceArea",
            "select sum(country.SurfaceArea) dependant on country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find total amount of surface that countries in the Caribbean cover., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "sqlite_sequence country",
            "",
            "",
            "",
            "city country",
            "country countrylanguage",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much land area do the countries that make up the Carribbean cover altogether?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much land area do the countries that make up the Carribbean cover altogether?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Name",
            "select sum(country.SurfaceArea), country.Code",
            "select sum(country.SurfaceArea)as country.Name",
            "select sum(country.SurfaceArea)as country.Code",
            "select sum(country.SurfaceArea)as country.SurfaceArea",
            "select sum(country.SurfaceArea), country.IndepYear",
            "select sum(country.SurfaceArea) (country.SurfaceArea)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much land area do the countries that make up the Carribbean cover altogether?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "sqlite_sequence country",
            "city country",
            "",
            "",
            "",
            "country countrylanguage",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total area of the Caribbean countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, sum(t2.c4)",
            "SELECT-FROM-WHERE (sum(t2.c4)",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE ( sum(t2.c4)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total area of the Caribbean countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Name",
            "select sum(country.SurfaceArea), country.Code",
            "select sum(country.SurfaceArea), country.Region",
            "select sum(country.SurfaceArea) delimited by country.Region",
            "select sum(country.SurfaceArea), country.IndepYear",
            "select sum(country.SurfaceArea), country.LifeExpectancy",
            "select sum(country.SurfaceArea) delimited by country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total area of the Caribbean countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region (Caribbean), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Caribbean), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "sqlite_sequence country",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For country that's part of Asia called as having the shortest expected lifespan, please list., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For country that's part of Asia called as having the shortest expected lifespan, please list., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Region",
            "select country.Code, country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Code",
            "select country.Name (country.Code)",
            "select country.Name, country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For country that's part of Asia called as having the shortest expected lifespan, please list., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: In which Asian country do people live for the least amount of time?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: In which Asian country do people live for the least amount of time?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.LifeExpectancy",
            "select country.Name, country.Code",
            "select country.Name, country.GNP",
            "select country.Code, country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: In which Asian country do people live for the least amount of time?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please select the Asian country which has the lowest average life span below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ROUTINE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-AVERAGE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please select the Asian country which has the lowest average life span below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.LifeExpectancy",
            "select country.Name de country.Continent",
            "select country.Name, country.SurfaceArea",
            "select country.Name, country.GNP"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please select the Asian country which has the lowest average life span below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the total population and greatest national income of Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the total population and greatest national income of Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c6), max(t2.c6)",
        "label": "select sum(t2.c6), max(t2.c8)",
        "score": false,
        "real_pred": "select sum(country.Population), max(country.Population)",
        "real_label": "select sum(country.Population), max(country.GNP)",
        "topk_preds": [
            "select sum(country.Population), max(country.Population)",
            "select max(country.Population), sum(country.Population)",
            "select sum(country.Population), max(country.SurfaceArea)",
            "select country.Population, max(country.SurfaceArea)",
            "select sum(country.Population), maxim(country.Population)",
            "select sum(country.Population), max(country.IndepYear)",
            "select country.Population, country.Capital",
            "select sum(country.Population), min(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the total population and greatest national income of Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How many people live in Asia and what is the largest Gross National Product in this region?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT)",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How many people live in Asia and what is the largest Gross National Product in this region?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c6, t2.c8",
        "label": "select sum(t2.c6), max(t2.c8)",
        "score": false,
        "real_pred": "select country.Population, country.GNP",
        "real_label": "select sum(country.Population), max(country.GNP)",
        "topk_preds": [
            "select country.Population, country.GNP",
            "select country.Code, country.Population",
            "select country.Code, country.Population, country.GNP",
            "select country.Name, country.GNP",
            "select country.Code, country.Name, max(country.GNP)",
            "select country.Name, country.Population",
            "select country.Code, country.Name, country.GNP",
            "select max(country.GNP), country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How many people live in Asia and what is the largest Gross National Product in this region?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Among all Asian countries, how many people are living there and what's their largest gross national product?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Among all Asian countries, how many people are living there and what's their largest gross national product?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c6, t2.c8",
        "label": "select sum(t2.c6), max(t2.c8)",
        "score": false,
        "real_pred": "select country.Population, country.GNP",
        "real_label": "select sum(country.Population), max(country.GNP)",
        "topk_preds": [
            "select country.Population, country.GNP",
            "select country.Name, country.Population, country.GNP",
            "select country.Population, max(country.GNP)",
            "select country.Name, country.Population, max(country.GNP)",
            "select country.Name, country.Population",
            "select country.Code, country.Population, max(country.GNP)",
            "select country.Code, country.Population, country.GNP",
            "select country.Code, country.Name, max(country.GNP)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Among all Asian countries, how many people are living there and what's their largest gross national product?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: How much will the life span be the countries on this continent if they were all republics?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: How much will the life span be the countries on this continent if they were all republics?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c7",
        "label": "select avg(t2.c7)",
        "score": false,
        "real_pred": "select country.LifeExpectancy",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select country.LifeExpectancy",
            "select sum(country.LifeExpectancy)",
            "select max(country.LifeExpectancy)",
            "select country.Code, country.LifeExpectancy",
            "select country.LifeExpectancy, country.Continent",
            "select country.Code, max(country.LifeExpectancy)",
            "select country.Code, sum(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: How much will the life span be the countries on this continent if they were all republics?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give the average lifespan in African republics above., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE (avg(t2.c7)",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give the average lifespan in African republics above., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.GovernmentForm",
            "select an avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.Population",
            "select  avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.LocalName",
            "select avg(country.LifeExpectancy).",
            "select avg(country.LifeExpectancy), country.GNPOld"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give the average lifespan in African republics above., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me the average lifespan for the countries in Africa which are republics?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t2.c7)",
            "SELECT-FROM-WHERE (avg(t2.c7)",
            "SELECT-FROM-WHERE\u00adGROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me the average lifespan for the countries in Africa which are republics?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select an avg(country.LifeExpectancy)",
            "select  avg(country.LifeExpectancy)",
            "select the avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy",
            "select avg(country.Population)",
            "select Avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy),"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me the average lifespan for the countries in Africa which are republics?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the total area of the continents 'Asia' and 'Europe'?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-COMBINAT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-COMBINAT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the total area of the continents 'Asia' and 'Europe'?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Continent",
            "select sum(country.SurfaceArea) delimited by country.Continent",
            "select sum(country.SurfaceArea) def. country.Continent",
            "select sum(country.SurfaceArea) def. country.SurfaceArea",
            "select sum(country.SurfaceArea), country.Continent",
            "select sum(country.SurfaceArea), country.Continent2",
            "select sum(country.SurfaceArea), country.IndepYear"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the total area of the continents 'Asia' and 'Europe'?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "sqlite_sequence country",
            "city country",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the total land area of the continents Asia and Europe., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-COMBINAT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-COMBINAT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the total land area of the continents Asia and Europe., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c4)",
        "label": "select sum(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.SurfaceArea)",
        "real_label": "select sum(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.SurfaceArea)",
            "select sum(country.SurfaceArea), country.Continent",
            "select sum(country.SurfaceArea) def. country.Continent",
            "select sum(country.SurfaceArea), country.Continent",
            "select sum(country.SurfaceArea), country.Continent2",
            "select sum(country.SurfaceArea)across country.Continent",
            "select sum(country.SurfaceArea), country.Population",
            "select sum(country.SurfaceArea) def. country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the total land area of the continents Asia and Europe., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "sqlite_sequence country",
            "city country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want you to display a list containing the average gross national product and the total population in nationa whose government is US territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-AVERAGE(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE - AVERAGE(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE (AVERAGE(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE, AVG(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want you to display a list containing the average gross national product and the total population in nationa whose government is US territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": true,
        "real_pred": "select avg(country.GNP), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.Population), avg(country.GNP)",
            "select avg(country.Population), sum(country.Population)",
            "select avg(country.GNP), avg(country.Population)",
            "select sum(country.Population), avg(country.GNP)",
            "select avg(country.IndepYear), sum(country.Population)",
            "select avg(country.LifeExpectancy), sum(country.Population)",
            "select avg(country.SurfaceArea), sum(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want you to display a list containing the average gross national product and the total population in nationa whose government is US territory., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For every country in which the United States has some kind of control, what is their gross national product and population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C8, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-C8, SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For every country in which the United States has some kind of control, what is their gross national product and population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c8, t2.c6",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": false,
        "real_pred": "select country.GNP, country.Population",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select country.GNP, country.Population",
            "select country.Code, country.GNP, country.Population",
            "select country.Name, country.GNP, country.Population",
            "select country.IndepYear, country.GNP, country.Population",
            "select country.GNPOld, country.Population",
            "select country.LifeExpectancy, country.Population",
            "select country.IndepYear, country.Population",
            "select country.GNP, country.Population, country.Capital"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For every country in which the United States has some kind of control, what is their gross national product and population?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "sqlite_sequence country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The average income (GNP) and the total number of inhabitants in all the countries that are governed by the United States should be mentioned here., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, avg(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE, AVG(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The average income (GNP) and the total number of inhabitants in all the countries that are governed by the United States should be mentioned here., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": true,
        "real_pred": "select avg(country.GNP), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.Population), avg(country.GNP)",
            "select sum(country.GNP), sum(country.Population)",
            "select an avg(country.GNP), sum(country.Population)",
            "select avg(country.SurfaceArea), sum(country.Population)",
            "select avg(country.IndepYear), sum(country.Population)",
            "select avg(country.GNPOld), sum(country.Population)",
            "select avg(country.LifeExpectancy), sum(country.Population)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The average income (GNP) and the total number of inhabitants in all the countries that are governed by the United States should be mentioned here., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (United States), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname (United States), c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average Gross National Product and total population for the countries listed whose governments formed part of US Territory?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AVERAGE(t2.c8), sum(t2.c6)",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, AVG(t2.c8), sum(t2.c6)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average Gross National Product and total population for the countries listed whose governments formed part of US Territory?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c8), sum(t2.c6)",
        "label": "select avg(t2.c8), sum(t2.c6)",
        "score": true,
        "real_pred": "select avg(country.GNP), sum(country.Population)",
        "real_label": "select avg(country.GNP), sum(country.Population)",
        "topk_preds": [
            "select avg(country.GNP), sum(country.Population)",
            "select avg(country.GNP), avg(country.Population)",
            "select avg(country.Population), avg(country.GNP)",
            "select avg(country.IndepYear), avg(country.Population)",
            "select avg(country.LifeExpectancy), avg(country.Population)",
            "select avg(country.GNP), total(country.Population)",
            "select sum(country.Population), avg(country.GNP)",
            "select sum(country.GNP), avg(country.GNP)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average Gross National Product and total population for the countries listed whose governments formed part of US Territory?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (US Territory), c12: headofstate, c13: capital, c14: code2 (US)). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which nations use English or Dutch as their official tongue?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-DECLARATION-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which nations use English or Dutch as their official tongue?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select *",
        "score": false,
        "real_pred": "select country.Name",
        "real_label": "select *",
        "topk_preds": [
            "select country.Name",
            "select country.Name, countrylanguage.CountryCode",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select country.Name, country.Continent",
            "select country.Name, country.Code",
            "select country.Name, country.Region",
            "select countrylanguage.CountryCode",
            "select country.Name, country.Capital"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which nations use English or Dutch as their official tongue?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English, Dutch), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t2 t3",
        "score": false,
        "real_pred": "countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which language is spoken by the largest number of Asian countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-WHERE-GROUPS-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which language is spoken by the largest number of Asian countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Code2",
            "select countrylanguage.Language, country.Continent",
            "select countrylanguage.Language (country.Name)",
            "select countrylanguage.Language, country.HeadOfState"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which language is spoken by the largest number of Asian countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "city country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me languages that only one country uses which has a republic structure., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-REGULATION-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me languages that only one country uses which has a republic structure., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.LocalName",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Name",
            "select distinct countrylanguage.Language",
            "select countrylanguage.Language, country.GovernmentForm",
            "select countrylanguage.Language, country.Code",
            "select exclusive countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me languages that only one country uses which has a republic structure., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "city country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the name, population and expected life span of the Asian country with the largest surface area., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, t2.c1, t2.c6, t2.c7",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the name, population and expected life span of the Asian country with the largest surface area., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c7",
        "label": "select t2.c1, t2.c6, t2.c7",
        "score": true,
        "real_pred": "select country.Name, country.Population, country.LifeExpectancy",
        "real_label": "select country.Name, country.Population, country.LifeExpectancy",
        "topk_preds": [
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.IndepYear, country.Population, country.LifeExpectancy",
            "select country.Name, country.Code, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy, country.GNP",
            "select country.Name, country.Population, country.LifeExpectancy, country.LifeExpectancy",
            "select country.Name), country.Population, country.LifeExpectancy",
            "select country.Name, country.Population), country.LifeExpectancy"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the name, population and expected life span of the Asian country with the largest surface area., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent (Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me the average age at which people die in which country their mother tongue is not the same as English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (AVERAGE(t2.c7)",
            "SELECT-FROM-WHERE -GROUP BY-HAVING",
            "SELECT-FROM-WHERE/GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me the average age at which people die in which country their mother tongue is not the same as English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.Language",
            "select an avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.CountryCode",
            "select avg(country.LifeExpectancy), country.Name",
            "select avg(country.Population)",
            "select avg(country.LifeExpectancy), country.Code",
            "select avg(t2, t3.c7)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me the average age at which people die in which country their mother tongue is not the same as English., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What is the average life span in the countries that don't use English as an official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (avg(t2.c7)",
            "SELECT-FROM-WHERE (Avg(t2.c7)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What is the average life span in the countries that don't use English as an official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.Language",
            "select an avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.CountryCode",
            "select avg(country.LifeExpectancy), countrylanguage.IsOfficial",
            "select avg(country.LifeExpectancy",
            "select avg(country.LifeExpectancy), country.Code",
            "select  avg(country.LifeExpectancy)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What is the average life span in the countries that don't use English as an official language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name (Spain), c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "country",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the mean life expectancy of countries where English is not the national language, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (Avg(t2.c7)",
            "SELECT-FROM-WHERE (avg(t2.c7)",
            "SELECT-FROM-WHERE\u00adGROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the mean life expectancy of countries where English is not the national language, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select avg(t2.c7)",
        "label": "select avg(t2.c7)",
        "score": true,
        "real_pred": "select avg(country.LifeExpectancy)",
        "real_label": "select avg(country.LifeExpectancy)",
        "topk_preds": [
            "select avg(country.LifeExpectancy)",
            "select an avg(country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), countrylanguage.Language",
            "select avg(country.LifeExpectancy), countrylanguage.CountryCode",
            "select avg(country.LifeExpectancy), country.Code",
            "select avg(t2, country.LifeExpectancy)",
            "select avg(country.LifeExpectancy), country.Name",
            "select avg(country.LifeExpectancy"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the mean life expectancy of countries where English is not the national language, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "country",
            "",
            "",
            "",
            "sqlite_sequence countrylanguage"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me information about the national language of the country whose head of state's name is Beatrix., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate (Beatrix), c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me information about the national language of the country whose head of state's name is Beatrix., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate (Beatrix), c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.LocalName",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.HeadOfState",
            "select countrylanguage.Language, countrylanguage.IsOfficial",
            "select countrylanguage.Language, country.Continent",
            "select countrylanguage.Language, countrylanguage.IsOfficial"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me information about the national language of the country whose head of state's name is Beatrix., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate (Beatrix), c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which African nations contain fewer people than any country in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which African nations contain fewer people than any country in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.LocalName",
            "select country.Name, country.IndepYear",
            "select country.Code, country.Name",
            "select distinct country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which African nations contain fewer people than any country in Asia?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show the names of African countries which have fewer inhabitants than any country in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNDER-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show the names of African countries which have fewer inhabitants than any country in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.IndepYear",
            "select country.Name, country.LocalName",
            "select country.Name, country.Code",
            "select country.Name, country.SurfaceArea"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show the names of African countries which have fewer inhabitants than any country in Asia., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Asia, Africa), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries belonging to the continents named Africa have even fewer residents than any Asian nations?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNDER-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INCORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries belonging to the continents named Africa have even fewer residents than any Asian nations?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Continent",
            "select country.Code, country.Name",
            "select country.Name, country.Region",
            "select sub-clause country.Name",
            "select country.Name, country.Code",
            "select country.Name, country.HeadOfState"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries belonging to the continents named Africa have even fewer residents than any Asian nations?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "sqlite_sequence country",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Do you have information on which Asian countries have more people than all African countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Do you have information on which Asian countries have more people than all African countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.Continent",
            "select country.Name, country.IndepYear",
            "select distinct country.Name",
            "select country.Name de country.Continent"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Do you have information on which Asian countries have more people than all African countries?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Africa, Asia), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which are the codes of countries which speak a different language than English and whose government does not follow a republic system of government?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which are the codes of countries which speak a different language than English and whose government does not follow a republic system of government?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c0",
        "label": "select t2.c0",
        "score": true,
        "real_pred": "select country.Code",
        "real_label": "select country.Code",
        "topk_preds": [
            "select country.Code",
            "select country.Code2",
            "select country.Name",
            "select countrylanguage.CountryCode",
            "select country.SurfaceArea",
            "select country.Capital",
            "select country.Code0",
            "select country.Code4"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which are the codes of countries which speak a different language than English and whose government does not follow a republic system of government?., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to see the codes of countries which don't speak English and for whose the government types aren't republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHEAT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-NEW-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to see the codes of countries which don't speak English and for whose the government types aren't republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c0",
        "label": "select t2.c0",
        "score": true,
        "real_pred": "select country.Code",
        "real_label": "select country.Code",
        "topk_preds": [
            "select country.Code",
            "select country.Code, countrylanguage.Language",
            "select country.Name, country.Code2",
            "select country.Code, country.Name",
            "select country.Name, country.GovernmentForm",
            "select country.Name, country.Capital",
            "select country.Name",
            "select country.Name, country.Code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to see the codes of countries which don't speak English and for whose the government types aren't republics., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform (Republic), c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t2 t3",
        "score": true,
        "real_pred": "country countrylanguage",
        "real_label": "country countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "",
            "",
            "sqlite_sequence countrylanguage",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please indicate European cities that do not speak English as their mother tongue below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please indicate European cities that do not speak English as their mother tongue below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select city.Name",
        "real_label": "select distinct city.Name",
        "topk_preds": [
            "select city.Name",
            "select distinct city.Name",
            "select city.ID, city.Name",
            "select city.Name, country.Continent",
            "select city.Name, country.Code",
            "select city.Name, country.Capital",
            "select city.Name, country.Name",
            "select city.Name, countrylanguage.Language"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please indicate European cities that do not speak English as their mother tongue below., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (English), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t0 t2 t3",
        "label": "t0 t2 t3",
        "score": true,
        "real_pred": "city country countrylanguage",
        "real_label": "city country countrylanguage",
        "topk_preds": [
            "city country countrylanguage",
            "",
            "city sqlite_sequence country countrylanguage",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the different types of governments and what are their populations for those that had an average life expectancy above 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOGRAPHY-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOGRAPHIC-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the different types of governments and what are their populations for those that had an average life expectancy above 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c11, t2.c6",
        "label": "select sum(t2.c6), t2.c11",
        "score": false,
        "real_pred": "select country.GovernmentForm, country.Population",
        "real_label": "select sum(country.Population), country.GovernmentForm",
        "topk_preds": [
            "select country.GovernmentForm, country.Population",
            "select country.Name, country.Population",
            "select country.GNPOld, country.GovernmentForm, country.Population",
            "select country.GovernmentForm, count(*)",
            "select country.Capital, country.Population",
            "select country.GovernmentForm, sum(country.Population)",
            "select country.LocalName, country.Population",
            "select t2.c 11, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the different types of governments and what are their populations for those that had an average life expectancy above 72?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the names of the continents and their populations and lifespans which have an average life expectancy below 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GEOGRAPHY-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BYHAVE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the names of the continents and their populations and lifespans which have an average life expectancy below 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1, t2.c6, t2.c7",
        "label": "select sum(t2.c6), avg(t2.c7), t2.c2",
        "score": false,
        "real_pred": "select country.Name, country.Population, country.LifeExpectancy",
        "real_label": "select sum(country.Population), avg(country.LifeExpectancy), country.Continent",
        "topk_preds": [
            "select country.Name, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, avg(country.LifeExpectancy)",
            "select country.Name, country.IndepYear, country.Population, avg(country.LifeExpectancy)",
            "select country.Name, country.Continent, country.Population, country.LifeExpectancy",
            "select country.Name, country.Continent, country.Population, avg(country.LifeExpectancy)",
            "select country.Name, country.IndepYear, country.Population, country.LifeExpectancy",
            "select country.Continent, country.Population, country.LifeExpectancy",
            "select country.Name, country.Population, country.LifeExpectancy"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the names of the continents and their populations and lifespans which have an average life expectancy below 72., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to see the names of the three smallest countries in terms of population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY - LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to see the names of the three smallest countries in terms of population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Capital",
            "select country.Name, country.Code",
            "select country.Name, country.Population",
            "select country.Name, country.HeadOfState",
            "select country.Name, country.LocalName",
            "select country.Name, country.Region",
            "select country.Name, country.Code2"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to see the names of the three smallest countries in terms of population., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me about all the European nations where their populations that exceed 8000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ACT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ACT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me about all the European nations where their populations that exceed 8000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select distinct country.Name",
            "select country.Name, country.Continent",
            "select distinct country.Name, country.Continent",
            "select European country.Name",
            "select country.Name, country.Population",
            "select european country.Name",
            "select distinct country.Name, country.Population"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me about all the European nations where their populations that exceed 8000., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of all the European countries, give me the exact names. Please show me those countries which have more than 80000 people residing in them., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of all the European countries, give me the exact names. Please show me those countries which have more than 80000 people residing in them., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t2.c1",
        "label": "select t2.c1",
        "score": true,
        "real_pred": "select country.Name",
        "real_label": "select country.Name",
        "topk_preds": [
            "select country.Name",
            "select country.Name, country.Continent",
            "select distinct country.Name",
            "select exact country.Name",
            "select country.Name, country.Population",
            "select country.Name, country.Region",
            "select country.Name, country.Capital",
            "select country.Name, country.Name6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of all the European countries, give me the exact names. Please show me those countries which have more than 80000 people residing in them., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (Europe), c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "city country",
            "",
            "",
            "sqlite_sequence country",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I am interested in knowing about the total population and average surface area of all countries located on North America whose surface area has exceeded 3000., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-AGGRESS-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-AGGRESS-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I am interested in knowing about the total population and average surface area of all countries located on North America whose surface area has exceeded 3000., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select sum(t2.c6), avg(t2.c4)",
        "label": "select sum(t2.c6), avg(t2.c4)",
        "score": true,
        "real_pred": "select sum(country.Population), avg(country.SurfaceArea)",
        "real_label": "select sum(country.Population), avg(country.SurfaceArea)",
        "topk_preds": [
            "select sum(country.Population), avg(country.SurfaceArea)",
            "select avg(country.Population), sum(country.Population)",
            "select sum(country.Population), avg(country.Population)",
            "select total(country.Population), avg(country.SurfaceArea)",
            "select sum(country.Population), avg(country.GNP)",
            "select country.Population, avg(country.SurfaceArea)",
            "select sum(country.Population), avg(country.SurfaceArea).",
            "select sum(country.Population), avg(country.IndepYear)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I am interested in knowing about the total population and average surface area of all countries located on North America whose surface area has exceeded 3000., database: Database: world_1. t0: city(c0: id, c1: name (Americana), c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent (North America), c3: region (North America), c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "country",
        "real_label": "country",
        "topk_preds": [
            "country",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know which language the largest amount of people speak in each country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know which language the largest amount of people speak in each country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Code",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.Language, country.Population",
            "select countrylanguage.Language, country.Code2",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select country.Name, countrylanguage.CountryCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know which language the largest amount of people speak in each country., database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "country countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "city country countrylanguage",
            "",
            "sqlite_sequence country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which countries speak which languages as a predominant language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which countries speak which languages as a predominant language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c1",
        "label": "select t3.c1, t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.Language",
        "real_label": "select countrylanguage.Language, countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.Language",
            "select countrylanguage.Language, country.Name",
            "select countrylanguage.CountryCode, countrylanguage.Language",
            "select country.Name, countrylanguage.Language",
            "select countrylanguage.Language, country.Capital",
            "select countrylanguage.Language, country.Code",
            "select country.Name, country.Continent",
            "select country.Name, countrylanguage.CountryCode"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which countries speak which languages as a predominant language?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language, c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t2 t3",
        "label": "t3",
        "score": false,
        "real_pred": "country countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "country countrylanguage",
            "sqlite_sequence country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "",
            "countrylanguage",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the codes of those countries where the highest proportion of population speak Spanish?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "label": "SELECT-FROM-WHERE-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-WHERE-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the codes of those countries where the highest proportion of population speak Spanish?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "select t3.c0",
        "label": "select t3.c0, max(t3.c3)",
        "score": false,
        "real_pred": "select countrylanguage.CountryCode",
        "real_label": "select countrylanguage.CountryCode, max(countrylanguage.Percentage)",
        "topk_preds": [
            "select countrylanguage.CountryCode",
            "select country.Code",
            "select country.Name, country.Continent",
            "select country.Name, country.Code2",
            "select country.Name, country.Code",
            "select country.Name, countrylanguage.CountryCode",
            "select country.Code2",
            "select country.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the codes of those countries where the highest proportion of population speak Spanish?, database: Database: world_1. t0: city(c0: id, c1: name, c2: countrycode, c3: district, c4: population) (c2) refers to t2(c0). t1: sqlite_sequence(c0: name, c1: seq). t2: country(c0: code, c1: name, c2: continent, c3: region, c4: surfacearea, c5: indepyear, c6: population, c7: lifeexpectancy, c8: gnp, c9: gnpold, c10: localname, c11: governmentform, c12: headofstate, c13: capital, c14: code2). t3: countrylanguage(c0: countrycode, c1: language (Spanish), c2: isofficial, c3: percentage) (c0) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "countrylanguage",
        "real_label": "countrylanguage",
        "topk_preds": [
            "countrylanguage",
            "country countrylanguage",
            "city country countrylanguage",
            "sqlite_sequence countrylanguage",
            "sqlite_sequence country countrylanguage",
            "",
            "city countrylanguage",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the record companies that were used by orchestras created before 2003 as well as those created after 2003., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE/INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE,-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE AND-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-EITHER-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the record companies that were used by orchestras created before 2003 as well as those created after 2003., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company for both orchestra.Year_of_Founded, orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.Year_of_Founded",
            "select orchestra.Record_Company for both orchestra.Year_of_Founded, orchestra.Major_Record_Format",
            "select orchestra.Record_Company for both orchestra.Year_of_Founded & orchestra.Record_Company",
            "select orchestra.Record_Company for both orchestra.Year_of_Founded, t1.c6",
            "select orchestra.Conductor_ID, orchestra.Record_Company",
            "select orchestra.Record_Company for both orchestra.Year_of_Founded, orchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the record companies that were used by orchestras created before 2003 as well as those created after 2003., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: In your opinion, which record companies were used by orchestras made prior to 2003 and those made after 2003?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE AND-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE.",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: In your opinion, which record companies were used by orchestras made prior to 2003 and those made after 2003?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.Year_of_Founded",
            "select orchestra.Record_Company for both orchestra.Year_of_Founded, orchestra.Record_Company",
            "select orchestra.Record_Company for both orchestra.Year_of_Founded, orchestra.Major_Record_Format",
            "select orchestra.Record_Company for both orchestra.Year_of_Founded, orchestra.Orchestra",
            "select orchestra.Conductor_ID, orchestra.Record_Company",
            "select orchestra.Record_Company for both orchestra.Year_of_Founded, t1.c6",
            "select orchestra.Record_Company for both orchestra.Year_of_Founded, orchestra.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: In your opinion, which record companies were used by orchestras made prior to 2003 and those made after 2003?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please show me the names of conductors which do not come from the USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please show me the names of conductors which do not come from the USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Age",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please show me the names of conductors which do not come from the USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list all conductors whose countries are not USA below., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list all conductors whose countries are not USA below., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Conductor_ID, conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list all conductors whose countries are not USA below., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "conductor orchestra performance",
            "conductor orchestra",
            "",
            "conductor orchestra show",
            "",
            "",
            "conductor performance"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Record a list of conductors whose citizenships are not USA below., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Record a list of conductors whose citizenships are not USA below., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Nationality",
            "select distinct conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Record a list of conductors whose citizenships are not USA below., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the list containing the names of conductors which does not belong to 'USA'., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the list containing the names of conductors which does not belong to 'USA'., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Age",
            "select conductor.Name, conductor.Nationality, max(conductor.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the list containing the names of conductors which does not belong to 'USA'., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "conductor performance",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please return the names of conductors which are not from the USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please return the names of conductors which are not from the USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Age",
            "select conductor.Name, conductor.Age",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, max(conductor.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please return the names of conductors which are not from the USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the names of conductors who do not come from the USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the names of conductors who do not come from the USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Name, conductor.Nationality, conductor.Year_of_Work",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Nationality, conductor.Age",
            "select conductor.Name, conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (or conductor.Age)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the names of conductors who do not come from the USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List down the conductors' names that did not originate from USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List down the conductors' names that did not originate from USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Name, conductor.Age",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name - conductor.Nationality",
            "select conductor.Name (not conductor.Age)",
            "select conductor.Name, conductor.Nationality,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List down the conductors' names that did not originate from USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want to find out the conductors who don't belong to USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want to find out the conductors who don't belong to USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select conductor.Conductor_ID",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Conductor_ID",
            "select conductor.Name",
            "select conductor.Name, conductor.Nationality",
            "select conductor.Conductor_ID, conductor.Name",
            "select conductor.Conductor_ID, conductor.Nationality",
            "select conductor.Age, conductor.Nationality",
            "select conductor.Name, conductor.Age",
            "select conductor.Conductor_ID, conductor.Age"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want to find out the conductors who don't belong to USA., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality (USA), c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "conductor",
        "real_label": "conductor",
        "topk_preds": [
            "conductor",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please return records of orchestras, sorted descending by the years in which they were founded., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c1",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM\u2013ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM,-ORDER BY",
            "SELECT-FROM-ORDER BY t1.c0"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please return records of orchestras, sorted descending by the years in which they were founded., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c1",
        "label": "select t1.c3",
        "score": false,
        "real_pred": "select orchestra.Orchestra",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Orchestra",
            "select orchestra.Orchestra, orchestra.Year_of_Founded",
            "select orchestra.Orchestra (orchestrated orchestra.Conductor_ID)",
            "select orchestra.Orchestra (orchestrated orchestra.Orchestra_ID)",
            "select orchestra.Orchestra, orchestra.Conductor_ID",
            "select orchestra.Orchestra_ID",
            "select orchestra.Orchestra (orchestrated orchestra.Year_of_Founded)",
            "select orchestra.Orchestra (orchestration BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please return records of orchestras, sorted descending by the years in which they were founded., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter the average number of people who went to these events., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY (ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY.ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY (ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter the average number of people who went to these events., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select avg(t3.c4)",
        "label": "select avg(t3.c4)",
        "score": true,
        "real_pred": "select avg(show.Attendance)",
        "real_label": "select avg(show.Attendance)",
        "topk_preds": [
            "select avg(show.Attendance)",
            "select an avg(show.Attendance)",
            "select the avg(show.Attendance)",
            "select avg(t3.c8)",
            "select  avg(show.Attendance)",
            "select avg(t3.c6)",
            "select avg(t3.c5)",
            "select avg(t3,c4)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter the average number of people who went to these events., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t3",
        "label": "t3",
        "score": true,
        "real_pred": "show",
        "real_label": "show",
        "topk_preds": [
            "show",
            "performance show",
            "",
            "orchestra show",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the maximum and minimum percentage of performances that do not fall under the category of Live final., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY max(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY max(t2.c4), min(t2.c4)",
            "SELECT-FROM-WHERE-GROUP BY maximum(t2.c6), min(t2.c6)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the maximum and minimum percentage of performances that do not fall under the category of Live final., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select max(t2.c6), min(t2.c6)",
        "label": "select max(t2.c6), min(t2.c6)",
        "score": true,
        "real_pred": "select max(performance.Share), min(performance.Share)",
        "real_label": "select max(performance.Share), min(performance.Share)",
        "topk_preds": [
            "select max(performance.Share), min(performance.Share)",
            "select max(performance.Official_ratings_in_millions), min(performance.Official_ratings_in_millions)",
            "select max(t2.c8), min(t2.c8)",
            "select max(performance.Performance_ID), min(performance.Performance_ID)",
            "select max(performance.Type), min(performance.Official_ratings_in_millions)",
            "select max(performance.Weekly_rank), min(performance.Weekly_rank)",
            "select max(t2.c7), min(t2.c7)",
            "select max(performance.Date), min(performance.Official_ratings_in_millions)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the maximum and minimum percentage of performances that do not fall under the category of Live final., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "performance",
        "real_label": "performance",
        "topk_preds": [
            "performance",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the largest and smallest percentage of performances whose type is not \"Live final\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY max(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE-GROUP BY max(t2.c4), min(t2.c4)",
            "SELECT-FROM-WHERE-GROUPT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the largest and smallest percentage of performances whose type is not \"Live final\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select max(t2.c6), min(t2.c6)",
        "label": "select max(t2.c6), min(t2.c6)",
        "score": true,
        "real_pred": "select max(performance.Share), min(performance.Share)",
        "real_label": "select max(performance.Share), min(performance.Share)",
        "topk_preds": [
            "select max(performance.Share), min(performance.Share)",
            "select max(performance.Official_ratings_in_millions), min(performance.Official_ratings_in_millions)",
            "select max(performance.Weekly_rank), min(performance.Weekly_rank)",
            "select max(performance.Type), min(performance.Official_ratings_in_millions)",
            "select max(t2.c8), min(t2.c8)",
            "select max(performance.Date), min(performance.Date)",
            "select max(t2.c7), min(t2.c7)",
            "select max(performance.Orchestra_ID), min(performance.Official_ratings_in_millions)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the largest and smallest percentage of performances whose type is not \"Live final\"?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "performance",
        "real_label": "performance",
        "topk_preds": [
            "performance",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the maximum and minimum values for the ratio of performances whose type is not Live final?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE.MAX(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE, MAX(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE.MAX(t2.c4), min(t2.c4)",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the maximum and minimum values for the ratio of performances whose type is not Live final?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select max(t2.c6), min(t2.c6)",
        "label": "select max(t2.c6), min(t2.c6)",
        "score": true,
        "real_pred": "select max(performance.Share), min(performance.Share)",
        "real_label": "select max(performance.Share), min(performance.Share)",
        "topk_preds": [
            "select max(performance.Share), min(performance.Share)",
            "select max(performance.Official_ratings_in_millions), min(performance.Official_ratings_in_millions)",
            "select max(t2.c8), min(t2.c8)",
            "select max(performance.Weekly_rank), min(performance.Weekly_rank)",
            "select max(t2.c7), min(t2.c7)",
            "select max(performance.Type), min(performance.Official_ratings_in_millions)",
            "select max(performance.Orchestra_ID), min(performance.Official_ratings_in_millions)",
            "select max(performance.Date), min(performance.Official_ratings_in_millions)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the maximum and minimum values for the ratio of performances whose type is not Live final?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "performance",
        "real_label": "performance",
        "topk_preds": [
            "performance",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want to see the maximum and minimum stakes on performances which did not have Live Final., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE (MAX(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE Max(t2.c6), min(t2.c6)",
            "SELECT-FROM-WHERE Maximum(t2.c6), Min(t2.c6)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want to see the maximum and minimum stakes on performances which did not have Live Final., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select max(t2.c6), min(t2.c6)",
        "label": "select max(t2.c6), min(t2.c6)",
        "score": true,
        "real_pred": "select max(performance.Share), min(performance.Share)",
        "real_label": "select max(performance.Share), min(performance.Share)",
        "topk_preds": [
            "select max(performance.Share), min(performance.Share)",
            "select max(t2.c8), min(performance.Share)",
            "select max(t2.c7), min(performance.Share)",
            "select max(performance.Official_ratings_in_millions), min(performance.Share)",
            "select max(performance.Weekly_rank), min(performance.Share)",
            "select max(performance.Date), min(performance.Share)",
            "select max(performance.Share ), min(performance.Share)",
            "select max(performance.Share), min(performance.Share)."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want to see the maximum and minimum stakes on performances which did not have Live Final., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type (Live final), c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t2",
        "label": "t2",
        "score": true,
        "real_pred": "performance",
        "real_label": "performance",
        "topk_preds": [
            "performance",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please indicate the name of the conductor who has been appointed to conduct orchestras established after 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INDICATE-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CONDIT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-CONDUCTOR"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please indicate the name of the conductor who has been appointed to conduct orchestras established after 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select conductor.Name",
        "real_label": "select conductor.Name",
        "topk_preds": [
            "select conductor.Name",
            "select conductor.Name, orchestra.Conductor_ID",
            "select conductor.Name, orchestra.Year_of_Founded",
            "select conductor.Name (or conductor.Age)",
            "select conductor.Name (ORDER BY-LIMIT)",
            "select conductor.Name, orchestra.Orchestra_ID",
            "select conductor.Name (ORDER BY-LIMIT",
            "select distinct conductor.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please indicate the name of the conductor who has been appointed to conduct orchestras established after 2008., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "conductor orchestra",
        "real_label": "conductor orchestra",
        "topk_preds": [
            "conductor orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need information about the main recording formats for orchestras, according to their popularity., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need information about the main recording formats for orchestras, according to their popularity., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c5",
        "label": "select t1.c5",
        "score": true,
        "real_pred": "select orchestra.Major_Record_Format",
        "real_label": "select orchestra.Major_Record_Format",
        "topk_preds": [
            "select orchestra.Major_Record_Format",
            "select orchestra.Major_Record_Format, t1.c6",
            "select orchestra.Major_Record_Format, orchestra.Year_of_Founded",
            "select orchestra.Major_Record_Format (ORDER BY-LIMIT)",
            "select orchestra.Major_Record_Format, t1.c7",
            "select orchestra.Major_Record_Format, orchestra.Record_Company",
            "select orchestra.Major_Record_Format, orchestra.Conductor_ID",
            "select orchestra.Major_Record_Format, t1.c8"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need information about the main recording formats for orchestras, according to their popularity., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the most common record formats used by orchestras, in descending order., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SQL-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the most common record formats used by orchestras, in descending order., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c5",
        "label": "select t1.c5",
        "score": true,
        "real_pred": "select orchestra.Major_Record_Format",
        "real_label": "select orchestra.Major_Record_Format",
        "topk_preds": [
            "select orchestra.Major_Record_Format",
            "select top-ten-record-formats-in-descending-order",
            "select orchestra.Major_Record_Format, t1.c6",
            "select top-ten-record-formats-in-c5-ORDER BY-LIMIT",
            "select top-ten-record-formats-in-descending-ordnance",
            "select top-ten-record-formats-in-c5-ordinal",
            "select top-ten-record-formats-in-descending-ordinal",
            "select top-ten-record-formats-in-gr.-ordered by-importance"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the most common record formats used by orchestras, in descending order., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the most commonly used orchestra recording formats, sorted by frequency., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SQL-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-CENTER",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SQL-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-CAP",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-CROSS-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the most commonly used orchestra recording formats, sorted by frequency., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c5",
        "label": "select t1.c5",
        "score": true,
        "real_pred": "select orchestra.Major_Record_Format",
        "real_label": "select orchestra.Major_Record_Format",
        "topk_preds": [
            "select orchestra.Major_Record_Format",
            "select top-ten-recording-formats-in-GROUP BY-ORDER BY-LIMIT",
            "select top-ten-recording-formats-in-gROUP BY-ORDER BY-LIMIT",
            "select orchestra.Major_Record_Format, t1.c6",
            "select top-ten-recording-formats-in-gr.-ordered",
            "select top-ten-recording-formats-in-c5-ordered",
            "select top-ten-recording-formats-in-gr.-ordered by-favorites",
            "select top-ten-recording-formats-in-gr.-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the most commonly used orchestra recording formats, sorted by frequency., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the most common record formats for orchestras, ranked by their occurrence?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SQL-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SQL-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SQL-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the most common record formats for orchestras, ranked by their occurrence?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c5",
        "label": "select t1.c5",
        "score": true,
        "real_pred": "select orchestra.Major_Record_Format",
        "real_label": "select orchestra.Major_Record_Format",
        "topk_preds": [
            "select orchestra.Major_Record_Format",
            "select orchestra.Major_Record_Format, t1.c6",
            "select orchestra.Major_Record_Format, orchestra.Year_of_Founded",
            "select orchestra.Major_Record_Format, t1.c7",
            "select orchestra.Major_Record_Format, orchestra.Conductor_ID",
            "select orchestra.Major_Record_Format, t1.c8",
            "select orchestra.Major_Record_Format, orchestra.Record_Company",
            "select orchestra.Major_Record_Format, orchestra.Orchestra"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the most common record formats for orchestras, ranked by their occurrence?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What are the most frequent record formats for orchestras, sorted by their frequency?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SQL-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SCALE-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SQL-UNION-SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What are the most frequent record formats for orchestras, sorted by their frequency?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c5",
        "label": "select t1.c5",
        "score": true,
        "real_pred": "select orchestra.Major_Record_Format",
        "real_label": "select orchestra.Major_Record_Format",
        "topk_preds": [
            "select orchestra.Major_Record_Format",
            "select top-ten-record-formats-in-GROUP BY-ORDER BY-LIMIT",
            "select top-ten-record-formats-in-gROUP BY-ORDER BY-LIMIT",
            "select top-ten-record-formats-in-c5-ordered by-gROUP BY-LIMIT",
            "select orchestra.Major_Record_Format, t1.c6",
            "select top-ten-record-formats-in-gr.1-ORDER BY-LIMIT",
            "select top-ten-record-formats-in-gr.-ORDER BY-LIMIT",
            "select top-ten-record-formats-in-gr.-ordered by-favorites"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What are the most frequent record formats for orchestras, sorted by their frequency?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which music company has been credited to be involved with the largest quantity of orchestras worldwide?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which music company has been credited to be involved with the largest quantity of orchestras worldwide?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.Year_of_Founded",
            "select orchestra.Record_Company, orchestra.Conductor_ID",
            "select orchestra.Record_Company (http://www.orchestra.Record_Company)",
            "select orchestra.Record_Company (http://orchestra.Record_Company)",
            "select orchestra.Record_Company, t1.c6",
            "select orchestra.Record_Company, orchestra.Major_Record_Format",
            "select orchestra.Record_Company (orchestra.Year_of_Founded)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which music company has been credited to be involved with the largest quantity of orchestras worldwide?, database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The records companies which are signed by orchestra created before 2003 and those created after 2004 should be shown., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISPLAY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINGUISH-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The records companies which are signed by orchestra created before 2003 and those created after 2004 should be shown., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select t1.c3",
        "label": "select t1.c3",
        "score": true,
        "real_pred": "select orchestra.Record_Company",
        "real_label": "select orchestra.Record_Company",
        "topk_preds": [
            "select orchestra.Record_Company",
            "select orchestra.Record_Company, orchestra.Year_of_Founded",
            "select orchestra.Record_Company, orchestra.Conductor_ID",
            "select orchestra.Record_Company and orchestra.Year_of_Founded",
            "select orchestra.Record_Company, orchestra.Orchestra",
            "select orchestra.Conductor_ID, orchestra.Record_Company",
            "select orchestra.Record_Company, t1.c6",
            "select orchestra.Record_Company, orchestra.Major_Record_Format"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The records companies which are signed by orchestra created before 2003 and those created after 2004 should be shown., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please indicate the number of orchestras on the following table that used the recording medium CD or DVD., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please indicate the number of orchestras on the following table that used the recording medium CD or DVD., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), orchestra.Major_Record_Format",
            "select count(*),",
            "select count(*) the orchestra.Orchestra_ID",
            "select count(*), orchestra.Major_Record_Format",
            "select count(*), orchestra.Major_Record_Format,",
            "select count(*) the orchestra.Orchestra",
            "select count(*), orchestra.Orchestra_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please indicate the number of orchestras on the following table that used the recording medium CD or DVD., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I'd like to find the number of orchestras on CD or DVD format., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I'd like to find the number of orchestras on CD or DVD format., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*) I don't care if they're on a major-record-format (DVD, CD)",
            "select count(*) I don't care if they're on a major-recording-format (DVD, CD)",
            "select count(*) I don't care if they're on a major-record_format (DVD, CD)",
            "select count(*) I don't care if they're on a major_record_format (DVD, CD)",
            "select count(*) I don't care if they're on a major-record-format (CD, DVD)",
            "select count(*) I don't care if they're on a major-record-format (DVD, CD).",
            "select count(*) I don't care if they're on a major-recording-format (CD, DVD)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I'd like to find the number of orchestras on CD or DVD format., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please count the number of orchestras that have CD or DVD as their recording medium., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please count the number of orchestras that have CD or DVD as their recording medium., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), orchestra.Major_Record_Format",
            "select count(*),",
            "select count(*), orchestra.Orchestra_ID",
            "select count(*), orchestra.Orchestra",
            "select count(*) the orchestra.Orchestra",
            "select count(*), orchestra.Year_of_Founded",
            "select count(*) (http://orchestra.Orchestra)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please count the number of orchestras that have CD or DVD as their recording medium., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format (DVD, CD)) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List the numbers of orchestras which used CDs or DVDs as records., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List the numbers of orchestras which used CDs or DVDs as records., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), orchestra.Major_Record_Format",
            "select count(distinct orchestra.Orchestra)",
            "select count(*), orchestra.Orchestra_ID",
            "select count(*), orchestra.Record_Company",
            "select count(*), orchestra.Orchestra",
            "select count(*), orchestra.Year_of_Founded",
            "select count(*), orchestra.Conductor_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List the numbers of orchestras which used CDs or DVDs as records., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter the number of orchestras that use CD/DVD as a major format below., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE_GROUP BY",
            "SELECT-FROM-WHERE, count(*)",
            "SELECT-FROM-WHERE (count(*)",
            "SELECT-FROM-WHERE count(*)",
            "SELECT-FROM-WHERE (*)",
            "SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter the number of orchestras that use CD/DVD as a major format below., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "select count(*)",
        "label": "select count(*)",
        "score": true,
        "real_pred": "select count(*)",
        "real_label": "select count(*)",
        "topk_preds": [
            "select count(*)",
            "select count(*), orchestra.Major_Record_Format",
            "select count(*) the SELECT-FROM-WHERE",
            "select count(*), orchestra.Major_Record_Format, t1.c6",
            "select count(*), orchestra.Major_Record_Format, t1.c7",
            "select count(*), orchestra.Major_Record_Format - t1.c6",
            "select count(*),",
            "select count(*), orchestra.Major_Record_Format, orchestra.Year_of_Founded"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter the number of orchestras that use CD/DVD as a major format below., database: Database: orchestra. t0: conductor(c0: conductor_id, c1: name, c2: age, c3: nationality, c4: year_of_work). t1: orchestra(c0: orchestra_id, c1: orchestra, c2: conductor_id, c3: record_company, c4: year_of_founded, c5: major_record_format) (c2) refers to t0(c0). t2: performance(c0: performance_id, c1: orchestra_id, c2: type, c3: date, c4: official_ratings_in_millions, c5: weekly_rank, c6: share) (c1) refers to t1(c0). t3: show(c0: show_id, c1: performance_id, c2: if_first_show, c3: result, c4: attendance) (c1) refers to t2(c0).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "orchestra",
        "real_label": "orchestra",
        "topk_preds": [
            "orchestra",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter the email addresses, cell numbers and home phones of each employee here., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code (Employee), c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-POSITION-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter the email addresses, cell numbers and home phones of each employee here., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code (Employee), c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c10, t6.c9",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": true,
        "real_pred": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
            "select Professionals.email_address, Professionals.home_phone, Professionals.home_phone",
            "select Professionals.email_address, Professionals.professional_id9, Professionals.home_phone",
            "select Professionals.email_address, Professionals.home_phone, Professionals.email_address",
            "select Professionals.email_address, t6.cten, Professionals.home_phone",
            "select Professionals.email_address, Professionals.role_code5, Professionals.home_phone",
            "select Professionals.email_address, Professionals.role_code3, Professionals.home_phone",
            "select Professionals.last_name, Professionals.cell_number, Professionals.home_phone"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter the email addresses, cell numbers and home phones of each employee here., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code (Employee), c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please provide the email addresses, mobile numbers, home phone numbers of all employees in order., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code (Employee), c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (*)",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY(t6.c8)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please provide the email addresses, mobile numbers, home phone numbers of all employees in order., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code (Employee), c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c10, t6.c9",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": true,
        "real_pred": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
            "select Professionals.email_address, Professionals.home_phone, Professionals.home_phone",
            "select Professionals.email_address, Professionals.professional_id9, Professionals.home_phone",
            "select Professionals.email_address, Professionals.home_phone, Professionals.home_phone",
            "select Professionals.email_address, Professionals.role_code1, Professionals.home_phone",
            "select Professionals.email_address, Professionals.role_code3, Professionals.home_phone",
            "select Professionals.email_address, Professionals.role_code5, Professionals.home_phone",
            "select Professionals.email_address, Professionals.home_phone, Professionals.email_address"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please provide the email addresses, mobile numbers, home phone numbers of all employees in order., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code (Employee), c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the e-mail, telephone number and home phone of each of your professionals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the e-mail, telephone number and home phone of each of your professionals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c9, t6.c9",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": false,
        "real_pred": "select Professionals.email_address, Professionals.home_phone, Professionals.home_phone",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.email_address, Professionals.home_phone, Professionals.home_phone",
            "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
            "select Professionals.email_address, Professionals.professional_id9, Professionals.home_phone",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.professional_id9",
            "select Professionals.email_address, Professionals.home_phone.c9, Professionals.home_phone",
            "select Professionals.email_address, Professionals.home_phone, Professionals.home_phone",
            "select Professionals.email_address, Professionals.home_phone0, Professionals.home_phone"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the e-mail, telephone number and home phone of each of your professionals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please send me the email address, home phone and cellular number of each professional., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please send me the email address, home phone and cellular number of each professional., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c9, t6.c10",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": false,
        "real_pred": "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number.",
            "select Professionals.email_address, Professionals.home_phone, Professionals.professional_id",
            "select Professionals.email_address, t 6.c9, Professionals.cell_number",
            "select Professionals.email_address, t66.c9, Professionals.cell_number",
            "select t 6.c8, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, t06.c9, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please send me the email address, home phone and cellular number of each professional., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which is the cell number, home phone or email address of each professional?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which is the cell number, home phone or email address of each professional?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c10, t6.c9, t6.c8",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": false,
        "real_pred": "select Professionals.cell_number, Professionals.home_phone, Professionals.email_address",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.cell_number, Professionals.home_phone, Professionals.email_address",
            "select Professionals.cell_number, Professionals.home_phone or Professionals.email_address",
            "select Professionals.home_phone, Professionals.email_address",
            "select Professionals.professional_id, Professionals.home_phone, Professionals.email_address",
            "select Professionals.zip_code, Professionals.home_phone, Professionals.email_address",
            "select Professionals.role_code, Professionals.home_phone, Professionals.email_address",
            "select Professionals.last_name, Professionals.home_phone, Professionals.email_address",
            "select Professionals.professional_id, Professionals.home_phone or Professionals.email_address"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which is the cell number, home phone or email address of each professional?, database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give the email address, home phone and cell number of each professional., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give the email address, home phone and cell number of each professional., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c9, t6.c10",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": false,
        "real_pred": "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number.",
            "select Professionals.email_address, Professionals.home_phone, Professionals.professional_id",
            "select Professionals.email_address, t66.c9, Professionals.cell_number",
            "select Professionals.email_address, t 6.c9, Professionals.cell_number",
            "select Professionals.email_address, t 6.c9, t 6.c10",
            "select t 6.c8, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, t06.c9, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give the email address, home phone and cell number of each professional., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter the first names of all medical practitioners along with their respective treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-C2 - SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter the first names of all medical practitioners along with their respective treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t7.c3",
        "label": "select distinct t6.c2, t3.c1",
        "score": false,
        "real_pred": "select Professionals.first_name, Treatments.treatment_type_code",
        "real_label": "select distinct Professionals.first_name, Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Professionals.first_name, Treatments.treatment_type_code",
            "select Professionals.first_name, Treatments.dog_id",
            "select Professionals.first_name, Treatments.professional_id",
            "select distinct Professionals.first_name, Treatments.treatment_type_code",
            "select Professionals.first_name, Treatments.treatment_id",
            "select Professionals.first_name, Treatments.treatment_type_code,",
            "select Professionals.first_name, Professionals.street",
            "select Professionals.role_code, Treatments.treatment_type_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter the first names of all medical practitioners along with their respective treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t3 t6 t7",
        "score": false,
        "real_pred": "Professionals Treatments",
        "real_label": "Treatment_Types Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Owners Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Sizes Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter the first names for each professional, followed by a detailed account of their treatment type., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-GROUP BY ORDINARY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter the first names for each professional, followed by a detailed account of their treatment type., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t3.c1",
        "label": "select distinct t6.c2, t3.c1",
        "score": false,
        "real_pred": "select Professionals.first_name, Treatment_Types.treatment_type_description",
        "real_label": "select distinct Professionals.first_name, Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Professionals.first_name, Treatment_Types.treatment_type_description",
            "select Professionals.first_name, Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Professionals.first_name, Treatment_Types.treatment_type_description - Treatments.treatment_type_code",
            "select Professionals.first_name, Treatment_Types.treatment_type_code_description",
            "select Professionals.first_name, Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Professionals.first_name, Treatment_Types.treatment_type_description (Treatments.treatment_type_code)",
            "select Professionals.first_name, Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Professionals.first_name, Treatment_Types.treatment_type_description, t7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter the first names for each professional, followed by a detailed account of their treatment type., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t6 t7",
        "label": "t3 t6 t7",
        "score": true,
        "real_pred": "Treatment_Types Professionals Treatments",
        "real_label": "Treatment_Types Professionals Treatments",
        "topk_preds": [
            "Treatment_Types Professionals Treatments",
            "Breeds Treatment_Types Professionals Treatments",
            "",
            "",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For those who have operated a treatment which has been less expensive than the average, give me their first and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C1, SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For those who have operated a treatment which has been less expensive than the average, give me their first and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c1, t4.c2",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Owners.first_name, Owners.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Owners.first_name, Owners.last_name",
            "select Professionals.role_code, Owners.last_name",
            "select Professionals.first_name, Owners.last_name",
            "select Professionals.first_name, Professionals.first_name",
            "select Dogs.owner_id, Owners.last_name",
            "select Professionals.role_code, Professionals.first_name",
            "select Sizes.size_description, Owners.last_name",
            "select Dogs.owner_id, Dogs.abandoned_yn"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For those who have operated a treatment which has been less expensive than the average, give me their first and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t6 t7",
        "label": "t6 t7",
        "score": false,
        "real_pred": "Owners Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Owners Professionals Treatments",
            "Owners Treatments",
            "Owners Dogs Professionals Treatments",
            "Sizes Owners Professionals Treatments",
            "Treatment_Types Owners Professionals Treatments",
            "Sizes Owners Treatments",
            "Treatment_Types Owners Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need to find out about which therapists treat patients for a low price. Give me their first names and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need to find out about which therapists treat patients for a low price. Give me their first names and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select Professionals.role_code, Professionals.first_name",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select t 6.c2, Professionals.last_name",
            "select Dogs.abandoned_yn, Professionals.last_name",
            "select Dogs.owner_id, Professionals.last_name",
            "select Owners.first_name, Professionals.first_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need to find out about which therapists treat patients for a low price. Give me their first names and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t6 t7",
        "label": "t6 t7",
        "score": false,
        "real_pred": "Owners Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Owners Professionals Treatments",
            "Treatment_Types Owners Professionals Treatments",
            "Owners Dogs Professionals Treatments",
            "Sizes Professionals Treatments",
            "Dogs Professionals Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who are the people who operate the therapy which costs less than the average? Give me their first names and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who are the people who operate the therapy which costs less than the average? Give me their first names and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c1, t4.c2",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Owners.first_name, Owners.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Owners.first_name, Owners.last_name",
            "select Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.first_name",
            "select Professionals.first_name, Professionals.first_name",
            "select Professionals.first_name, Owners.last_name",
            "select Dogs.owner_id, Owners.last_name",
            "select Dogs.owner_id, Dogs.abandoned_yn",
            "select Professionals.first_name, Professionals.street"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who are the people who operate the therapy which costs less than the average? Give me their first names and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t6 t7",
        "label": "t6 t7",
        "score": false,
        "real_pred": "Owners Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Owners Professionals Treatments",
            "Treatment_Types Owners Professionals Treatments",
            "Dogs Professionals Treatments",
            "Sizes Professionals Treatments",
            "Professionals Treatments",
            "Charges Professionals Treatments",
            "Sizes Treatments",
            "Owners Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to find out which professionals have been operating treatment that costs less than the average. I need their first names and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to find out which professionals have been operating treatment that costs less than the average. I need their first names and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select the Professionals.first_name, Professionals.last_name",
            "select t 6.c2, Professionals.last_name",
            "select t.c2, Professionals.last_name",
            "select Dogs.abandoned_yn, Professionals.last_name",
            "select Charges.charge_amount, Professionals.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to find out which professionals have been operating treatment that costs less than the average. I need their first names and last names., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Breeds Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Sizes Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professional had operated a treatment that was cheaper than the average? Give me their first name and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-C2, SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professional had operated a treatment that was cheaper than the average? Give me their first name and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select t 6.c2, Professionals.last_name",
            "select t(6).c2, Professionals.last_name",
            "select t.c2, Professionals.last_name",
            "select Charges.charge_amount, Professionals.last_name",
            "select t.c2, t.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professional had operated a treatment that was cheaper than the average? Give me their first name and last name., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me email addresses, home numbers, and cell phone numbers for all the professionals here., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me email addresses, home numbers, and cell phone numbers for all the professionals here., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c9, t6.c10",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": false,
        "real_pred": "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number.",
            "select Professionals.email_address, t 6.c9, Professionals.cell_number",
            "select Professionals.email_address, t66.c9, Professionals.cell_number",
            "select Professionals.email_address, Dogs.weight, Professionals.cell_number",
            "select Dogs.gender, Professionals.home_phone, Professionals.cell_number",
            "select t 6.c8, Professionals.home_phone, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me email addresses, home numbers, and cell phone numbers for all the professionals here., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter the email address, home phone and cell phone of each professional below., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter the email address, home phone and cell phone of each professional below., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c9, t6.c10",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": false,
        "real_pred": "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number.",
            "select Professionals.email_address, t 6.c9, Professionals.cell_number",
            "select Professionals.email_address, t66.c9, Professionals.cell_number",
            "select t 6.c8, Professionals.home_phone, Professionals.cell_number",
            "select t.c8, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, t06.c9, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter the email address, home phone and cell phone of each professional below., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter all the emails, home numbers and cell phones for all the professionals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM t6.c8, t6.c9, t6.c10",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter all the emails, home numbers and cell phones for all the professionals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c9, t6.c10",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": false,
        "real_pred": "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number.",
            "select Professionals.email_address, t66.c9, Professionals.cell_number",
            "select Professionals.email_address, t 6.c9, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.professional_id",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Dogs.weight, Professionals.cell_number",
            "select Professionals.email_address, t06.c9, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter all the emails, home numbers and cell phones for all the professionals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: List down all the emails, mobile numbers and landlines of all the professional., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT.C8, SELECT.C10, SELECT.C9",
            "SELECT.C8, SELECT-C10, SELECT-FROM",
            "SELECT.C8, SELECT-C10, SELECT-C9",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT.C8, SELECT.C10, SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: List down all the emails, mobile numbers and landlines of all the professional., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c10, t6.c9",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": true,
        "real_pred": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
            "select Professionals.email_address, Professionals.home_phone, Professionals.city",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.street",
            "select Professionals.email_address, Professionals.home_phone, Professionals.first_name",
            "select Professionals.email_address, Professionals.home_phone, Professionals.professional_id",
            "select Professionals.email_address, Professionals.home_phone, Professionals.city0",
            "select Professionals.email_address, Professionals.home_phone, Professionals.role_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: List down all the emails, mobile numbers and landlines of all the professional., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Enter the email, home phone and cell number for the professionals below., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Enter the email, home phone and cell number for the professionals below., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c9, t6.c10",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": false,
        "real_pred": "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number.",
            "select Professionals.email_address, t66.c9, Professionals.cell_number",
            "select Professionals.email_address, t 6.c9, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.professional_id",
            "select Professionals.email_address, t06.c9, Professionals.cell_number",
            "select Professionals.email_address, Professionals.professional_id9, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Enter the email, home phone and cell number for the professionals below., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter the email addresses, home phone numbers and cell phone numbers of all the professionals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-HAVING-SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter the email addresses, home phone numbers and cell phone numbers of all the professionals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c9, t6.c10",
        "label": "select t6.c8, t6.c10, t6.c9",
        "score": false,
        "real_pred": "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
        "real_label": "select Professionals.email_address, Professionals.cell_number, Professionals.home_phone",
        "topk_preds": [
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, Professionals.home_phone, Professionals.cell_number.",
            "select Professionals.email_address, t 6.c9, Professionals.cell_number",
            "select Professionals.email_address, t66.c9, Professionals.cell_number",
            "select t 6.c8, Professionals.home_phone, Professionals.cell_number",
            "select Dogs.gender, Professionals.home_phone, Professionals.cell_number",
            "select Professionals.email_address, t06.c9, Professionals.cell_number",
            "select Professionals.email_address, Dogs.weight, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter the email addresses, home phone numbers and cell phone numbers of all the professionals., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6",
        "label": "t6",
        "score": true,
        "real_pred": "Professionals",
        "real_label": "Professionals",
        "topk_preds": [
            "Professionals",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to find the id, last name and cell number of all professionals that live in the state of Indiana or have performed over two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-T6-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING-",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to find the id, last name and cell number of all professionals that live in the state of Indiana or have performed over two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c",
        "prediction": "select t6.c0, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select Sizes.size_code, Professionals.last_name, Professionals.cell_number",
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number."
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to find the id, last name and cell number of all professionals that live in the state of Indiana or have performed over two treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Charges Professionals Treatments",
            "Sizes Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the ID, last name and cell telephone number of all professionals located in the state of Indiana or have performed more than 2 treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING OR-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAG-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the ID, last name and cell telephone number of all professionals located in the state of Indiana or have performed more than 2 treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_",
        "prediction": "select t6.c0, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.first_name, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select Sizes.size_code, Professionals.last_name, Professionals.cell_number",
            "select Dogs.dog_id, Professionals.last_name, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the ID, last name and cell telephone number of all professionals located in the state of Indiana or have performed more than 2 treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Breeds Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Sizes Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the professional's ID, last name and mobile phone number, if they are located in the state of Indiana and have done more than 2 treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost",
        "prediction": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAGMENT-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GAGMENT-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the professional's ID, last name and mobile phone number, if they are located in the state of Indiana and have done more than 2 treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, ",
        "prediction": "select t7.c2, t6.c7, t6.c10",
        "label": "select t6.c0, t6.c7, t6.c10",
        "score": false,
        "real_pred": "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
        "topk_preds": [
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number",
            "select Professionals.professional_id, Professionals.last_name, Professionals.cell_number",
            "select t8.c2, Professionals.last_name, Professionals.cell_number",
            "select Treatments.dog_id, Professionals.last_name, Professionals.cell_number",
            "select t2.c2, Professionals.last_name, Professionals.cell_number",
            "select Charges.charge_id, Professionals.last_name, Professionals.cell_number",
            "select Sizes.size_code, Professionals.last_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.last_name, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the professional's ID, last name and mobile phone number, if they are located in the state of Indiana and have done more than 2 treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state (Indiana), c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like you to find the different breed type and size combination of dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM INTERSECT-SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like you to find the different breed type and size combination of dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select distinct t5.c3, t5.c4",
        "label": "select distinct t5.c3, t5.c4",
        "score": true,
        "real_pred": "select distinct Dogs.breed_code, Dogs.size_code",
        "real_label": "select distinct Dogs.breed_code, Dogs.size_code",
        "topk_preds": [
            "select distinct Dogs.breed_code, Dogs.size_code",
            "select Dogs.breed_code, Dogs.size_code",
            "select unique Dogs.breed_code, Dogs.size_code",
            "select different Dogs.breed_code, Dogs.size_code",
            "select count(*), Dogs.breed_code, Dogs.size_code",
            "select specific Dogs.breed_code, Dogs.size_code",
            "select every Dogs.breed_code, Dogs.size_code",
            "select the distinct Dogs.breed_code, Dogs.size_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like you to find the different breed type and size combination of dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find all the breed types and their corresponding sizes that are listed for dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM VENTILATE-UNION-SELECT-FROM",
            "SELECT-FROM VENTILATE-GROUP BY",
            "SELECT-FROM VENTILATE-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find all the breed types and their corresponding sizes that are listed for dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c3, t5.c4",
        "label": "select distinct t5.c3, t5.c4",
        "score": false,
        "real_pred": "select Dogs.breed_code, Dogs.size_code",
        "real_label": "select distinct Dogs.breed_code, Dogs.size_code",
        "topk_preds": [
            "select Dogs.breed_code, Dogs.size_code",
            "select distinct Dogs.breed_code, Dogs.size_code",
            "select t5.cbreed_code, Dogs.size_code",
            "select Dogs.owner_id, Dogs.size_code",
            "select t5.c breed_code, Dogs.size_code",
            "select dog_Dogs.breed_code, Dogs.size_code",
            "select Dogs.dog_id, Dogs.size_code",
            "select Dogs.abandoned_yn, Dogs.size_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find all the breed types and their corresponding sizes that are listed for dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "Sizes Dogs",
            "Sizes Treatment_Types Dogs",
            "Breeds Sizes Dogs",
            "Treatment_Types Dogs",
            "Owners Dogs",
            "Charges Dogs",
            "Charges Treatment_Types Dogs"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the names of the dogs that never broke their owners' bank account over 1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-HAVE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ESCAPE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-AVERAGE-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the names of the dogs that never broke their owners' bank account over 1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Dogs.breed_code",
            "select Dogs.name, Dogs.age",
            "select Dogs.name, Charges.charge_amount",
            "select Dogs.name, Dogs.owner_id",
            "select Dogs.name, Treatments.treatment_type_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the names of the dogs that never broke their owners' bank account over 1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t1 t5 t7",
        "label": "t5 t7",
        "score": false,
        "real_pred": "Charges Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Charges Dogs Treatments",
            "Charges Sizes Dogs Treatments",
            "Breeds Charges Dogs Treatments",
            "Charges Treatment_Types Dogs Treatments",
            "",
            "",
            "Charges Dogs Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me the first, last names of the doctors who treated you for less than average amount of money., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me the first, last names of the doctors who treated you for less than average amount of money., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select Dogs.owner_id, Professionals.last_name",
            "select Charges.charge_type, Professionals.last_name",
            "select Dogs.owner_id, Dogs.abandoned_yn",
            "select t 6.c2, Professionals.last_name",
            "select t.c2, t.c7"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me the first, last names of the doctors who treated you for less than average amount of money., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t1 t6 t7",
        "label": "t6 t7",
        "score": false,
        "real_pred": "Charges Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Charges Professionals Treatments",
            "Charges Sizes Professionals Treatments",
            "Breeds Charges Professionals Treatments",
            "Charges Sizes Treatments",
            "Charges Dogs Professionals Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the names of the medical professionals whom you have treated at a price lower than average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-COST-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the names of the medical professionals whom you have treated at a price lower than average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select the Professionals.first_name, Professionals.last_name",
            "select Charges.charge_amount, Professionals.last_name",
            "select t 6.c2, Professionals.last_name",
            "select t06.c2, Professionals.last_name",
            "select t.c2, Professionals.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the names of the medical professionals whom you have treated at a price lower than average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the first and last names of the medical professionals whom you have treated at a price lower than average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-COST-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the first and last names of the medical professionals whom you have treated at a price lower than average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t6.c7",
        "label": "select distinct t6.c2, t6.c7",
        "score": false,
        "real_pred": "select Professionals.first_name, Professionals.last_name",
        "real_label": "select distinct Professionals.first_name, Professionals.last_name",
        "topk_preds": [
            "select Professionals.first_name, Professionals.last_name",
            "select distinct Professionals.first_name, Professionals.last_name",
            "select Professionals.role_code, Professionals.last_name",
            "select the Professionals.first_name, Professionals.last_name",
            "select t 6.c2, Professionals.last_name",
            "select Charges.charge_amount, Professionals.last_name",
            "select Dogs.abandoned_yn, Professionals.last_name",
            "select t.c2, Professionals.last_name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the first and last names of the medical professionals whom you have treated at a price lower than average., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Owners Professionals Treatments",
            "Sizes Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to know the names of the dogs that do not cost more than $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to know the names of the dogs that do not cost more than $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c5",
        "label": "select t5.c5",
        "score": true,
        "real_pred": "select Dogs.name",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.name",
            "select Dogs.name, Treatments.dog_id",
            "select Dogs.name, Treatments.dog_id, Dogs.abandoned_yn",
            "select Dogs.name, Treatments.dog_id, Treatments.professional_id",
            "select Dogs.name, Treatments.dog_id, Dogs.breed_code",
            "select Dogs.name, Treatments.treatment_type_code, Treatments.date_of_treatment",
            "select Dogs.name, Treatments.professional_id",
            "select Dogs.name, Treatments.dog_id, Treatments.treatment_type_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to know the names of the dogs that do not cost more than $1000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Breeds Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the list of the dogs that the owners did not pay over $1000 for the treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the list of the dogs that the owners did not pay over $1000 for the treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c0",
        "label": "select t5.c5",
        "score": false,
        "real_pred": "select Dogs.dog_id",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.dog_id",
            "select Dogs.dog_id, Dogs.owner_id",
            "select Dogs.dog_id, Dogs.owner_id, Dogs.breed_code",
            "select Dogs.dog_id, Dogs.owner_id, Dogs.abandoned_yn",
            "select Dogs.dog_id, Treatments.dog_id",
            "select Dogs.dog_id, Dogs.owner_id",
            "select Dogs.dog_id, Dogs.owner_id - Treatments.cost_of_treatment",
            "select Dogs.dog_id, Dogs.owner_id, Treatments.cost_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the list of the dogs that the owners did not pay over $1000 for the treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Breeds Charges Dogs Treatments",
            "Sizes Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Owners Dogs Treatments",
            "Breeds Dogs Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please provide me with the list of dogs for which the owner did not pay more than 1 000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": false,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-PROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please provide me with the list of dogs for which the owner did not pay more than 1 000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c0",
        "label": "select t5.c5",
        "score": false,
        "real_pred": "select Dogs.dog_id",
        "real_label": "select Dogs.name",
        "topk_preds": [
            "select Dogs.dog_id",
            "select Dogs.dog_id, Dogs.owner_id",
            "select Dogs.dog_id, Treatments.dog_id",
            "select Dogs.dog_id, Charges.charge_amount",
            "select Dogs.dog_id, Treatments.cost_of_treatment",
            "select Dogs.dog_id, Charges.charge_type",
            "select Dogs.dog_id, Professionals.role_code",
            "select Dogs.dog_id, Sizes.size_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please provide me with the list of dogs for which the owner did not pay more than 1 000 for treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5 t7",
        "label": "t5 t7",
        "score": true,
        "real_pred": "Dogs Treatments",
        "real_label": "Dogs Treatments",
        "topk_preds": [
            "Dogs Treatments",
            "Charges Dogs Treatments",
            "Sizes Dogs Treatments",
            "Treatment_Types Dogs Treatments",
            "Breeds Dogs Treatments",
            "Owners Dogs Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the identification, role and e-mail address of the professionals who did not provide any service on the dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM.",
            "SELECT-FROM- EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the identification, role and e-mail address of the professionals who did not provide any service on the dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c1, t6.c8",
        "label": "select t6.c0, t6.c1, t6.c8",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.role_code, Professionals.email_address",
        "real_label": "select Professionals.professional_id, Professionals.role_code, Professionals.email_address",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.role_code, Professionals.email_address",
            "select Professionals.professional_id, Professionals.first_name, Professionals.email_address",
            "select Professionals.role_code, Professionals.first_name, Professionals.email_address",
            "select Professionals.first_name, Professionals.role_code, Professionals.email_address",
            "select t 6.c0, Professionals.role_code, Professionals.email_address",
            "select Dogs.dog_id, Professionals.role_code, Professionals.email_address",
            "select t6).c0, Professionals.role_code, Professionals.email_address",
            "select Charges.charge_id, Professionals.role_code, Professionals.email_address"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the identification, role and e-mail address of the professionals who did not provide any service on the dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please give me the e-mail address, role code and professional ID of all those who did not treat any dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "real_label": "SELECT-FROM-EXCEPT-SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EMPT-EXCEPT-SELECT-FROM",
            "SELECT-FROM-A-EXCEPT-SELECT-FROM",
            "SELECT-FROM-HOLD-EXCEPT-SELECT-FROM",
            "SELECT-FROME-EXCEPT-SELECT-FROM",
            "SELECT-FROM- EXCEPT-SELECT-FROM",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM",
            "SELECT-FROM-EXCEPT-SELECT-FROM."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please give me the e-mail address, role code and professional ID of all those who did not treat any dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c8, t6.c1, t6.c0",
        "label": "select t6.c0, t6.c1, t6.c8",
        "score": false,
        "real_pred": "select Professionals.email_address, Professionals.role_code, Professionals.professional_id",
        "real_label": "select Professionals.professional_id, Professionals.role_code, Professionals.email_address",
        "topk_preds": [
            "select Professionals.email_address, Professionals.role_code, Professionals.professional_id",
            "select Professionals.email_address, Professionals.first_name, Professionals.professional_id",
            "select Professionals.email_address, Professionals.professional_id, Professionals.role_code",
            "select Professionals.email_address, Professionals.role_code, Professionals.first_name",
            "select Professionals.email_address, Professionals.role_code, Professionals.professional_id",
            "select Professionals.email_address, Professionals.role_code & Professionals.professional_id",
            "select Professionals.email_address, Professionals.role_code, Professionals.professional_id",
            "select Professionals.email_address, Dogs.owner_id, Professionals.professional_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please give me the e-mail address, role code and professional ID of all those who did not treat any dogs., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "",
            "Dogs Professionals Treatments",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me information about the treatment type that has the lowest price in total., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-ACT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me information about the treatment type that has the lowest price in total., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t3.c1, t7.c3",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
        "real_label": "select Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Owners.first_name, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_code, Treatment_Types.treatment_type_description",
            "select Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description, Treatments.dog_id",
            "select Sizes.size_description, Treatment_Types.treatment_type_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me information about the treatment type that has the lowest price in total., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t3 t7",
        "score": false,
        "real_pred": "Treatments",
        "real_label": "Treatment_Types Treatments",
        "topk_preds": [
            "Treatments",
            "Treatment_Types Treatments",
            "Dogs Treatments",
            "Owners Treatments",
            "Dogs Professionals Treatments",
            "Professionals Treatments",
            "Charges Treatments",
            "Owners Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Describe the cheapest treatment type in terms of the amount spent to treat it., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Describe the cheapest treatment type in terms of the amount spent to treat it., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Treatment_Types.treatment_type_description",
        "real_label": "select Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description, t7",
            "select Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Treatment_Types.treatment_type_description, Treatments.dog_id",
            "select Treatment_Types.treatment_type_code, Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.cost_of_treatment",
            "select Treatment_Types.treatment_type_description-, Treatments.treatment_type_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Describe the cheapest treatment type in terms of the amount spent to treat it., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Treatment_Types Treatments",
        "real_label": "Treatment_Types Treatments",
        "topk_preds": [
            "Treatment_Types Treatments",
            "Sizes Treatment_Types Treatments",
            "Charges Treatment_Types Treatments",
            "Breeds Treatment_Types Treatments",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Describe which ones of these treatment types costs the least amount of money., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Describe which ones of these treatment types costs the least amount of money., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t3.c1, t7.c3",
        "label": "select t3.c1",
        "score": false,
        "real_pred": "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
        "real_label": "select Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description, t7",
            "select Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Treatment_Types.treatment_type_description, Treatments.dog_id",
            "select Treatment_Types.treatment_type_code, Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, t07.c3",
            "select Treatment_Types.treatment_type_description,"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Describe which ones of these treatment types costs the least amount of money., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Treatment_Types Treatments",
        "real_label": "Treatment_Types Treatments",
        "topk_preds": [
            "Treatment_Types Treatments",
            "Sizes Treatment_Types Treatments",
            "Charges Treatment_Types Treatments",
            "Breeds Treatment_Types Treatments",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The treatment that has the lowest cost, describe it to me., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": false,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The treatment that has the lowest cost, describe it to me., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t3.c1",
        "label": "select t3.c1",
        "score": true,
        "real_pred": "select Treatment_Types.treatment_type_description",
        "real_label": "select Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Treatment_Types.treatment_type_description",
            "select Treatment_Types.treatment_type_description, Treatments.professional_id",
            "select Treatment_Types.treatment_type_description, Treatments.dog_id",
            "select Treatment_Types.treatment_type_description, Treatments.treatment_type_code",
            "select Treatment_Types.treatment_type_description, t7",
            "select Treatment_Types.treatment_type_description, Treatments.cost_of_treatment",
            "select Treatment_Types.treatment_type_description-, Treatments.professional_id",
            "select Treatment_Types.treatment_type_code, Treatment_Types.treatment_type_description"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The treatment that has the lowest cost, describe it to me., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t7",
        "label": "t3 t7",
        "score": true,
        "real_pred": "Treatment_Types Treatments",
        "real_label": "Treatment_Types Treatments",
        "topk_preds": [
            "Treatment_Types Treatments",
            "Sizes Treatment_Types Treatments",
            "Charges Treatment_Types Treatments",
            "Breeds Treatment_Types Treatments",
            "",
            "",
            "",
            "Owners Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you tell me which dog owner has spent the most on veterinary bills so far? Show the owner ID and ZIP code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you tell me which dog owner has spent the most on veterinary bills so far? Show the owner ID and ZIP code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c0, t4.c6",
        "label": "select t4.c0, t4.c6",
        "score": true,
        "real_pred": "select Owners.owner_id, Owners.zip_code",
        "real_label": "select Owners.owner_id, Owners.zip_code",
        "topk_preds": [
            "select Owners.owner_id, Owners.zip_code",
            "select Dogs.owner_id, Owners.zip_code",
            "select Sizes.size_code, Owners.zip_code",
            "select Charges.charge_type, Owners.zip_code",
            "select t8.c1, Owners.zip_code",
            "select Sizes.size_description, Owners.zip_code",
            "select Owners.first_name, Owners.zip_code",
            "select Owners.owner_id-, Owners.zip_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you tell me which dog owner has spent the most on veterinary bills so far? Show the owner ID and ZIP code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t5 t7",
        "label": "t4 t5 t7",
        "score": true,
        "real_pred": "Owners Dogs Treatments",
        "real_label": "Owners Dogs Treatments",
        "topk_preds": [
            "Owners Dogs Treatments",
            "Sizes Owners Dogs Treatments",
            "",
            "Charges Owners Dogs Treatments",
            "Treatment_Types Owners Dogs Treatments",
            "",
            "Sizes Dogs Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: The owner who spent most on their dogs can be found here. Give me their ID and their ZIP Code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-C0-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: The owner who spent most on their dogs can be found here. Give me their ID and their ZIP Code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t4.c0, t4.c6",
        "label": "select t4.c0, t4.c6",
        "score": true,
        "real_pred": "select Owners.owner_id, Owners.zip_code",
        "real_label": "select Owners.owner_id, Owners.zip_code",
        "topk_preds": [
            "select Owners.owner_id, Owners.zip_code",
            "select Dogs.owner_id, Owners.zip_code",
            "select Treatments.dog_id, Owners.zip_code",
            "select t8.c1, Owners.zip_code",
            "select Sizes.size_code, Owners.zip_code",
            "select Charges.charge_id, Owners.zip_code",
            "select Owners.owner_id, t4c6",
            "select t9.c0, Owners.zip_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: The owner who spent most on their dogs can be found here. Give me their ID and their ZIP Code., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t4 t5 t7",
        "label": "t4 t5 t7",
        "score": true,
        "real_pred": "Owners Dogs Treatments",
        "real_label": "Owners Dogs Treatments",
        "topk_preds": [
            "Owners Dogs Treatments",
            "Sizes Owners Dogs Treatments",
            "Charges Owners Dogs Treatments",
            "Treatment_Types Owners Dogs Treatments",
            "Breeds Owners Dogs Treatments",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to get the ids and mobile phone numbers for professionals who did at least two types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to get the ids and mobile phone numbers for professionals who did at least two types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c10",
        "label": "select t6.c0, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.cell_number",
            "select Professionals.first_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.cell_number",
            "select Professionals.role_code, Professionals.cell_number",
            "select t8.c2, Professionals.cell_number",
            "select t2.c2, Professionals.cell_number",
            "select Charges.charge_amount, Professionals.cell_number",
            "select Professionals.professional_id2, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to get the ids and mobile phone numbers for professionals who did at least two types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Owners Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "Sizes Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which professionals have completed at least two treatments? Enter their professional ids and mobile numbers., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING.",
            "SELECT-FROM-GROUP BY-HAVING-UNIon-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GAGUE-GROUP BY-HAVING",
            "SELECT-FROM-GROUPS-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which professionals have completed at least two treatments? Enter their professional ids and mobile numbers., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c10",
        "label": "select t6.c0, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.cell_number",
            "select Professionals.first_name, Professionals.cell_number",
            "select Professionals.role_code, Professionals.cell_number",
            "select t2.c2, Professionals.cell_number",
            "select Charges.charge_id, Professionals.cell_number",
            "select t 6.c0, Professionals.cell_number",
            "select Dogs.dog_id, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which professionals have completed at least two treatments? Enter their professional ids and mobile numbers., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Charges Professionals Treatments",
            "Owners Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the cell number and professional ID of those professionals who work in two or more different types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHER-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GATHERING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING -UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the cell number and professional ID of those professionals who work in two or more different types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c10, t6.c0",
        "label": "select t6.c0, t6.c10",
        "score": false,
        "real_pred": "select Professionals.cell_number, Professionals.professional_id",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.cell_number, Professionals.professional_id",
            "select Professionals.cell_number, Treatments.professional_id",
            "select Professionals.home_phone, Professionals.professional_id",
            "select Professionals.professional_id, Professionals.cell_number",
            "select Professionals.cell_number, Professionals.first_name",
            "select Professionals.role_code, Professionals.professional_id",
            "select t 6.c10, Professionals.professional_id",
            "select Professionals.cell_number, Dogs.dog_id"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the cell number and professional ID of those professionals who work in two or more different types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Owners Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Professionals Treatments",
            "",
            "Charges Professionals Treatments"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please find the ID and cell number of the professionals who work on two or more types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY-HAVING",
        "label": "SELECT-FROM-GROUP BY-HAVING",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-HAVING",
        "real_label": "SELECT-FROM-GROUP BY-HAVING",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-EXCEPT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING-INSTALL-UNION-SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please find the ID and cell number of the professionals who work on two or more types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c0, t6.c10",
        "label": "select t6.c0, t6.c10",
        "score": true,
        "real_pred": "select Professionals.professional_id, Professionals.cell_number",
        "real_label": "select Professionals.professional_id, Professionals.cell_number",
        "topk_preds": [
            "select Professionals.professional_id, Professionals.cell_number",
            "select Professionals.first_name, Professionals.cell_number",
            "select Treatments.professional_id, Professionals.cell_number",
            "select Professionals.role_code, Professionals.cell_number",
            "select t8.c2, Professionals.cell_number",
            "select t2.c2, Professionals.cell_number",
            "select Charges.charge_amount, Professionals.cell_number",
            "select t 6.c0, Professionals.cell_number"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please find the ID and cell number of the professionals who work on two or more types of treatments., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t6 t7",
        "label": "t6 t7",
        "score": true,
        "real_pred": "Professionals Treatments",
        "real_label": "Professionals Treatments",
        "topk_preds": [
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Treatment_Types Professionals Treatments",
            "Owners Professionals Treatments",
            "Charges Professionals Treatments",
            "Breeds Professionals Treatments",
            "Sizes Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please inform me about the price for the latest medical care., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-TO-ORDER BY-LIMIT",
            "SELECT-FROM-ON-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-OF-ORDER BY-LIMIT",
            "SELECT-FROM-CURRENCY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please inform me about the price for the latest medical care., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c5",
        "label": "select t7.c5",
        "score": true,
        "real_pred": "select Treatments.cost_of_treatment",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Treatments.cost_of_treatment",
            "select Treatments.cost_of_treatment, Treatments.treatment_type_code",
            "select Treatments.cost_of_treatment, t7.c6",
            "select Treatments.cost_of_treatment, Treatments.dog_id",
            "select Treatments.cost_of_treatment, Treatments.professional_id",
            "select Treatments.cost_of_treatment, t8.c1",
            "select Treatments.cost_of_treatment, Treatments.date_of_treatment",
            "select avg(Treatments.cost_of_treatment)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please inform me about the price for the latest medical care., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t7",
        "score": true,
        "real_pred": "Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Treatments",
            "Dogs Treatments",
            "Owners Treatments",
            "Dogs Professionals Treatments",
            "Charges Treatments",
            "Professionals Treatments",
            "Treatment_Types Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Find the cost of the latest treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Find the cost of the latest treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t7.c5",
        "label": "select t7.c5",
        "score": true,
        "real_pred": "select Treatments.cost_of_treatment",
        "real_label": "select Treatments.cost_of_treatment",
        "topk_preds": [
            "select Treatments.cost_of_treatment",
            "select max(Treatments.cost_of_treatment)",
            "select Treatments.cost_of_treatment, Treatments.treatment_type_code",
            "select Treatments.cost_of_treatment, Treatments.date_of_treatment",
            "select Treatments.cost_of_treatment, Treatments.dog_id",
            "select Treatments.cost_of_treatment, Treatments.professional_id",
            "select Treatments.cost_of_treatment, t7.c6",
            "select Treatments.cost_of_treatment - Treatments.treatment_type_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Find the cost of the latest treatment., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t7",
        "label": "t7",
        "score": true,
        "real_pred": "Treatments",
        "real_label": "Treatments",
        "topk_preds": [
            "Treatments",
            "Dogs Treatments",
            "Professionals Treatments",
            "Dogs Professionals Treatments",
            "Breeds Treatments",
            "Charges Treatments",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the price for each charge category and total cost., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY (ADD-ON-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY, sum(t1.c2)",
            "SELECT-FROM-GROUP BY and sum(t1.c2)",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the price for each charge category and total cost., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t1.c1, sum(t1.c2)",
        "label": "select t1.c1, t1.c2",
        "score": false,
        "real_pred": "select Charges.charge_type, sum(Charges.charge_amount)",
        "real_label": "select Charges.charge_type, Charges.charge_amount",
        "topk_preds": [
            "select Charges.charge_type, sum(Charges.charge_amount)",
            "select Charges.charge_id, Charges.charge_type, sum(Charges.charge_amount)",
            "select Charges.charge_amount, sum(Charges.charge_amount)",
            "select Charges.charge_type.c2, sum(Charges.charge_amount)",
            "select Charges.charge_type, sum(Treatments.cost_of_treatment)",
            "select Charges.charge_id, sum(Charges.charge_amount)",
            "select Charges.charge_type, sum(t2.c2)",
            "select Charges.charge_type, sum(t1.c5)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the price for each charge category and total cost., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name (Price), c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t1",
        "label": "t1",
        "score": true,
        "real_pred": "Charges",
        "real_label": "Charges",
        "topk_preds": [
            "Charges",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please state every combination of breed and size codes., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM every possible combination(t5.c3), SELECT-FROM",
            "SELECT-FROM every possible t5.c3, t5.c4",
            "SELECT-FROM each possible t5.c3, t5.c4",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM every possible combination(t5.c3), t5.c4",
            "SELECT-FROM (UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please state every combination of breed and size codes., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c3, t5.c4",
        "label": "select distinct t5.c3, t5.c4",
        "score": false,
        "real_pred": "select Dogs.breed_code, Dogs.size_code",
        "real_label": "select distinct Dogs.breed_code, Dogs.size_code",
        "topk_preds": [
            "select Dogs.breed_code, Dogs.size_code",
            "select distinct Dogs.breed_code, Dogs.size_code",
            "select every Dogs.breed_code, Dogs.size_code",
            "select unique Dogs.breed_code, Dogs.size_code",
            "select every possible Dogs.breed_code, Dogs.size_code",
            "select possible Dogs.breed_code, Dogs.size_code",
            "select Dogs.owner_id, Dogs.size_code",
            "select Dogs.dog_id, Dogs.breed_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please state every combination of breed and size codes., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the list of all possible combination of breed and size codes., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM all possible t5.c3, t5.c4",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT.C3, SELECT.C4"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the list of all possible combination of breed and size codes., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c3, t5.c4",
        "label": "select distinct t5.c3, t5.c4",
        "score": false,
        "real_pred": "select Dogs.breed_code, Dogs.size_code",
        "real_label": "select distinct Dogs.breed_code, Dogs.size_code",
        "topk_preds": [
            "select Dogs.breed_code, Dogs.size_code",
            "select distinct Dogs.breed_code, Dogs.size_code",
            "select possible Dogs.breed_code, Dogs.size_code",
            "select every possible Dogs.breed_code, Dogs.size_code",
            "select every Dogs.breed_code, Dogs.size_code",
            "select unique Dogs.breed_code, Dogs.size_code",
            "select combinat-id(Dogs.breed_code), Dogs.size_code",
            "select every possible Dogs.owner_id, Dogs.size_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the list of all possible combination of breed and size codes., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "Treatment_Types Dogs",
            "Sizes Dogs",
            "Owners Dogs",
            "Charges Dogs",
            "Sizes Treatment_Types Dogs",
            "Sizes Treatment_Types Owners",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me a list containing all possible breed and size combinations., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM all possible t5.c3, t5.c4",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM (UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM all possible t5.c3 - t5.c4"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me a list containing all possible breed and size combinations., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t5.c3, t5.c4",
        "label": "select distinct t5.c3, t5.c4",
        "score": false,
        "real_pred": "select Dogs.breed_code, Dogs.size_code",
        "real_label": "select distinct Dogs.breed_code, Dogs.size_code",
        "topk_preds": [
            "select Dogs.breed_code, Dogs.size_code",
            "select possible Dogs.breed_code, Dogs.size_code",
            "select distinct Dogs.breed_code, Dogs.size_code",
            "select unique Dogs.breed_code, Dogs.size_code",
            "select all possible Dogs.breed_code, Dogs.size_code",
            "select combinat-id(Dogs.breed_code), Dogs.size_code",
            "select every possible Dogs.breed_code, Dogs.size_code",
            "select list(Dogs.breed_code), Dogs.size_code"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me a list containing all possible breed and size combinations., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t5",
        "label": "t5",
        "score": true,
        "real_pred": "Dogs",
        "real_label": "Dogs",
        "topk_preds": [
            "Dogs",
            "Sizes Dogs",
            "Breeds Sizes Dogs",
            "Treatment_Types Dogs",
            "Sizes Treatment_Types Dogs",
            "Charges Sizes Dogs",
            "Charges Dogs",
            "Owners Dogs"
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each professional, please give their first name and describe the treatments that they have done., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM",
        "score": false,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each professional, please give their first name and describe the treatments that they have done., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "select t6.c2, t7.c3",
        "label": "select distinct t6.c2, t3.c1",
        "score": false,
        "real_pred": "select Professionals.first_name, Treatments.treatment_type_code",
        "real_label": "select distinct Professionals.first_name, Treatment_Types.treatment_type_description",
        "topk_preds": [
            "select Professionals.first_name, Treatments.treatment_type_code",
            "select Professionals.first_name, Treatments.dog_id",
            "select Professionals.first_name, Treatments.professional_id",
            "select Professionals.first_name, Treatment_Types.treatment_type_description",
            "select Professionals.first_name, Professionals.role_code",
            "select Professionals.first_name, t8.c1",
            "select Professionals.first_name, Charges.charge_type",
            "select Professionals.first_name, Treatments.date_of_treatment"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each professional, please give their first name and describe the treatments that they have done., database: Database: dog_kennels. t0: breeds(c0: breed_code, c1: breed_name). t1: charges(c0: charge_id, c1: charge_type, c2: charge_amount). t2: sizes(c0: size_code, c1: size_description). t3: treatment_types(c0: treatment_type_code, c1: treatment_type_description). t4: owners(c0: owner_id, c1: first_name, c2: last_name, c3: street, c4: city, c5: state, c6: zip_code, c7: email_address, c8: home_phone, c9: cell_number). t5: dogs(c0: dog_id, c1: owner_id, c2: abandoned_yn, c3: breed_code, c4: size_code, c5: name, c6: age, c7: date_of_birth, c8: gender, c9: weight, c10: date_arrived, c11: date_adopted, c12: date_departed). t6: professionals(c0: professional_id, c1: role_code, c2: first_name, c3: street, c4: city, c5: state, c6: zip_code, c7: last_name, c8: email_address, c9: home_phone, c10: cell_number). t7: treatments(c0: treatment_id, c1: dog_id, c2: professional_id, c3: treatment_type_code, c4: date_of_treatment, c5: cost_of_treatment).",
        "prediction": "t3 t6 t7",
        "label": "t3 t6 t7",
        "score": true,
        "real_pred": "Treatment_Types Professionals Treatments",
        "real_label": "Treatment_Types Professionals Treatments",
        "topk_preds": [
            "Treatment_Types Professionals Treatments",
            "Sizes Treatment_Types Professionals Treatments",
            "Breeds Treatment_Types Professionals Treatments",
            "Charges Treatment_Types Professionals Treatments",
            "",
            "Sizes Professionals Treatments",
            "Charges Professionals Treatments",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me singers in ascending order of wealth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY (t0.c1)",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY (SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me singers in ascending order of wealth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name",
            "select singer.Singer_ID, singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Net_Worth_Millions, singer.Citizenship",
            "select singer.Name de, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name and singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me singers in ascending order of wealth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter singers according to their wealth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY.LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (LIMIT)",
            "SELECT-FROM- ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter singers according to their wealth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1, t0.c3",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select singer.Name, singer.Net_Worth_Millions",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID",
            "select singer.Name",
            "select singer.Singer_ID, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name",
            "select singer.Singer_ID, singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Net_Worth_Millions, singer.Citizenship",
            "select singer.Name, singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter singers according to their wealth., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please put the names of singers ranked by their wealth in ascending order below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY",
        "label": "SELECT-FROM-ORDER BY",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY",
        "real_label": "SELECT-FROM-ORDER BY",
        "topk_preds": [
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY (SELECT-FROM-ORDER BY",
            "SELECT SELECT-FROM-ORDER BY",
            "SELECT-FROM-ORDER BY ",
            "SELECT-FROM-ORDER BY.",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY (t0.c1)",
            "SELECTFROM-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please put the names of singers ranked by their wealth in ascending order below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name in singer.Net_Worth_Millions",
            "select singer.Name de-facto-ORDER BY",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name de-facto-ordered",
            "select singer.Name-ORDER BY",
            "select singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please put the names of singers ranked by their wealth in ascending order below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show the different nationalities, and their numbers of singers of each., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY, count(*)",
            "SELECT-FROM-GROUP BY (t0.c4), count(*)",
            "SELECT-FROM-GROUP BY (t0.c4) et count(*)",
            "SELECT-FROM-GROUP BY (count(*)",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY (t0.c4)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show the different nationalities, and their numbers of singers of each., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4, count(*)",
        "label": "select t0.c4, count(*)",
        "score": true,
        "real_pred": "select singer.Citizenship, count(*)",
        "real_label": "select singer.Citizenship, count(*)",
        "topk_preds": [
            "select singer.Citizenship, count(*)",
            "select singer.Citizenship, count(*)",
            "select singer.Citizenship., count(*)",
            "select singer.Citizenship, t0.c5, count(*)",
            "select singer.Citizenship, singer.Citizenship, count(*)",
            "select singer.Citizenship, count(*), singer.Net_Worth_Millions",
            "select singer.Citizenship, count(*), t0.c5",
            "select singer.Citizenship, count(*), singer.Citizenship"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show the different nationalities, and their numbers of singers of each., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me different nationalities and their numbers of singers in each., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY (t0.c4)",
            "SELECT-FROM-GROUP BY (count(*)",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM-GROUP BY (ORDER BY",
            "SELECT-FROM-GROUP BY "
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me different nationalities and their numbers of singers in each., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4, count(*)",
        "label": "select t0.c4, count(*)",
        "score": true,
        "real_pred": "select singer.Citizenship, count(*)",
        "real_label": "select singer.Citizenship, count(*)",
        "topk_preds": [
            "select singer.Citizenship, count(*)",
            "select singer.Citizenship, count(*), singer.Citizenship",
            "select singer.Citizenship., count(*)",
            "select singer.Citizenship, count(*), t0.c5",
            "select singer.Citizenship, count(*), singer.Net_Worth_Millions",
            "select singer.Citizenship, count(*),",
            "select singer.Citizenship, count(*)",
            "select singer.Citizenship, count(*), singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me different nationalities and their numbers of singers in each., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Of the singers, what are their birth years and nationalities?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM (GROUP BY-HAVING",
            "SELECT-FROM (ORDER BY-LIMIT)",
            "SELECT-FROM (GROUP BY-HAVING)",
            "SELECT-FROM (ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Of the singers, what are their birth years and nationalities?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select singer.Birth_Year, singer.Citizenship",
        "real_label": "select singer.Birth_Year, singer.Citizenship",
        "topk_preds": [
            "select singer.Birth_Year, singer.Citizenship",
            "select singer.Singer_ID, singer.Birth_Year, singer.Citizenship",
            "select singer.Name, singer.Birth_Year, singer.Citizenship",
            "select singer.Citizenship, singer.Birth_Year",
            "select t0.c5, singer.Birth_Year",
            "select singer.Birth_Year), singer.Citizenship",
            "select singer.Birth_Year-, singer.Citizenship",
            "select singer.Birth_Year, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Of the singers, what are their birth years and nationalities?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I want to know the birth year and nationality of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT.c2, SELECT.c4",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT.c2, SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I want to know the birth year and nationality of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select singer.Birth_Year, singer.Citizenship",
        "real_label": "select singer.Birth_Year, singer.Citizenship",
        "topk_preds": [
            "select singer.Birth_Year, singer.Citizenship",
            "select singer.Singer_ID, singer.Birth_Year, singer.Citizenship",
            "select singer.Name, singer.Birth_Year, singer.Citizenship",
            "select singer.Citizenship, singer.Birth_Year",
            "select singer.Name, singer.Birth_Year",
            "select t0.c5, singer.Birth_Year",
            "select singer.Birth_Year), singer.Citizenship",
            "select singer.Birth_Year, singer.Citizenship, singer.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I want to know the birth year and nationality of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need to know the birth years and countries of the singers above., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM SELECT-FROM",
            "SELECT.c2, SELECT.c4",
            "SELECT.c2, SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need to know the birth years and countries of the singers above., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select singer.Birth_Year, singer.Citizenship",
        "real_label": "select singer.Birth_Year, singer.Citizenship",
        "topk_preds": [
            "select singer.Birth_Year, singer.Citizenship",
            "select singer.Singer_ID, singer.Birth_Year, singer.Citizenship",
            "select singer.Name, singer.Birth_Year, singer.Citizenship",
            "select singer.Citizenship, singer.Birth_Year",
            "select singer.Birth_Year.c2, singer.Citizenship",
            "select singer.Birth_Year, singer.Citizenship, singer.Singer_ID",
            "select t0.c5, singer.Birth_Year",
            "select singer.Birth_Year, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need to know the birth years and countries of the singers above., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I need to know the birth years and nationalities of the singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM -UNION-SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I need to know the birth years and nationalities of the singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select singer.Birth_Year, singer.Citizenship",
        "real_label": "select singer.Birth_Year, singer.Citizenship",
        "topk_preds": [
            "select singer.Birth_Year, singer.Citizenship",
            "select singer.Singer_ID, singer.Birth_Year, singer.Citizenship",
            "select singer.Name, singer.Birth_Year, singer.Citizenship",
            "select singer.Citizenship, singer.Birth_Year",
            "select singer.Birth_Year), singer.Citizenship",
            "select t0.c5, singer.Birth_Year",
            "select singer.Birth_Year, singer.Citizenship, singer.Singer_ID",
            "select singer.Birth_Year, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I need to know the birth years and nationalities of the singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter the birth years and nationalities of the singers below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT.c2, SELECT.c4",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter the birth years and nationalities of the singers below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select singer.Birth_Year, singer.Citizenship",
        "real_label": "select singer.Birth_Year, singer.Citizenship",
        "topk_preds": [
            "select singer.Birth_Year, singer.Citizenship",
            "select singer.Singer_ID, singer.Birth_Year, singer.Citizenship",
            "select singer.Name, singer.Birth_Year, singer.Citizenship",
            "select singer.Citizenship, singer.Birth_Year",
            "select singer.Birth_Year.c2, singer.Citizenship",
            "select singer.Birth_Year), singer.Citizenship",
            "select t0.c5, singer.Birth_Year",
            "select singer.Birth_Year, singer.Citizenship, singer.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter the birth years and nationalities of the singers below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the birth years and nationalities of the singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM SELECT-FROM",
            "SELECT.c2, SELECT.c4",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the birth years and nationalities of the singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select singer.Birth_Year, singer.Citizenship",
        "real_label": "select singer.Birth_Year, singer.Citizenship",
        "topk_preds": [
            "select singer.Birth_Year, singer.Citizenship",
            "select singer.Singer_ID, singer.Birth_Year, singer.Citizenship",
            "select singer.Name, singer.Birth_Year, singer.Citizenship",
            "select singer.Citizenship, singer.Birth_Year",
            "select singer.Birth_Year), singer.Citizenship",
            "select t0.c5, singer.Birth_Year",
            "select singer.Birth_Year, singer.Net_Worth_Millions",
            "select singer.Birth_Year, singer.Citizenship, singer.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the birth years and nationalities of the singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the birth years and nationalities of the singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM",
        "label": "SELECT-FROM",
        "score": true,
        "real_pred": "SELECT-FROM",
        "real_label": "SELECT-FROM",
        "topk_preds": [
            "SELECT-FROM",
            "SELECT-FROM-UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT.c2, SELECT.c4",
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY",
            "SELECT.c2, SELECT-FROM",
            "SELECT-FROM SELECT-FROM"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the birth years and nationalities of the singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c2, t0.c4",
        "label": "select t0.c2, t0.c4",
        "score": true,
        "real_pred": "select singer.Birth_Year, singer.Citizenship",
        "real_label": "select singer.Birth_Year, singer.Citizenship",
        "topk_preds": [
            "select singer.Birth_Year, singer.Citizenship",
            "select singer.Singer_ID, singer.Birth_Year, singer.Citizenship",
            "select singer.Name, singer.Birth_Year, singer.Citizenship",
            "select singer.Citizenship, singer.Birth_Year",
            "select singer.Birth_Year), singer.Citizenship",
            "select t0.c5, singer.Birth_Year",
            "select singer.Birth_Year, singer.Net_Worth_Millions",
            "select singer.Birth_Year, singer.Citizenship, singer.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the birth years and nationalities of the singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Could you add the names of those singers whose country is not France below?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Could you add the names of those singers whose country is not France below?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, t0.c5",
            "select singer.Name - singer.Birth_Year",
            "select singer.Name - singer.Citizenship",
            "select singer.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Could you add the names of those singers whose country is not France below?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please list the names of singers who are not citizens of France below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please list the names of singers who are not citizens of France below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, t0.c5",
            "select singer.Name, t0.c6",
            "select singer.Name - singer.Citizenship",
            "select singer.Name - singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please list the names of singers who are not citizens of France below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me names of singers who are not citizens of France below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me names of singers who are not citizens of France below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, t0.c5",
            "select singer.Name, singer.Singer_ID",
            "select singer.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me names of singers who are not citizens of France below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship (France)). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please enter singers whose passport is not French below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-FROM-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please enter singers whose passport is not French below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c0",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select singer.Singer_ID",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Singer_ID",
            "select singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name",
            "select singer.Singer_ID, singer.Citizenship",
            "select distinct singer.Name, singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please enter singers whose passport is not French below., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers are not French Citizens?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers are not French Citizens?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select t0.c1",
        "score": false,
        "real_pred": "select distinct singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select singer.Name",
            "select distinct singer.Name, singer.Birth_Year",
            "select distinct singer.Name, singer.Citizenship",
            "select singer.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers are not French Citizens?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you list the singers who do not hold French citizenship here?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you list the singers who do not hold French citizenship here?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Citizenship",
            "select distinct singer.Name",
            "select distinct singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name",
            "select singer.Singer_ID"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you list the singers who do not hold French citizenship here?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Write down the names of singers who do not hold French citizenship., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Write down the names of singers who do not hold French citizenship., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Name, singer.Birth_Year",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name (or singer.Birth_Year)",
            "select singer.Name - singer.Citizenship",
            "select singer.Name (not singer.Birth_Year)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Write down the names of singers who do not hold French citizenship., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which singers do not hold French citizenship?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WITH-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-EXCEPT-SELECT-FROM-WHERE."
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which singers do not hold French citizenship?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select distinct singer.Name",
            "select singer.Singer_ID",
            "select distinct singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Citizenship",
            "select distinct singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which singers do not hold French citizenship?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the name of the highest-paid musician?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the name of the highest-paid musician?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name (or singer.Birth_Year)",
            "select singer.Name (singer.Net_Worth_Millions)",
            "select singer.Name the singer.Net_Worth_Millions",
            "select singer.Name, t0.c6"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the name of the highest-paid musician?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "singer song",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Who is the richest singer at present?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Who is the richest singer at present?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Singer_ID, singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name at singer.Net_Worth_Millions",
            "select singer.Name (singer.Net_Worth_Millions)",
            "select singer.Name ausinger.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Who is the richest singer at present?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: What's the name of the highest-paid singer in the world?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-ORDER BY-LIMIT",
        "label": "SELECT-FROM-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT (SELECT-FROM-ORDER BY-LIMIT)",
            "SELECT-FROM-ORDER BY-LIMIT, SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-SELECT-FROM-ORDER BY-LIMIT",
            "SELECT-FROM-ORDER BY-LIMIT-UNION-SELECT-FROM-WHERE"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: What's the name of the highest-paid singer in the world?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select t0.c1",
        "score": true,
        "real_pred": "select singer.Name",
        "real_label": "select singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, singer.Net_Worth_Millions",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name (or singer.Birth_Year)",
            "select singer.Name (or singer.Net_Worth_Millions)",
            "select singer.Name the singer.Net_Worth_Millions",
            "select singer.Name (singer.Net_Worth_Millions)",
            "select singer.Name (single-value)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: What's the name of the highest-paid singer in the world?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: For each nationality, how many singers originate from that country?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GEOGRAPHIC-GROUP BY",
            "SELECT-FROM-WHERE-GROUP BY",
            "SELECT-FROM-GROUP BY, count(*)",
            "SELECT-FROM-GROUP BY -ORDER BY",
            "SELECT-FROM -GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: For each nationality, how many singers originate from that country?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4, count(*)",
        "label": "select t0.c4, count(*)",
        "score": true,
        "real_pred": "select singer.Citizenship, count(*)",
        "real_label": "select singer.Citizenship, count(*)",
        "topk_preds": [
            "select singer.Citizenship, count(*)",
            "select count(*), singer.Citizenship",
            "select singer.Citizenship.c4, count(*)",
            "select singer.Citizenship, count(*)",
            "select singer.Citizenship, count(*), singer.Singer_ID",
            "select singer.Citizenship, count(*), singer.Net_Worth_Millions",
            "select singer.Citizenship., count(*)",
            "select singer.Citizenship, count(*), singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: For each nationality, how many singers originate from that country?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me information about the most common citizen of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me information about the most common citizen of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select singer.Citizenship",
        "real_label": "select singer.Citizenship",
        "topk_preds": [
            "select singer.Citizenship",
            "select singer.Citizenship, singer.Name",
            "select singer.Citizenship, t0.c5",
            "select singer.Citizenship, count(*)",
            "select singer.Citizenship, singer.Net_Worth_Millions",
            "select singer.Name, singer.Citizenship",
            "select singer.Citizenship, sum(singer.Net_Worth_Millions)",
            "select singer.Name, singer.Birth_Year"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me information about the most common citizen of singers., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Please tell me the singers of which nationality are the most common., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Please tell me the singers of which nationality are the most common., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select singer.Citizenship",
        "real_label": "select singer.Citizenship",
        "topk_preds": [
            "select singer.Citizenship",
            "select singer.Citizenship, count(*)",
            "select singer.Citizenship, singer.Name",
            "select singer.Name, singer.Citizenship",
            "select singer.Citizenship the most, singer.Name",
            "select singer.Name, singer.Birth_Year",
            "select singer.Citizenship de singer.Name",
            "select singer.Citizenship-, count(*)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Please tell me the singers of which nationality are the most common., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Which is the most common passport for singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "real_label": "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
        "topk_preds": [
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT (SELECT-FROM-GROUP BY-LIMIT)",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Which is the most common passport for singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c4",
        "label": "select t0.c4",
        "score": true,
        "real_pred": "select singer.Citizenship",
        "real_label": "select singer.Citizenship",
        "topk_preds": [
            "select singer.Citizenship",
            "select singer.Citizenship de facto-dominance-gROUP BY-ORDER BY-LIMIT",
            "select singer.Citizenship de facto-dominance-GROUP BY-ORDER BY-LIMIT",
            "select singer.Citizenship, t0.c5",
            "select singer.Citizenship, singer.Net_Worth_Millions",
            "select singer.Citizenship de facto-dominance-grpois-t0.c5",
            "select singer.Citizenship de facto-dominance-grpois-singer.Citizenship",
            "select singer.Citizenship de facto-dominance-grpois-singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Which is the most common passport for singers?, database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Give me the maximum wealth for each category according to their nationality., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-GROUP BY",
        "label": "SELECT-FROM-GROUP BY",
        "score": true,
        "real_pred": "SELECT-FROM-GROUP BY",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY maximum(t0.c3), t0.c4",
            "SELECT-FROM-GROUP BY SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY UNION-SELECT-FROM",
            "SELECT-FROM-GROUP BY-ORDER BY maximum(t0.c3)",
            "SELECT-FROM-GROUP BY (ORDER BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Give me the maximum wealth for each category according to their nationality., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select max(t0.c3), t0.c4",
        "label": "select t0.c4, max(t0.c3)",
        "score": false,
        "real_pred": "select max(singer.Net_Worth_Millions), singer.Citizenship",
        "real_label": "select singer.Citizenship, max(singer.Net_Worth_Millions)",
        "topk_preds": [
            "select max(singer.Net_Worth_Millions), singer.Citizenship",
            "select singer.Citizenship, max(singer.Net_Worth_Millions)",
            "select maximum(singer.Net_Worth_Millions), singer.Citizenship",
            "select min(singer.Net_Worth_Millions), singer.Citizenship",
            "select maxima(singer.Net_Worth_Millions), singer.Citizenship",
            "select sum(singer.Net_Worth_Millions), singer.Citizenship",
            "select maximal(singer.Net_Worth_Millions), singer.Citizenship",
            "select singer.Citizenship, max(singer.Net_Worth_Millions)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Give me the maximum wealth for each category according to their nationality., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0",
        "label": "t0",
        "score": true,
        "real_pred": "singer",
        "real_label": "singer",
        "topk_preds": [
            "singer",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the singers whose songs sold more than 300,000 copies., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the singers whose songs sold more than 300,000 copies., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t1.c2",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select song.Singer_ID",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select song.Singer_ID",
            "select song.Singer_ID, song.Title",
            "select song.Singer_ID, song.Sales",
            "select distinct song.Singer_ID",
            "select song.Singer_ID, singer.Name",
            "select singer.Name, song.Singer_ID",
            "select song.Singer_ID, max(song.Sales)",
            "select song.Singer_ID (song.Title)"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the singers whose songs sold more than 300,000 copies., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t1",
        "label": "t0 t1",
        "score": false,
        "real_pred": "song",
        "real_label": "singer song",
        "topk_preds": [
            "song",
            "singer song",
            "",
            "",
            "",
            "song singer song",
            "song singer",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like to see different names of singers that had songs which sold over 300 000 copies., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DIFFERENT",
            "SELECT-FROM-WHERE-VARIATION"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like to see different names of singers that had songs which sold over 300 000 copies., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select different singer.Name",
            "select singer.Name",
            "select distinct singer.Name, singer.Birth_Year",
            "select distinct singer.Name, song.Singer_ID",
            "select distinct singer.Name, singer.Singer_ID",
            "select unique singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like to see different names of singers that had songs which sold over 300 000 copies., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Show me all the names of singers who had their songs sold more than 300,000 copies., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY-HAVING"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Show me all the names of singers who had their songs sold more than 300,000 copies., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select t0.c1",
        "label": "select distinct t0.c1",
        "score": false,
        "real_pred": "select singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select singer.Name",
            "select singer.Name, song.Singer_ID",
            "select song.Singer_ID",
            "select singer.Name, singer.Birth_Year",
            "select singer.Name, singer.Singer_ID",
            "select distinct singer.Name",
            "select singer.Name, song.Singer_ID",
            "select singer.Name, singer.Name"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Show me all the names of singers who had their songs sold more than 300,000 copies., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: Can you tell me about the different names of those singers whose songs sold more than 300 000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-WHERE",
        "score": true,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-WHERE",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-UNION-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-GROUP BY-HAVING",
            "SELECT-FROM-WHERE-INTERSECT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-DISTINCT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-EXCEPT-SELECT-FROM-WHERE",
            "SELECT-FROM-WHERE-ORDER BY-LIMIT",
            "SELECT-FROM-WHERE-DIFFERENT"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: Can you tell me about the different names of those singers whose songs sold more than 300 000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "select distinct t0.c1",
        "label": "select distinct t0.c1",
        "score": true,
        "real_pred": "select distinct singer.Name",
        "real_label": "select distinct singer.Name",
        "topk_preds": [
            "select distinct singer.Name",
            "select distinct singer.Name, song.Singer_ID",
            "select count(distinct singer.Name)",
            "select distinct singer.Name, singer.Birth_Year",
            "select distinct singer.Name, song.Singer_ID",
            "select different singer.Name",
            "select distinct singer.Name song.Singer_ID",
            "select distinct singer.Name, singer.Net_Worth_Millions"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: Can you tell me about the different names of those singers whose songs sold more than 300 000., database: Database: singer. t0: singer(c0: singer_id, c1: name, c2: birth_year, c3: net_worth_millions, c4: citizenship). t1: song(c0: song_id, c1: title, c2: singer_id, c3: sales, c4: highest_position) (c2) refers to t0(c0).",
        "prediction": "t0 t1",
        "label": "t0 t1",
        "score": true,
        "real_pred": "singer song",
        "real_label": "singer song",
        "topk_preds": [
            "singer song",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "input": "Translate the question into a SQL structure according to the database. question: I would like details about all the properties under that particular property type code., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "SELECT-FROM-WHERE",
        "label": "SELECT-FROM-GROUP BY",
        "score": false,
        "real_pred": "SELECT-FROM-WHERE",
        "real_label": "SELECT-FROM-GROUP BY",
        "topk_preds": [
            "SELECT-FROM-WHERE",
            "SELECT-FROM-GROUP BY-HAVING",
            "SELECT-FROM-GROUP BY-ORDER BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT",
            "SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-UNION-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-ORDER BY-LIMIT-INTERSECT-SELECT-FROM-GROUP BY",
            "SELECT-FROM-GROUP BY-UNION-SELECT-FROM-GROUP BY"
        ]
    },
    {
        "input": "Generate the SELECT sub-clause of this question according to the database. question: I would like details about all the properties under that particular property type code., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "select t3.c25",
        "label": "select t1.c1",
        "score": false,
        "real_pred": "select Properties.other_property_details",
        "real_label": "select Ref_Property_Types.property_type_description",
        "topk_preds": [
            "select Properties.other_property_details",
            "select Properties.property_type_code, Properties.other_property_details",
            "select Properties.property_type_code, Properties.date_on_market",
            "select Properties.property_address, Properties.other_property_details",
            "select Properties.property_type_code, Properties.property_address",
            "select Properties.property_address, Properties.shp_feature_3",
            "select Properties.property_type_code, Properties.shp_feature_3",
            "select Properties.property_address, Properties.room_count"
        ]
    },
    {
        "input": "Generate the relevant tables of this question according to the database. question: I would like details about all the properties under that particular property type code., database: Database: real_estate_properties. t0: ref_feature_types(c0: feature_type_code, c1: feature_type_name). t1: ref_property_types(c0: property_type_code, c1: property_type_description). t2: other_available_features(c0: feature_id, c1: feature_type_code, c2: feature_name, c3: feature_description). t3: properties(c0: property_id, c1: property_type_code, c2: date_on_market, c3: date_sold, c4: property_name, c5: property_address, c6: room_count, c7: vendor_requested_price, c8: buyer_offered_price, c9: agreed_selling_price, c10: apt_feature_1, c11: apt_feature_2, c12: apt_feature_3, c13: fld_feature_1, c14: fld_feature_2, c15: fld_feature_3, c16: hse_feature_1, c17: hse_feature_2, c18: hse_feature_3, c19: oth_feature_1, c20: oth_feature_2, c21: oth_feature_3, c22: shp_feature_1, c23: shp_feature_2, c24: shp_feature_3, c25: other_property_details). t4: other_property_features(c0: property_id, c1: feature_id, c2: property_feature_description).",
        "prediction": "t3",
        "label": "t1 t3",
        "score": false,
        "real_pred": "Properties",
        "real_label": "Ref_Property_Types Properties",
        "topk_preds": [
            "Properties",
            "",
            "Properties Other_Property_Features",
            "",
            "",
            "",
            "",
            ""
        ]
    }
]